<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>[动态规划] 背包问题归纳 | River&#39;s Blog</title>

<link rel="shortcut icon" href="https://river861.github.io/favicon.ico?v=1601382792921">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://river861.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            River&#39;s Blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于我
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1601382792921" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
		<div class="post-content-wrapper">
			<div class="post-detail gt-bg-theme-color-second">
				<article class="gt-post-content">
					<h2 class="post-title">
					  [动态规划] 背包问题归纳
					</h2>
					<div class="post-info">
					  <span>
						2020-09-04
					  </span>
					  <span>
						13 min read
					  </span>
					  
						<a href="https://river861.github.io/tag/tazjCHBPT/" class="post-tag">
						  # 算法
						</a>
					  
					</div>
					
					<div class="post-content">
						<p>背包问题是非常经典的一类动态规划题目，包括01背包、完全背包、多重背包等。</p>
<!-- more -->
<h3 id="一-01背包问题">一、01背包问题</h3>
<h4 id="1-定义">1. 定义</h4>
<p>有n件物品和一个容量为V的背包。第i件物品的体积（volumn）是v[i]，价值（worth）是w[i]，问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析">2. 解析</h4>
<ul>
<li>每种物品只有选和不选两种。我们可以使用多阶段动态规划的思想来解决。<br>
用dp[i][j]表示前i个物品（或用“从第i个物品开始的后面所有物品”的反向定义也行）装入容量为j的背包中的最大价值量。<br>
则转移方程为：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中每多考虑一个物品i，代表一个“阶段”。括号第一项表示选，第二项表示不选。</p>
<ul>
<li>**（优化）**由于每一项都是依赖于i-1，因此可以使用滚动数组来优化空间复杂度：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[j] = max(dp[j], dp[j - v[i]] + w[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中注意使用滚动数组时，j的遍历必须逆序，来保证等号右边使用的dp值是上一阶段的结果值.</p>
<ul>
<li>如果需要打印路径，则必须使用第一种写法，否则可以使用优化写法来节省空间。</li>
</ul>
<h4 id="3-模板">3. 模板</h4>
<ul>
<li>普通写法</li>
</ul>
<pre><code>int V, n, v[maxn], w[maxn], dp[maxn][maxv];

for(int j = 0; j &lt;= V; j ++) dp[0][j] = 0;
for (int i = 1; i &lt;= n; i ++) {
    for (int j = v[i]; j &lt;= V; j ++) {
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
    }
}
</code></pre>
<ul>
<li>优化写法</li>
</ul>
<pre><code>int V, n, v[maxn], w[maxn], dp[maxv];

for (int i = 1; i &lt;= n; i ++) {
    for (int j = V; j &gt;= w[i]; j --) {  // 逆序遍历
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/a80587c9c2204f40bc802e4403db9587">Uva 624</a><br>
Luogu 2925 干草出售<br>
Luogu 1616 疯狂的采药<br>
Hdu 3466 Proud Merchants</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="二-完全背包问题">二、完全背包问题</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>有n种物品和一个容量为V的背包，每种物品都有无限个。第i种物品的体积为v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析-2">2. 解析</h4>
<ul>
<li>由于有无限个，所以每种物品的选择就有无限种了，因此我们不能用01背包的套路了，需要换一种思路。我们先回顾一下01背包中的优化写法，之所以j要逆序遍历是为了使得等号右边的dp值对应的是上一物品计算完后的dp值。而回到完全背包问题，由于物品有无限个，因此对于已经选择了当前物品的dp值，我们依然可以继续添加当前物品，直到达到背包上限为止。这样一想，完全背包问题的递推式就大概是：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], dp[i][j - v[i]] + w[j])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中第1、2项和01背包一样，第3项表示继续添加当前物品。</p>
<ul>
<li>然而上述递推式实在是比较混乱，因此实际上大多数情况下使用的是滚动数组的版本：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[j] = max(dp[j], dp[j - v[i]] + w[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>可以看到这里和01背包的转移方程是一样的，但是实际用的时候这里j的遍历顺序必须为正序。</p>
<ul>
<li>
<p>在笔者看来，完全背包问题的写法其实还可以通过刷表法来理解。就是对于每一种新的物品i，用它来不断刷新所有体积的背包的状态（最大价值量）。j的顺序遍历使得刷新的效果可以“叠加”，从而实现放入多个物品的效果。</p>
</li>
<li>
<p>实际上紫薯还提供里完全背包的另一种思路，即看成是带权的DAG的最长路问题，不过其代码量相比于递推式要稍微大一些，因此这里略。感兴趣的可以看一下下面的例题，有使用了这种方法的题解。</p>
</li>
</ul>
<h4 id="3-模板-2">3. 模板</h4>
<pre><code>int V, n, v[maxn], w[maxn], dp[maxv];

fill(dp, dp + V + 1, 0);
for(int i = 1; i &lt;= n; i ++) {
    for(int j = v[i]; j &lt;= V; j ++) {  // 顺序遍历
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
</code></pre>
<h4 id="4-例题-2">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/f52f039856de40f798b881ac15e0a346">Hdu 4508</a><br>
Hdu 1114 Piggy-Bank<br>
Luogu 1853 投资的最大效益</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="三-多重背包问题">三、多重背包问题</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>有n种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件体积是v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析-3">2. 解析</h4>
<ul>
<li>
<p>多重背包问题限制了物品的数目，这里有一种显然的思路就是，把每一“个”物品看作一个不同的“种”物品，然后用01背包去做，但是这样大概率为超时（笑），时间复杂度为O(V*∑p[i])</p>
</li>
<li>
<p>顺着上述思路，有一种二进制法可以将时间复杂度降到O(V*∑lgp[i])，并且一般够用了😀。<br>
它的原理就是将一个数量为p[i]，价值为v[i]的物体拆分成 1、2、4、8...这若干份（每一份右2的幂次份原物体构成，构成的新物体价值为kw[i]，体积为kv[i]），然后 注意最后不足2的幂次的数量也单独做成1份，这样物体的总数量就降为了 O(∑lgn)。然后就可以按照01背包问题的套路来处理这∑lgn个新物体了。<br>
正确性是由二进制原理保证的：因为原来可能选择的1~p[i]个原物体一定可以被替换为新物体的组合。</p>
</li>
<li>
<p>实际上还有一种使用单调队列的优化方式，但由于技巧性比较高，一般用不到</p>
</li>
</ul>
<h4 id="3-模板-3">3. 模板</h4>
<pre><code>int V, n, v[n], w[n], p[n], dp[maxv];  // p[i]表示原物体i的数量限制

fill(dp, dp + V + 1, 0);
for(int i = 0; i &lt; n; i ++) {
    for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) {  // 每一个新物体由k个原物体组成
        if(k &gt; num) k = num;  // 最后不足2的幂次的单独一份
        num -= k;
        for(int j = V; j &gt;= k * v[i]; j --) {  // 对新物体使用01背包问题处理，这里使用的是01背包问题的滚动数组模板，当然也可以不用
            dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]);
        }
    }
}
</code></pre>
<p>其实还有另一种写法是将原物体分为新物体后用一个新数组装起来，然后再进行01背包操作，区别其实不大。这里直接写在外层嵌套了，因为代码量少一些所以我喜欢😀。</p>
<h4 id="4-例题-3">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/435420c882a44e2881fa142ebf83ba94">Hdu1059</a><br>
Luogu P1776 宝物筛选</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="四-混合背包问题">四、混合背包问题</h3>
<h4 id="1-定义-4">1. 定义</h4>
<p>如果将前面三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的有限次（多重背包），问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析-4">2. 解析</h4>
<ul>
<li>
<p>首先01背包和多重背包在模板上只有j的遍历顺序不同，因此我们可以通过一个if语句来区分这两种背包，然后分别进行不同顺序的内层循环即可</p>
</li>
<li>
<p>然后其实01背包是一种特殊的多重背包，即01背包是数量上限为1的多重背包问题，这样一想其实就只用写多重背包的代码即可</p>
</li>
</ul>
<h4 id="3-模板-4">3. 模板</h4>
<pre><code>int V, n, v[n], w[n], p[n], dp[maxv];  // p[i]表示每个物品的件数，-1代表无穷个

for (int i = 1; i &lt;= n; i++)
    if (p[i] == -1)  // 完全背包
        for (int j = v[i]; j &lt;= V; j++)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    else {
        for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) {  // 01背包和多重背包
            if(k &gt; num) k = num;
            num -= k;
            for(int j = V; j &gt;= k * v[i]; j --) {  // 01背包只会执行k=1这一次
                dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]);
            }
        }
    }
</code></pre>
<h4 id="4-例题-4">4. 例题</h4>
<p>Luogu P1833 樱花<br>
HDU 3535 AreYouBusy</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="五-二维背包问题">五、二维背包问题</h3>
<h4 id="1-定义-5">1. 定义</h4>
<p>对于每件物品，具有两种不同的代价v[i], g[i]，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）V, G，物品的价值为v[i]v[i]。问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析-5">2. 解析</h4>
<p>这个其实比较简单，就是让dp数组增加一维度即可。<br>
即dp[i][j][k]表示前i件物品装入两种代价分别为j和k的背包时可获得的最大价值量。滚动数组后就变成dp[j][k]。直接看代码会就一目了然了。</p>
<h4 id="3-模板-5">3. 模板</h4>
<pre><code>int V, n, v[n], g[maxn], w[n], p[n], dp[maxv][maxg];  // v[i]和g[i]分别为两种代价
for (int i = 1; i &lt;= n; i ++)
    for (int j = V; j &gt;= v[i]; j --)
        for (int k = G; k &gt;= g[i]; k --)
            dp[j][k] = max(dp[j][k], dp[j - v[i]][k - g[i]] + w[i]);
</code></pre>
<h4 id="4-例题-5">4. 例题</h4>
<p>Luogu 1507 NASA的食物计划<br>
HDU 2159 FATE</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="六-分组背包问题">六、分组背包问题</h3>
<h4 id="1-定义-6">1. 定义</h4>
<p>有n件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。问如何选择物品装入背包可使价值总和最大。</p>
<h4 id="2-解析-6">2. 解析</h4>
<p>其实分组背包可以把每个组看作一个物体，即这其实就是一个01背包问题，每个物体依然还是选和不选两种状态，只不过选的时候可以从组内的多个原物体种任意选一个。同样看代码就一目了然了。</p>
<h4 id="3-模板伪代码">3. 模板（伪代码）</h4>
<pre><code>for (所有的组k)
    for (int j = V; j &gt;= 0; j--)
        for (所有属于组k的i)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i])
</code></pre>
<h4 id="4-例题-6">4. 例题</h4>
<p>Luogu 1757 通天之分组背包<br>
HDU 1712 ACboy needs your help</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<h3 id="七-背包问题的其它要素">七、背包问题的其它要素</h3>
<h4 id="1-问法不同">1. 问法不同</h4>
<ul>
<li>最大值、最小值： 一次对应max、min即可</li>
<li>方案数目：改为sum，同时注意初始化可能需要改变</li>
</ul>
<h4 id="2-范围不同">2. 范围不同</h4>
<ul>
<li>
<p>最大化、最小化：<br>
初始化时对于前0个物品的价值量dp[i][0...V]全部初始化为0，这样即使最终的dp[n][V]未达到边界值也能有最值答案（根据提问内容不同可能会有所改变）</p>
</li>
<li>
<p>恰好装满<br>
初始化时dp[i][0]=0, dp[i][1...V]全部初始化为 -INF或INF，这样不能刚好达到V的方案的最终价值量就为 -INF或INF（根据提问内容不同可能会有所改变）</p>
</li>
</ul>
<h4 id="3-打印路径">3. 打印路径</h4>
<ul>
<li>
<p>不使用滚动数组的写法，即有完整的dp[i][j]记录，然后通过递归的方法print_ans打印路径。这是我个人比较喜欢的写法，因为不用额外维护存储路径信息的数组😀</p>
</li>
<li>
<p>维护一个记录路径信息的数组<br>
记录下每个状态的最优值是由状态转移方程的哪一项推出来的。然后就可以根据这条记录找到上一个状态，从上一个状态接着向上推，得到整条路径。</p>
</li>
</ul>
<h4 id="3-情景">3. 情景</h4>
<p>区分背包问题是简单的，但是.....<br>
如何才能发现一道题考察的是背包问题呢？<br>
这就需要多刷题目，直到看到题目的某个情景就能反应出是在考察背包问题。</p>
<p>当然我还没到那种境界就是了hhh😀</p>
<p><br><center><strong>*    *   *</strong></center><br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">参考博客</a></p>

					</div>
				</article>
			</div>
			<div class="toc-container">
				<ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%B8%80-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">一、01背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF">3. 模板</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">二、完全背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-2">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90-2">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF-2">3. 模板</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98-2">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">三、多重背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-3">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90-3">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF-3">3. 模板</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98-3">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">四、混合背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-4">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90-4">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF-4">3. 模板</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98-4">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">五、二维背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-5">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90-5">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF-5">3. 模板</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98-5">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">六、分组背包问题</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-6">1. 定义</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90-6">2. 解析</a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF%E4%BC%AA%E4%BB%A3%E7%A0%81">3. 模板（伪代码）</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98-6">4. 例题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B6%E5%AE%83%E8%A6%81%E7%B4%A0">七、背包问题的其它要素</a>
<ul>
<li><a href="#1-%E9%97%AE%E6%B3%95%E4%B8%8D%E5%90%8C">1. 问法不同</a></li>
<li><a href="#2-%E8%8C%83%E5%9B%B4%E4%B8%8D%E5%90%8C">2. 范围不同</a></li>
<li><a href="#3-%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84">3. 打印路径</a></li>
<li><a href="#3-%E6%83%85%E6%99%AF">3. 情景</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

			</div>
		</div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://river861.github.io/post/tan-xin-suan-fa-qu-jian-wen-ti-gui-na/" class="post-title gt-a-link">
                    [贪心算法] 区间问题归纳
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">Re: start</div>
    <div class="social-container">
        
            
                <a href="https://github.com/River861" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Copyright © 2020  <a href="https://github.com/River861" target="_blank">River</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://river861.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>

</body>
</html>
