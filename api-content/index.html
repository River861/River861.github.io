{"posts":[{"title":"[图论] 最大匹配问题归纳","content":"包括匈牙利算法和Hopcroft_karp算法。 一、定义 即在一个二分图中，找到最大的匹配对数。每个点只能最多和另外一个点配对。 二、情景 为了方便理解，这里考虑一下最大匹配场景： 有一列男生1..n，还有一列女生女生n + 1..n + m。即结点分开存； 愿意配对的男女会有边相连； 要求出男女配对的最大匹配数目。 三、解析 有两种方法可以解决最大匹配问题：匈牙利算法、Hopcroft_karp算法。 匈牙利算法 时间复杂度O(VE) 优点是代码简单，不超时时优先使用 Hopcroft_karp算法 时间复杂度O(sqrt(V)*E) 优先时更快，缺点是代码复杂，类似最大流 其实该算法就是将匈牙利算法中的find部分通过bfs分段，一点点来找匹配而已。 四、匈牙利算法 模板 bool find(int u){ for(int v : G[u]){ if(vis[v]) continue; vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int maxMatch(){ int res = 0; for(int i = 1; i &lt;= n; i ++){ // 男生逐个去邀请追女生 memset(vis, 0, sizeof(vis)); // vis用于标记对象点是否判断过, 每次都要清零 if(find(i)) res ++; // 找到一个心仪的女生了 } return res; } 五、Hopcroft_karp算法 模板 /* 类似最大流算法 数组解释： dist[i]: 层数标记 belong[i]: i 的对象 */ bool bfs(){ queue&lt;int&gt; queue; memset(dist, -1, sizeof(dist)); fin_dist = INF; // dist为当前终点的层数标记 for(int u = 1; u &lt;= n; u ++) if(!belong[u]) que.push(u), dist[u] = 0; // 若干起点 while(!que.empty()){ int u = que.front(); que.pop(); if(dist[u] &gt; fin_dist) break; // 到增广路终点层数的点都标记好了就跳出, 后面不再标记 for(int v : G[u]){ if(dist[v] == -1){ // 未被标记 dist[v] = dist[u] + 1; if(!belong[v]) fin_dist = dist[v]; // 找到增广路, 确定增广路终点层数 else dist[belong[v]] = dist[v] + 1, que.push(belong[v]); // 继续bfs } } } return dist != INF; } bool find(int u){ if(dist[u] &gt; fin_dist) return 0； for(int v : G[u]){ if(vis[v] || dist[v] != dist[u] + 1) continue; // 询问过 || 不是上下层关系 则跳过 vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int Hopcroft_karp(){ int res = 0; while(bfs()){ // 搜索有无增广路 memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i ++) if(!belong[i] &amp;&amp; find(i)) res ++; // 若没有女朋友 &amp;&amp; 能找到 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-da-pi-pei-wen-ti-gui-na/"},{"title":"[图论][经典] 常见的图论方法归纳","content":"比如dfs、bfs、并查集、链式前向星、判断二分图等。 一、dfs 1. 定义 dfs，即深度优先搜索。顾名思义，即尽可能递归到达最深处，然后再回溯，以此类推，直到遍历完整个图。 2. 解析 通过递归实现。 主要用于解决找迷宫路径等问题。 dfs代码比bfs简单。 要领： 用vis数组维护是否走过，记得清零； dfs中continue的条件分三类：出界、已走过、不是所求。不要遗漏了。 3. 模板 const int Fx[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}; // 方向 string a[maxn]; // 记录地图 bool vis[maxn][maxm]; // vis数组记录是否走过 void dfs(int x, int y) { vis[x][y] = 1; for(int k = 0; k &lt; 8; k ++) { int nx = x + Fx[k][0], ny = y + Fx[k][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '*') continue; // 出界、已走过、不是所求 dfs(nx, ny); // 递归 } } 4. 例题 Uva 572 * * * 二、bfs 1. 定义 bfs，即广度优先搜索。顾名思义，即先走完这一层，再走下一层，以此类推，直到遍历完整个图。 2. 解析 通过队列实现。 主要用于解决简单（权值为1）的最短路问题。 要领： bfs问题要先想清楚**“状态点”如何定义，然后维护相应维度的vis、a数组（地图）。 如果需要打印路径需要用p数组**进行父节点的存储。 debug时不要太着急，可以将打印信息写的详细一点，这样才能有利于更快地发现问题！ 注意区分Dijkstra模板：bfs用的是普通队列，vis数组的更新位置在push后。 3. 变式 双向bfs 先通过逆向bfs求出距离d[maxn]，然后再进行正向的“bfs”，这样就能实现一些比较复杂的最短路径问题。 复杂状态的表示 有时后一些状态点具有很多维度（比如八数码），或取值范围很大（超过1e8），这时没有办法通过vis数组来存储，因为会爆空间。 这时可以考虑这些方法来保存vis状态：set、哈希法（推荐）、康托展开。 4. 模板 const int Fx[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; // 方向 struct node { // 队列中的结点 int x, y, dist; node(int x, int y, int dist) : x(x), y(y), dist(dist) {} }; int a[maxn][maxm], vis[maxn][maxm], ans; void bfs(int x0, int y0) { queue&lt;node&gt; que; que.push(node(x0, y0, 0)), vis[x0][y0] = 1; // 入队后紧接着更新vis while(!que.empty()) { node u = que.front(); que.pop(); if(u.x == n - 1 &amp;&amp; u.y == m - 1) { // 退出条件（可选） ans = u.dist; break; } for(int i = 0; i &lt; 4; i ++) { int nx = u.x + Fx[i][0], ny = u.y + Fx[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '#') continue; que.push(node(nx, ny, u.dist + 1)), vis[nx][ny] = 1; // 入队后紧接着更新vis } } } 5. 例题 Uva 1600 Uva 1599 Uva 10085 Uva 816 * * * 三、并查集 1. 定义 将若干点进行加边联通，每个连通块形成一个代表元Fa[i]（i为连通块中的任意一点）。 2. 解析 并查集通常用于解决与连通相关的图论问题。 优化方法有：路径压缩、启发式连接。一般为了方便，只是用路径压缩就足够了。 3. 变式 在一些比较复杂的题目中，除了要维护父子关系，要需要维护其它的关系，这个时候需要 使用额外的辅助数组。 4. 模板 普通并查集 int n, Fa[maxn]; // 并查集要使用的Fa数组 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); // 路径压缩 } int main() { ...... for(int i = 1; i &lt;= n; i ++) Fa[i] = i; // Fa初始化 ...... for(const auto&amp; e : E) { // 逐条加边 int u = find(e.u), v = find(e.v); if(u == v) continue; // 若连通 Fa[u] = v; // 若不连通则将其连通 ...... } ..... } 复杂并查集 int Fa[maxn], dist[maxn]; // 辅助数组：到father的距离（非路径压缩的距离） int find(int x) { if(Fa[x] == x) return x; int fx = Fa[x]; Fa[x] = find(fx); dist[x] += dist[fx]; // 在回溯过程中更新，需要用到原father即fx return Fa[x]; } 5. 例题 最小生成树专题 * * * 四、链式前向星 1. 定义 一种比vector快且省空间的存图方法。 2. 解析 链式向前星 就是一种用一个链表来存放每个结点的所有出边的结构，新的边从链表头插入，用于加快读图。 链表头数组：head[maxn]，head[u]指向一条包含了u的所有邻接边的链表 存所有边：E[maxm] 边序号：cnt 3. 模板 struct edge { int to, w, next; edge() {} edge(int to, int w, int next) : to(to), w(w), next(next) {} } E[maxm]; // 用链式向前星来存图 int cnt, head[maxn]; // head[u]指向一条包含了u的所有邻接边的链表 void addEdge(int u, int v, int w) { E[cnt] = edge(v, w, head[u]); // 从链表的头部插入 head[u] = cnt ++; // 更改头指针 } int main() { ...... fill(head, head + n + 1, -1); // 初始化链表头，-1表示链表尾部 cnt = 1; // cnt表示当前加入的边序号 while(m --) { ...... addEdge(u, v, w); ...... } ...... for(int i = head[u]; ~i; i = E[i].next) { // 遍历u的所有出边的方法 int v = E[i].to, w = E[i].w; ...... } } 4. 例题 Poj 3159 * * * 五、判断二分图 1. 定义 判断一个图是否为二分图。 2. 解析 通过 染色法 实现。 用 1 和 -1 两种颜色给图的点染色，用col[maxn]来存放点的颜色, 0 表示还没染色。 若无法相间染色，则不是二分图，否则是。 3. 模板 bool dye(int u, int color){ col[u] = color; // 先染色 for(int v : G[u]){ if(!col[v] &amp;&amp; !dye(v, -color)) return 0; // 下一个点没染色 就染上不同色，染不上则失败 else if(col[v] == color) return 0; // 若下一个点染了色且和当前点颜色相同， 则必不是二分图 } return 1; } int main() { ...... bool ok = 1; // 是否是二分图 for(int i = 1; ok &amp;&amp; i &lt;= n; i ++) { if(!col[i] &amp;&amp; !dye(i, 1)) ok = 0; } ...... } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-jing-dian-chang-jian-de-tu-lun-fang-fa-gui-na/"},{"title":"[图论] 复杂的图论问题归纳","content":"比如LCA问题、最大流问题等。 一、求最近公共祖先结点（LCA） 1. 定义 LCA（Lowest Common Ancestors），即最近公共祖先，是指在有根树中找出某两个结点u和v最近的公共祖先结点。 2. 解析 这里只说一种我个人比较喜欢的在线算法：欧拉序 + RMQ 时间复杂度：预处理 O(n+nlgn)，查询只需要O(1) 原理： 欧拉序 就是在dfs遍历一棵树时经过的结点序列（包括回溯时经过的结点），显然两个结点u、v的最近公共祖先就是 欧拉序中 区间[u, v] 中深度最小的结点。（其中u、v指的是u、v在欧拉序中的第一次出现，即递归过程中的记录） 因此我们只需要通过一遍dfs得到欧拉序euler[2 * maxn]、对应的结点深度dep[2 * maxn]，以及每个结点在欧拉序中的位置 pos[maxn]，就可以通过RMQ在O(1)实现内找到欧拉序中 区间[pos[u], pos[v]] 中深度最小的结点位置。 需要维护的结构： euler[2 * maxn]：欧拉序 dep[2 * maxn]：欧拉序中结点对应的深度 pos[maxn]：每个结点在欧拉序中第一次出现的位置（对应于进入递归的时候） cnt：欧拉序长度 dp[2 * maxn][log_2maxn = 25]：对欧拉序根据dep进行RMQ预处理，dp[i][j]表示区间[i，i+2^j)中深度最小的 结点下标 为了防止混乱，规定RMQ存储、询问的是区间中深度最浅的 结点下标值，并且也是通过 结点下标区间 进行询问。之后只需要利用euler数组即可映射到对应的点。另外，区间表示为 左闭右开。 3. 模板 int n, m, s; vector&lt;int&gt; G[maxn]; int cnt, euler[2 * maxn], dep[2 * maxn], pos[maxn]; int dp[2 * maxn][log_2maxn]; void dfs(int u, int fa, int d) { pos[u] = cnt, euler[cnt] = u, dep[cnt] = d, cnt ++; for(int v : G[u]) if(v != fa) { dfs(v, u, d + 1); euler[cnt] = u, dep[cnt] = d, cnt ++; } } void init_RMQ() { for(int i = 0; i &lt; cnt; i ++) dp[i][0] = i; // 最短的区间 for(int j = 1; (1 &lt;&lt; j) &lt;= cnt; j ++) { // 注意先计算小区间，所以先从小到大遍历j for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; cnt; i ++) { int idx1 = dp[i][j - 1], idx2 = dp[i + (1 &lt;&lt; (j-1))][j - 1]; dp[i][j] = (dep[idx1] &lt; dep[idx2] ? idx1 : idx2); // RMQ中存放的是深度最小结点的下标值 } } } int min_RMQ(int l, int r) { int k = log2(r - l); int idx1 = dp[l][k], idx2 = dp[r - (1 &lt;&lt; k)][k]; return dep[idx1] &lt; dep[idx2] ? idx1 : idx2; } int main() { ...... dfs(s, -1, 0); // 求欧拉序euler、dep、pos init_RMQ(); // RMQ预处理 while(m --) { ...... if(pos[u] &gt; pos[v]) swap(u, v); // 询问u、v两个点的LCA，注意要保持欧拉序中u在v前面 cout &lt;&lt; euler[min_RMQ(pos[u], pos[v] + 1)] &lt;&lt; endl; // min_RMQ的输入、输出都是下标值，区间表示为左闭右开 } } 4. 例题 Luogu P3379 * * * 二、最大流问题（Dinic算法） 1. 定义 设源点为1, 终点为N。用 G[u][v] 表示点u、v之间的容量大小，求这样一个网络图 G 中的最大流量大小ans。 2. 解析 Dinic算法 求最大流 用邻接矩阵G存图更方便 先进行bfs, 判断有无增广路的同时,标记每个点的层号 然后根据层号进行dfs, 找增广路, 更新流值, 可能有多条不相交的增广路 循环往复 3. 模板 bool bfs(){ memset(dist, -1, sizeof(dist)); // 每次重新标记dist, 因为增加了反向边, 图已经不同 dist[1] = 0; que.push(1); while(!que.empty()){ int u = que.front(); que.pop(); for(int v = 1; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == -1){ // 连接 &amp;&amp; 未被标记 的点 dist[v] = dist[u] + 1; que.push(v); } } if(dist[N] == -1) return 0; // 若无法增广到终点，则表示没有增广路了 return 1; } int find(int u, int low){ // low是源点到现在最窄的(剩余流量最小)的边的剩余流量 if(u == N) return low; // dfs出口 for(int v = 1, a; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == dist[u] + 1 &amp;&amp; (a = find(v, min(low, G[u][v])))){ // 连接的 &amp;&amp; 是上下层关系的 &amp;&amp; 能连通到汇点 min维护low G[u][v] -= a; G[v][u] += a; // 增加反向边 起容错作用 return a; //只要发现一条增广路, 就返回增广的流量 } } return 0; } int main(){ //.... int ans = 0; while(bfs()){ // 利用bfs为每个点标记dis, 若标记不到汇点, 说明已经没有增广路 int temp; // 每次增广的流量 while(temp = find(1, INF)) ans += temp; // 根据dist进行dfs找增广路, 直到找不到为止 } cout &lt;&lt; ans &lt;&lt; endl; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-fu-za-de-tu-lun-wen-ti-gui-na/"},{"title":"[区间问题] 树状数组与线段树归纳","content":"用树状数组和线段树解决一些区间问题。 一、树状数组 1. 定义 用一个数组C[maxn]模拟树状结构，来表示原数组A[maxn]的区间信息。各操作的复杂度为O(lgn)。 2. 解析 lowbit(x) 指一个数x的二进制中，最靠右的1的权值大小。如lowbit(6)=2^1, lowbit(7)=2^0，lowbit(8)=8。 树状数组就是用一个C[maxn]数组来存放原数组A[maxn]的去区间信息。具体而言，C[x]存放了从A[(x-lowbit(x))...x]区间中各元素之和。 A[0]为0，不存放有效值。 [单点更新 区间查询] 求A[1...x]的区间和就需要求出它所对应的那几个C[j]区间之和，这几个区间通过lowbit向下枚举即可得出；而更改一个值A[i]时就需要更改所有包含了A[i]的C[j]区间，同样可以通过lowit线上枚举来获得。 3. 变式 [区间更新 单点查询] 树状数组中存放 差分值 D[i] = A[i] - A[i - 1]，这样区间更新只用更新区间两端，单点查值就是getSum。 [区间更新 区间查询] 维护两个数组 sum1[maxn]存放差值 D[1]、D[2]、D[3]... 的树状数组； sum2[maxn]存放 0 * D[1]、1 * D[2]、2 * D[3]... 的树状数组 更新操作要同时更新 sum1[maxn]、sum2[maxn] 查询区间的和为：n * ∑D[i] - ∑[(i - 1) * D[i]] = n * sum1[i] - sum2[i] 证明如下： A[1] + A[2] + ... + A[n] = (D[1]) + (D[1] + D[2]) + ... + (D[1] + D[2] + ... + D[n]) = n * D[1] + (n - 1) * D[2] + ... + D[n] = n * (D[1] + D[2] + ... + D[n]) - (0 * D[1] + 1 * D[2] + ... + (n - 1) * D[n]) 4. 模板 [单点更新 区间查询] int A[100010], C[100010]; // 原数组 和 树状数组 A[1...n]有效 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 当 A[k] += v时 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 求 A[1]+...+A[k]时 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } [区间更新 单点查询] int A[100010], C[100010]; int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 不变 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 不变 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } int main(){ ...... for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); // 在[x, y]区间加上k, 即让这个区间向上突出 add(y + 1, -k); ...... int ans = getSum(q); // 查询q位置的值 ...... } [区间更新 区间查询] int A[100010]; int sum1[100010]; // 存放了差值D[1]、D[2]、D[3]...的树状数组 int sum2[100010]; // 存放了0*D[1]、1*D[2]、2*D[3]...的树状数组 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 加差值和sum2的同时还要加sum2 for(int i = k; i &lt;= n; i += lowbit(i)) sum1[i] += v, sum2[i] += (k - 1) * v; } int getSum(int k){ // 区间和为 n*∑D[i] - ∑[(i-1)*D[i]] = n*sum1[i] - sum2[i] int res = 0; for(int i = k; i; i -= lowbit(i)) res += k * sum1[i] - sum2[i]; return res; } int main(){ for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); //在[x, y]区间加上k add(y + 1, -k); ...... int ans = getSum(q) - getSum(p - 1); //查询[p, q]位置的值 } * * * 二、线段树 1. 定义 一种强大的能解决区间的修改、查询问题的方法。 2. 解析 与树状数组相比，线段树代码量更大，但是适用范围更广。 k为结点编号 根节点为1, 左孩子为 k2, 右孩子为 k2+1 每个函数都包含参数k 除建树外共4种情形：单点查询 单点更新 区间查询 区间更新(要用到懒标记f) 一个题目一般只会用到两种 线段树一般保持 左闭右闭 区间，这样代码会好写一点 注意： 无论是更新还是查询，都要down懒标记 一些线段树的变形主要需要特别注意 状态归并 和 懒标记的更新 3. 模板 #include &lt;iostream&gt; using namespace std; using ll = long long; const int maxn = 5e5 + 5; struct node { int l, r, f = 0; ll w; node() {} node(int l, int r, ll w) : l(l), r(r), w(w) {} } Tree[4 * maxn]; int n, m; ll a[maxn]; void down(int k) { int &amp; v = Tree[k].f; Tree[k * 2].w += v * (Tree[k * 2].r - Tree[k * 2].l + 1); Tree[k * 2].f += v; Tree[k * 2 + 1].w += v * (Tree[k * 2 + 1].r - Tree[k * 2 + 1].l + 1); Tree[k * 2 + 1].f += v; v = 0; } void build(int l, int r, int k) { // 建树 if(l == r) { Tree[k] = node(l, r, a[l]); return; } int mid = (l + r) / 2; build(l, mid, k * 2); build(mid + 1, r, k * 2 + 1); Tree[k] = node(l, r, Tree[k * 2].w + Tree[k * 2 + 1].w); } void update(int x, int v, int k) { // 单点更新 if(Tree[k].l == Tree[k].r) { Tree[k].w += v; return; } int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) update(x, v, k * 2); else update(x, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int l, int r, int k) { // 区间查值 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; ll res = 0; if(l &lt;= mid) res += query(l, r, k * 2); if(r &gt; mid) res += query(l, r, k * 2 + 1); return res; } void update(int l, int r, int v, int k) { // 区间更新 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) { Tree[k].w += v * (Tree[k].r - Tree[k].l + 1); // 注意是多个值更新 Tree[k].f += v; // 懒标记： 预记儿子们的变化 return; } if(Tree[k].f) down(k); // 懒标记下传 int mid = (Tree[k].l + Tree[k].r) / 2; if(l &lt;= mid) update(l, r, v, k * 2); if(r &gt; mid) update(l, r, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int x, int k) { // 单点查值 if(Tree[k].l == Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) return query(x, k * 2); else return query(x, k * 2 + 1); } int main() { ios::sync_with_stdio(0), cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, n, 1); while(m --) { int f, x, y, k; // 单点更新 + 区间查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y, update(x, y, 1); // else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; // 区间更新 + 单点查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); // else cin &gt;&gt; x, cout &lt;&lt; query(x, 1) &lt;&lt; endl; // 区间更新 + 区间查值 cin &gt;&gt; f; if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; } } * * * FinFin Fin ","link":"https://river861.github.io/post/qu-jian-wen-ti-shu-zhuang-shu-zu-yu-xian-duan-shu-gui-na/"},{"title":"[动态规划][经典] 常见的动态规划问题归纳","content":"比如LIS问题 一、最长上升子序列（LIS） 1. 定义 给出一个序列a[1...n]，要求你求出其中最长的递增子序列的长度。 2. 简单的 O(n2)O(n^2)O(n2) 算法 原理： 设 dp[i] 为把下标i作为最长上升子序列结尾位置 的最大长度，则 dp[i] = max(dp[1..i]+1)，所有dp[i]初始为1. 模板： int n, num[maxn], dp[maxn]; // num[maxn]存放了序列，dp[i]表示以a[i]为结尾的最长子序列长度 int main() { ...... int ans = 0; for(int i = 1; i &lt;= n; i ++) { dp[i] = 1; for(int j = 1; j &lt; i; j ++) { if(num[i] &gt;= num[j]) dp[i] = max(dp[i], dp[j] + 1); } ans = max(ans, dp[i]); } cout &lt;&lt; ans &lt;&lt; endl; } 3. 最快的 O(nlgn) 算法 原理： 以非严格递增子序列为例，主要思想是 贪心 + 二分。这种方法不需要dp数组，取而代之，使用的是一个low数组。 维护一个 low数组 和 ans low[i]表示到当前为止，长度为i的LIS结尾元素的最小值；ans为 当前最长LIS长度 对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长，因此该算法贪心地维护出每个长度最小的结尾元素，存放在low[i]中 维护方法 对于每一个a[i]，如果a[i] &gt; low[ans]，就把 a[i]接到当前最长的LIS后面，即 low[++ ans] = a[i]；否则， 用 a[i] 更新 low数组 中第一个大于 a[i] 的元素 low[j] = a[i] 举个例子 比如1 5 6 3 4，假设当前已经遍历到下标3，则low[] = {1, 5, 6}，下一个数字3将会把5更新为3，表示到目前为止（1 5 6 3），长度为2的结尾最小的上升子序列为 1 3 。更新后下一个4才会有可能成为长度为3的上升子序列的末尾（1 3 4），这就是贪心起到的作用（总是维护最小的结尾值）。 模板： int nums[maxn], low[maxn]; // num[maxn]存放了序列，low[i]表示长度为i的LIS结尾元素的最小值 // 贪心 + 二分 解法 O(nlogn) int main(){ fill(low + 1, low + n + 1, INF); int ans = 0; // low和ans搭配使用，ans就是当前维护到的最长长度 for(int i = 1; i &lt;= n; i ++){ if(ans == 0 || num[i] &gt;= low[ans]) low[++ ans] = nums[i]; // 若为严格递增，改为 &gt; else{ int j = upper_bound(low + 1, low + n + 1, nums[i]) - low; // 若为严格递增，改为 lower_bound low[j] = nums[i]; } } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Nowcoder 旅行青蛙 * * * FinFin Fin LIS-参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-jing-dian-chang-jian-de-dong-tai-gui-hua-wen-ti-gui-na/"},{"title":"[动态规划] 数位dp方法归纳","content":"数位dp问题其实就是模板题。 一、定义 求出在给定区间 [A,B] 内，符合条件 f(i) 的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关。由于数是按位dp，数的大小对复杂度的影响很小。 简单来说，就是解决一些与区间中的数字的计数问题，计数条件一般与数的组成有关。 二、状态量 一般采用记忆化搜索的方式来实现dp，dp的状态经常包括pos、pre、cnt、lead、limit这几项： pos：当前处理的是数位的第几项，一般从高往低走 pre：当前位的前几位的状态，由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定） cnt：随着pos的前进需要维护的一些答案值/计数值 lead：当前位是否位前导0位 limit：当前位的最大值是否存在限制 三、记忆化搜索 把dfs的答案值存放在dp[pos][pre][cnt][...]数组中，以避免重复计算。 原理：从pos开始的低位dp答案会在高位值的枚举遍历中被反复调用。若从某个pos开始的dp它的前置状态pre和之前的某一次处理完全一样，则无需再重复计算，直接返回之前的答案值即可。因为所拥有的条件和上一次完全一样。 注意：当当前位为前导0或当前位受到限制时，没有必要将该值记录到dp数组。因为这些状态并不会被重复使用。 四、模板 以下模板大多数情况可套用，但部分细节还是需要结合具体题意进行考虑。 ll a[20], dp[20][20]; // a是用来装数位最高值的数组，dp是memo数组 ll dfs(ll pos, ll pre, ll cnt, bool lead, bool limit) { if(pos == 0) return cnt; // 已经遍历完一个数的情形 if(!lead &amp;&amp; !limit &amp;&amp; dp[pos][pre][...] != -1) return dp[pos][pre][...]; // 记忆化搜索 ll res = 0, maxv = limit ? a[pos] : 9; // 计算当前位最大值 for(ll i = 0; i &lt;= maxv; i ++) { // 若当前位是前导0 if(i == 0 &amp;&amp; lead) res += dfs(pos - 1, ...., 1, limit &amp;&amp; i == maxv); // 若当前位是最高位 else if(i &amp;&amp; lead) res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); // 正常情况 else res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); } if(!lead &amp;&amp; !limit) dp[pos][cnt] = res; return res; // 注意区分res和cnt，res是问题的答案，cnt是当前状态维护的小答案，res由最终的cnt累加而成 } ll cal(ll num) { ll pos = 0; while(num) a[++ pos] = num % 10, num /= 10; // 把数按位拆分（数位dp的前提） memset(dp, -1, sizeof(dp)); // memo数组初始化为-1 return dfs(pos, 0, 1, 1); // 从高位往低位dp } int main() { ...... // 注意！！！l为0时一般要特别处理，因为数位dp的过程会将0一直当作前导0从而忽略了数值0这一个数，不过由于是计算差值所以大部分情况不影响 cout &lt;&lt; cal(r, i) - cal(l - 1, i); // 将区间计算转化为差值计算 ...... } 五、例题 Nowcoder 17867 ZJOI 2010 数位dp就是模板题！！！ * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-shu-wei-dp-fang-fa-gui-na/"},{"title":"[数学][经典] 常见的数学方法归纳","content":"一些数学算法题中常用的技巧，包括gcd、exgcd、快速幂、逆元、组合数等。 基本说明 由于数学类方法经常性混合使用（比如组合数+快速幂），因此例题在最后统一给出。 * * * 一、最大公约数和最小公倍数（gcd） 1. 定义 没啥好说，大家都懂。最大公约数 gcd(a,b) ，最小公倍数 lcm(a,b) 。 2. 解析 求最大公约一般用辗转相除法，最小公倍数可以由最大公约数导出： gcd(a,b)⋅lcm(a,b)=a⋅bgcd(a, b) \\cdot lcm(a, b) = a \\cdot b gcd(a,b)⋅lcm(a,b)=a⋅b 同时注意为了防止a*b溢出，最终我们最小公倍数用下述公式求解： lcm(a,b)=a/gcd(a,b)⋅blcm(a, b) = a / gcd(a, b) \\cdot b lcm(a,b)=a/gcd(a,b)⋅b 3. 模板 ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } * * * 二、扩展欧几里得算法（exgcd） 1. 定义 上面说的求最大公约数的方式实际上叫欧几里得算法，而这里要讲的是它的升级版，不仅可以计算出前面说的最小公约数，还可以求出相应的“不定方程解”. 2. 解析 exgcd可以快速求出下面方程中的x、y、gcd(a,b)： ax+by=gcd(a,b)ax + by = gcd(a, b) ax+by=gcd(a,b) 上面的公式为裴蜀定理，有很多有用的结论： 上述式子一定有整数解，通过exgcd可以求出其中一组整数解 若要求出其它解，只需要 x+=b/gcd(a,b)，y-=a/gcd(a,b) 即可 注意不要漏了除以 gcd(a, b) +、-可以互换，相当于从另一个方向找其它解 对于ax+by=c，若c不是gcd(a, b)的倍数，则该方程无解 ...... 3. 模板 注意 在求解 ax+by=c 时要特判 a、b等于0 的情况。 ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if(b == 0) { y = 0, x = 1; return a; } ll res = exgcd(b, a % b, y, x); y -= (a / b) * x; return res; } * * * 三、快速幂算法 1. 定义 一种用来快速求解指数很大的幂运算的算法。 2. 解析 原理是将幂次减半，底数平方，并以此类推直到幂次为0。比如310=95=(94)(91)=(812)(91)=(65611)(91)3^{10}=9^5=(9^4)(9^1)=(81^2)(9^1)=(6561^1)(9^1)310=95=(94)(91)=(812)(91)=(65611)(91)，这样原式的答案就是6561*9了。 3. 模板 普通版，注意用long long： LL fast_pow(LL a, LL b) { // 快速幂算法 LL res = 1; while(b) { if(b &amp; 1) res = res * a; // 指数为奇时分一个出来 b &gt;&gt;= 1; // 指数减半 a = a * a; // 底数平方 } return res; } 带mod版，注意用long long： LL fast_pow_mod(LL a, LL b) { // 快速幂算法 带mod版 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } * * * 四、除法求模（逆元） 1. 定义 我们都知道，对于加法、减法、乘法，求模运算都可以提前，即： (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p ) % p (a * b) % p = (a % p * b % p) % p 而除法求模不行，因此对于除法求模我们需要使用一种专门的方法，即转化为乘法求模。 2. 解析 由费马小定理： bm−1≡1(modm)b^{m - 1} \\equiv 1 (mod m) bm−1≡1(modm) 转化一下则有： 1b≡bm−2(modm)\\frac{1}{b} \\equiv b^{m-2} (mod m) b1​≡bm−2(modm) 也就是说，对于除以b取模可以转化为乘以b^(m-2)取模！ 这样就成功将除法取模转化为了乘法取模。但要注意b、m必须互质。好消息是，这里的m一般就是题目给出的mod值，一般题目给出的都是一个很大的质数。 因此我们一般称b^(m-2)为b的 逆元 ，除以b取模相当于乘以b的逆元取模。 而对于b^(m-2)的求法，参见前文的 快速幂算法 即可。 3. 模板 以求组合数的模为例，里面要用到除法（除数为阶乘）求模： int C(int n, int m) { // n! / (n-m)! / m! =&gt; n! * [(n-m)!]^(mod-2) * [m!]^(mod-2) return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * 四、指数求模 1. 定义 指数比较大的情况一般用快速幂可以解决，然而.... 有时用快速幂还是会超时....这个时候也需要将指数模一模. 2. 解析 由费马小定理： bm−1≡1 (mod m)b^{m-1} \\equiv 1\\ (mod\\ m) bm−1≡1 (mod m) 将k组上式乘到下面这个式子中 aB≡ans (mod m)a^{B} \\equiv ans\\ (mod\\ m) aB≡ans (mod m) 得到 aB+k(m−1)≡ans (mod m)a^{B+k(m-1)} \\equiv ans\\ (mod\\ m) aB+k(m−1)≡ans (mod m) 上面两个式子说明，可以对指数 模(m-1)，答案不会变化。 3. 结论 在计算指数运算时，要是指数太大，可以 模(m-1)，答案不会变化。m为题目指定的mod。 五、组合数（C(n, m)） 1. 定义 在一些题目中需要用到组合数，甚至通过组合数直接输出结果，因此有必要学习一下组合数的计算方式。 C(n,m)=n!(n−m)!m!C(n, m) = \\frac{n!}{(n - m)! m!} C(n,m)=(n−m)!m!n!​ 2. 解析 两种方法 方法一：通过动态规划预处理出C[maxn][maxn]数组，预处理用时O(n^2)，查询用时O(1) 一般只要预处理不会超时、空间不会爆 就优先用这个！！ C(n,m)=C(n−1,m−1)+C(n−1,m)C(n, m) = C(n - 1, m - 1) + C(n - 1, m) C(n,m)=C(n−1,m−1)+C(n−1,m) 方法二：仅预处理出阶乘数fac[maxn]和阶乘数的逆元inv_fac[maxn]，预处理时间O(n*lg(mod))，查询用时稍微慢一点的O(1) 若方法一预处理超时了 或 内存爆了 就用这个。 C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅modC(n, m) = fac[n]\\cdot inv\\_fac(n - m) \\cdot mod \\cdot inv\\_fac(m) \\cdot mod C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅mod 3. 模板 方法一： void init(ll n) { C[0][0] = 1; for(ll i = 1; i &lt;= n; i ++) { for(ll j = 0; j &lt;= i; j ++) { C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } } 方法二： LL fast_pow_mod(LL a, LL b) { // 快速幂 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } void init(int n) { // 预处理 fac[0] = inv_fac[0] = 1; for(int i = 1; i &lt;= n; i ++) { fac[i] = fac[i - 1] * i % mod; inv_fac[i] = fast_pow_mod(fac[i], mod - 2); } } int C(int n, int m) { // 计算组合数 return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * Last. 例题 Nowcoder 数列统计 Nowcoder 子序列 Nowcoder 火柴排队 * * * FinFin Fin ","link":"https://river861.github.io/post/shu-xue-jing-dian-chang-jian-de-shu-xue-fang-fa-gui-na/"},{"title":"[图论] 最短路问题归纳","content":"包括Dijkstra算法、Spfa算法、Floyd算法以及它们的变形。 基本原则 首先看题目n的数量级，当 n&lt;1000 时，可以使用 [Floyd算法] 快速秒杀几乎所有题型 否则 若题目中所有边全为正权，则使用 [Dijkstra算法] 否则 当出现负权时，使用 [spfa算法] 注意一些隐蔽的最短路问题，比如题目会换一种问法。详见最短路的各种变形题。 * * * 一、正权单源最短路 —— Dijkstra算法 1. 定义 计算正权图上的单源最短路，即从单个源点出发到所有结点的最短路。包含无向图或有向图。 2. 解析 使用Dijkstra算法。时间复杂度O(mlgn)，一般够用。 3. 模板 struct node { // node结构是存放在优先队列中的结构 int u, d; node(int u, int d) : u(u), d(d) {} bool operator &lt; (const node&amp; rhs) const { return d &gt; rhs.d; // 由于默认为最大堆, 而我们希望最小的先出列 } }; struct edge { //edge结构仅用于存图 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, m, vis[maxn], d[maxn]; void Dij(int s) { fill(d, d + n + 1, INF), d[s] = 0; // 初始化d数组 fill(vis, vis + n + 1, 0); priority_queue&lt;node&gt; que; que.push(node(s, 0)); while(!que.empty()) { int u = que.top().u; que.pop(); if(vis[u]) continue; // vis就写在这两行，是为了忽略掉松弛前的结点（因为并没有从队列中删除，只是压入了d更小的状态而已）， vis[u] = 1; // 因此放在这里进行判断，这是和bfs不同的 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(node(e.to, d[e.to])); // 压入了松弛后的结点，然而并没有删除原结点，因此要依靠上面的vis } } } } int main() { ...... Dij(1); ...... } 注意Dijkstra的模板和bfs有点像，但是还是不一样的： 一个用优先队列，一个用普通队列 使用vis数组的原因不同 4. 例题 Poj 2397 Poj 1847 Poj 1502 * * * 二、带负权的单源最短路 —— spfa算法 1. 定义 计算带负权的图上的单源最短路，由于可能存在负环，因此Dijkstra算法不可用。 2. 解析 这时可以使用spfa算法。最坏时间复杂度O(nm)。 带负权的最短路径问题，可以使用Bellman-Ford或它的优化版本，即spfa算法。spafa算法能解决带负权的单源最短路问题，同时判断是否存在负环。最坏时间复杂度为O(nm)。比Dijkstra慢，因此对于正权的单源最短路我们使用Dijkstra，而对于带负权的就只能使用spfa算法了。 spfa算法的原理：先从Bellman-Ford算法的原理开始，Bellman-Ford算法通过将每条边松弛n-1次来求出每个点的最终d[maxn]，即松弛到不能再松弛了。而如果第n次还存在边可以继续松弛，说明存在负环。而spfa通过让已经松弛得不能再松弛的边不再入队来实现减少冗余的松弛操作，用队列来存储每一轮迭代后还需要继续松弛的边，就是这样一个优化。 spfa的模板与Dijkstra有点像，需要注意区分。 3. 模板 struct edge { // 用于存图的edge结构 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, inq[maxn], cnt[maxn], d[maxn]; bool spfa(int s) { fill(d, d + n + 1, INF); d[s] = 0; fill(inq, inq + n + 1, 0); // inq用于标记每个点是否在队列中 fill(cnt, cnt + n + 1, 0); // cnt用于统计每个点的入队次数 queue&lt;int&gt; que; // 只需要使用普通队列 que.push(s), inq[s] = 1, ++ cnt[s]; while(!que.empty()) { int u = que.front(); que.pop(); inq[u] = 0; // 可以重复入队 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(e.to), inq[e.to] = 1; if(++ cnt[e.to] &gt; n) return 1; // 入队超过n次说明有负环 } } } return 0; } int main() { ...... spfa(1); ...... } 要注意区分Dijkstra模板和spafa模板： Dijkstra使用优先队列，spfa使用普通队列 Dijkstra使用vis数组排出重复点；spfa使用inq记录是否在队列中，用cnt记录入队次数，允许重复入队 若原图不连通，需要加一个点使得原图连通后再用spfa算法来判断负环，否则会漏判。 4. 例题 Poj 3259 Poj 3169 LightOJ 1074 * * * 三、多源最短路 —— Floyd算法 1. 定义 求任意两点之间的最短路。包含无向图或有向图，正权图、负权图。 2. 解析 使用Floyd算法。时间复杂度O(n^3)。对于多源最短路问题只能使用Floyd算法，对于单源最短路问题，若n比较小，也可以使用Floyd算法来快速解决。因为代码简单啊😀 3. 模板 const int INF = 1 &lt;&lt; 29; int n, d[maxn][maxn]; void init() { for(int i = 1; i &lt;= n; i ++) { // 初始化d for(int j = 1; j &lt;= n; j ++) d[i][j] = INF; d[i][i] = 0; } } void Floyd() { for(int k = 1; k &lt;= n; k ++) { // 枚举中间点 for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= n; j ++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main() { ...... init(); Floyd(); ...... } 要注意Floyd中会有INF相加的情况，因此INF值不能太大，这里取的是1&lt;&lt; 29. 4. 例题 Uva 567 * * * 四、差分约束问题与最短路的关系 1. 定义 即给出对n个数m组约束不等式，求其中某两个数的最值。 2. 解析 差分约束问题可以转化为最短路/最长路问题解决。 原理：以问最大值为例，问x-y&lt;=多少时，肯定是通过若干B-A&lt;=w的约束条件才可能获得，而B-A&lt;=w这一不等式可以理解为d[B]&lt;=d[A]+w，这正好符合与最短路问题中的松弛操作的条件（d[u]&gt;d[v]+w）相反，也就是松弛操作会使得这一个个约束条件被满足，因此最短路问题的算法就可以得到满足所有约束条件的不等式的一组解。这样就可以得到d[x]与d[y]的差值了。 3. 模板 具体规则如下： 首先看问题，若问题问最大值则可以转化为最短路问题；问最小值则可以转化为最长路问题； 若为最短路问题，则将所有约束转化为B-A&lt;=w的形式；最长路问题则转化为B-A&gt;=w的形式； B-A&lt;=w对应于d[B]&lt;=d[A]+w，也就是从点A到B的有向路径权值为w； 然后就可以用Dijkstra、spfa或Floyd算法来秒杀了。 若存在负环，则表示无解；若d为INF，表示有无限个解。 4. 例题 Poj 3159 * * * 五、几种常见的最短路变形题 1. 求最大边权的最小值 / 最小边权的最大值 做法 以求最大边权的最小值为例： Floyd做法： 原松弛操作：d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作：d[i][j]= min(d[i][j] ,max( d[i][k] , d[k][j])); Dijkstra/spfa算法： 原松弛操作 ： d[v]= min(d[v], d[u]+w); 变形后的松弛操作 ： d[v]= min(d[v] , max(d[u], w)); 例题 Poj 2253 Poj 1797 2. 求往返最短路的最大值 / 和 做法 数据量小的用Floyd算法秒杀； 否则通过对原图和反图（所有有向边反向）各做一次Dijkstra/spfa来解决。 例题 Poj 1511 Poj 3268 3. 确定排名 做法 用Floyd算法，dp[u][v]表示u打败了v： 原松弛操作 ： d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作 ： d[i][j] = (d[i][k] &amp;&amp; d[k][j]) ? 1 : 0; 例题 Poj 3660 * * * FinFin Fin 最短路变形-参考博客 差分约束-参考博客 ","link":"https://river861.github.io/post/tu-lun-zui-duan-lu-wen-ti-gui-na/"},{"title":"[图论] 最小生成树问题归纳","content":"包括最小生成树、次小生成树和边权极差最小的生成树算法。 基本定义 本文的代码基本按照如下的图论模型进行定义，后文用的结构若与此相同则不再赘述： struct edge { int u, v, w; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { // 边按权值排序 return w &lt; rhs.w; } }; vector&lt;edge&gt; E; // 存储所有边 int n, m, Fa[maxn]; // Fa为并查集所需的数组 int find(int x) { // 并查集的find函数 return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } * * * 一、最小生成树 1. 定义 把若干点连成连通图，求最少连成的连通图的最小边权和。 2. 解析 这是最基础的题型，直接套用Kruskal算法的模板即可 3. 模板 int main() { ...... for(int i = 0; i &lt; n; i ++) Fa[i] = i; // Fa初始化 sort(E.begin(), E.end()); // 按结点从小到大排序 int ans = 0; for(const auto&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; // 若不连通则将其连通 ans += e.w; } ..... } 4. 例题 Uva 10034 * * * 二. 次小生成树 1. 定义 顾名思义，就是边权和第二小的生成树 2. 解析 其实也比较简单，按照以下步骤即可： 求出最小生成树mst 通过以每个点为根分别进行dfs，得到maxW[maxn][maxn]数组。其中maxW[root][v]表示最小生成树mst上从root到v的路径上的最大的一条边的权值。 遍历所有不在mst上的边，比如为（u, v），用它去替换mst上从u到v路径上的最大边，从而得到一系列次小生成树替补。这些次小生成树替补权值和最小的那个就是次小生成树。 时间复杂度为O(n^2+mlogm)，基本够用了。 3. 模板 原理简单，就是代码量较大...要维护一个存放边的容器E，同时还要维护一个存放最小生成树的边的容器mst。 struct edge { int u, v, w; bool flag = 0; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { return w &lt; rhs.w; } }; struct mst_edge { int v, w; mst_edge(int v, int w) : v(v), w(w) {} }; vector&lt;edge&gt; E; // 存放所有边的容器 vector&lt;mst_edge&gt; mst[maxn]; // 存放最小生成树的容器 int n, m, Fa[maxn], maxW[maxn][maxn], ans1, ans2; // ans1, ans2分别为最小生成树和次小生成树的边权和 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } void Kruskal() { for(int i = 1; i &lt;= n; i ++) Fa[i] = i; sort(E.begin(), E.end()); ans1 = 0; for(edge&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; ans1 += e.w; e.flag = 1; // 标记这条边在mst中 mst[e.u].push_back(mst_edge(e.v, e.w)); // 将最小生成树保存起来 mst[e.v].push_back(mst_edge(e.u, e.w)); } } void dfs(int root, int cur, int fa, int val) { // 遍历最小生成树来生成maxW数组 maxW[root][cur] = val; for(const mst_edge&amp; e : mst[cur]) if(e.v != fa) { dfs(root, e.v, cur, max(val, e.w)); } } void SKruskal() { Kruskal(); // 1. 求最小生成树mst for(int i = 1; i &lt;= n; i ++) dfs(i, i, 0, 0); // 2. 求maxW[root][v]数组 ans = INF; for(const edge&amp; e : E) if(e.flag == 0) ans2 = min(ans2, ans1 - maxW[e.u][e.v] + e.w); // 3. 用不在树上的边逐个替换，然后取最小的那个树就是次小生成树 } int main() { ...... SKruskal(); ...... } 4. 例题 Uva 10600 * * * 三. 边权极差最小的生成树 1. 定义 即最大边减最小边的值尽量小的生成树 2. 解析 我们知道求最小生成树是用Kruskal算法，这里其实也是一样：我们枚举生成树的最小边E[l]，然后每次只从边权大于这条最小边边权的边中进行最小生成树的生成，这样就能得到这个生成树的最大边边权。这样枚举完后，我们就能得到边权极差最小的生成树了。 正确性证明：为什么最小生成树T就一定是这个最小边对应的苗条度最小的生成树呢？仔细回想一下Kruskal算法，最小生成树T是通过从小到大枚举边得到的，如果这个最小边对应的使得苗条度最小的最大边不在这个T中的话，那就是说存在一个由边权小于这个最大边的一组边构成的一棵更小的生成树，这就与T是最小生成树矛盾了。 3. 模板 int main() { ...... sort(E.begin(), E.end()); int ans = INF; for(int l = 0, r; l &lt; E.size(); l ++) { // 枚举最小边l，然后通过Kruskal求最大边r for(int i = 1; i &lt;= n; i ++) Fa[i] = i; int cnt = 0; // 用cnt记录加的边的条数，以此判断图是否连通完毕 for(int i = l; i &lt; E.size(); i ++) { int u = find(E[i].u), v = find(E[i].v); if(u == v) continue; Fa[u] = v; if(++ cnt == n - 1) { r = i; break; } } if(cnt == n - 1) ans = min(ans, E[r].w - E[l].w); } ...... } 4. 例题 Uva 1395 * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/"},{"title":"[枚举] 暴力求解之枚举方法归纳","content":"包括枚举排列、枚举集合、回溯法、IDA*等算法。 一、枚举排列 1. 定义 枚举出一个序列a[maxn]的所有排列。 2. 解析 枚举排列 最简单的方法是运用STL的 next_permutation函数. 3. 模板 int a[maxn]; int main(){ ...... sort(a, a + n); do{ for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 打印排列 cout &lt;&lt; endl; } while(next_permutation(a, a + n)); } * * * 二、枚举集合 1. 定义 枚举出一个序列a[maxn]的所有子集。 2. 解析 枚举子集 最简单的方法是 二进制法。 设A、B为两个集合的二进制表示，则 交集表示为 A &amp; B 并集表示为 A | B 对称差集表示为 A ^ B 补集表示为 ALL ^ A [其中 ALL = (1 &lt;&lt; n) - 1] [枚举所有子集]： 枚举 0 到 (1 &lt;&lt; n) - 1 中的每个数字 i，然后将数字 i 转化为二进制， 如果 i 的第 j 位是 1，表示集合 i 包含 a[j]； 如果 i 的第 j 位是 0，表示集合 i 不包含 a[j]。 3. 变式 [枚举大小为k的所有子集] 从 i = (1 &lt;&lt; k) - 1 开始枚举，每次找比它大的下一个包含k个1的二进制数，方法如下： 令 x = lowbit(i)，表示当前 i 的靠右的 1 的权值 令 y = i + x，即让 y 等于 i 的最低 “1” 发生进位后的数字，此时必然有 y 中 1 的个数小于等于k 通过 (i &amp; -y) 得到由于进位而导致的所有从 1 变成 0 的位，然后将其除以 x 来去掉右边的所有 0 , 然后再继续右移 1 位来去掉一个 1 (因为进位后在左侧会有一个 0 变成 1) 。这样得到的数再 和 y 或一下，就可以得到下一个包含 k 个 1 的数字。 总结起来就是 i = ((i &amp; -y) / x) &gt;&gt; 1 | y。 [枚举一个给定集合 x 的所有子集] 从 全集 i = x 开始，从大到小枚举子集，方法如下： i = (i - 1) &amp; x. 即通过减1来缩小子集，通过&amp;x来限定在x的子集中。 [枚举一个给定集合 x 的所有超集] 从 最小集 i = x 开始，从小到大枚举超集，方法如下： i = (i + 1) | x. 即通过+1来扩大集合，通过|x来限定生成的集合必定包含x。 4. 模板 打印数字 i 代表的集合 int n, a[maxn]; // 长度为 n 的序列 void print_subset(int s){ // 打印 s 所表示的子集 for(int i = 0; i &lt; n; i ++){ if(s &amp; (1 &lt;&lt; i)) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } 枚举所有子集 void solve() { for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) { print_subset(i); // 用二进制数字i表示一个子集 } } 枚举所有大小为 k 的子集 void solve(int k) { for(int i = (1 &lt;&lt; k) - 1; i &lt; (1 &lt;&lt; n);) { print_subset(i); int x = i &amp; -i, y = i + x; i = (((i &amp; ~y) / x ) &gt;&gt; 1) | y; } } [枚举一个给定集合 x 的所有子集] void solve(int x) { for (int i = x; i &gt;= 0; i = (i - 1) &amp; x) { print_subset(i); } } [枚举一个给定集合 x 的所有超集] void solve(int x) { for (int i = x; i &lt; (1 &lt;&lt; n); i = (i + 1) | x) { print_subset(i); } } * * * 三、回溯法 1. 定义 即利用递归的回溯过程，来进行状态的“还原”，从而枚举出所有的情形。 2. 解析 紫薯告诉我们，回溯法总是比生成-测试法快得多。 需要一个递归深度值 idx（或一个坐标x, y）表示当前递归进度 需要一个值 cur 表示根据当前选择所形成的值（如和值等）。 需要一个 vis 数组标记已经递归过的位置（在回溯时还原） 3. 模板 int n, vis[maxn]; void solve(int idx, int cur) { if(idx == n - 1) { // 递归出口 // 根据 cur 更新 ans return; } for(int i = 1; i &lt;= n; i ++) if(!vis[i] &amp;&amp; 其它条件) { vis[i] = 1; solve(idx + 1, cur + i); // 递归 vis[i] = 0; // 还原 } } int main() { ...... vis[1] = 1; solve(0, 1); ...... } 4. 例题 Uva 524 Uva 167 (八皇后) * * * 四、迭代加深搜索（IDA*） 1. 定义 一种通过多次dfs找解的算法。 从小到大枚举dfs深度上限maxd，每次执行只考虑不超过maxd的节点。 IDA* 能进行关于深度的剪枝，从而提高效率。 一般回溯法可以解决的问题，但是 回溯时枚举边界无法确定时，可以使用IDA*算法。 2. 解析 枚举深搜的最大深度maxd，然后在maxd的限制下去进行dfs，并利用maxd来对dfs进行剪枝，使得dfs的每一层可以很快枚举完。 每次针对一个maxd进行dfs时，实际上就是相当于反复去解答这道题，因此也要重新初始化。 由于需要由maxd限制递归层数，因此dfs函数的参数必须包括一个idx表示当前递归的层数。 剩下的参数就按照需要进行增添。 优化技巧（IDA 的精髓）： 1、考虑最优性剪枝，即通过maxd可以判断出该次迭代已经不可能得到答案时要及时退出*； 2、考虑节点的搜索顺序，以加快搜索到目标节点。 3. 模板 bool dfs(int maxd, int idx, ......) { if(idx == maxd) { // 达到当前枚举的最大深度maxd就处理完后退出 if(不满足条件) return 0; else { ...... // 记录答案 return 1; } } if(通过maxd可以判断出该次迭代已经不可能得到答案) return 0; // 精髓：最优性剪枝 for(正常的dfs枚举) { if(不满足条件) continue; if(dfs(maxd, idx + 1, ......)) return 1; } return 0; } int main() { ...... for(int maxd = 1; ; maxd ++) { memset(ans, -1, sizeof(ans)); // 每次 dfs 需要重新初始化 if(dfs(maxd, 0, ....)) break; // 找到解就退出 } ...... 4. 例题 Uva 12558 Uva 1343 * * * FinFin Fin ","link":"https://river861.github.io/post/mei-ju-bao-li-qiu-jie-zhi-mei-ju-fang-fa-gui-na/"},{"title":"[经典] 常见的高效算法归纳","content":"包括滑动窗口、哈希表、拓扑排序、单调栈、KMP、RMQ、最小表示法、二分答案、Cantor等算法。 一、滑动窗口 1. 定义 滑动窗口法（又叫双指针法），即用i,j双指针（一般用下标）对数组进行遍历，同时要需要一个额外的比如vis数组维护窗口中的元素信息，是一种O(n)的扫描方法。 2. 解析 一般比较常见的问题就是，维护窗口中的元素各不相同。 既可以用一个vis[maxn]数组来表示窗口中是否存在某个元素，也可以用一个pos[maxn]数组来存储上一次遇见某个元素的位置（为-1表示不在窗口中）。本质是一样的。 当元素数值比较大时，用unordered_map来实现vis或pos即可。 最好统一一下开闭区间，比如总是使用闭区间[i, j]作为窗口范围。 最好统一一下判断顺序，比如总是先处理当前元素已经在窗口中出现过的情况 3. 大致模板 额外维护pos ll n, a[maxn]; unordered_map&lt;ll, ll&gt; pos; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { // 维护闭区间窗口[i, j] ll num = a[j]; if(pos.count(num) &amp;&amp; pos[num] != -1) { // 先判断在数组中的情况 for(; i &lt;= pos[num]; i ++) pos[a[i]] = -1; // 注意一定要逐个退出并消除pos } pos[num] = j; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 额外维护vis ll n, a[maxn]; unordered_map&lt;int, int&gt; vis; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { ll num = a[j]; if(vis[num]) { // 先判断在数组中的情况 while(i &lt; j &amp;&amp; a[i] != num) vis[a[i]] = 0, i ++; // 注意一定要逐个退出并消除vis i ++; } else vis[num] = 1; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Uva 11572 Nowcoder 数糖纸 Uva 12174 * * * 二、哈希表 1. 定义 当你希望定义一个数组（比如vis数组），但是下标范围很大（比如1e9），这个时候就没有办法开一个vis[maxn]的数组了，因为会爆内存。 这时我们就可以通过hash的方式把下标映射到一个可以接受的小范围，比如[0...200003]。 2. 解析 一般情况下优先使用 unordered_map 或 unordered_set 但也不排除出题人把 map 和 set 给卡了...这个时候就用哈希表吧，使用最简单的开放寻址法来解决冲突， 其实就是一个链表数组。 3. 模板 const int HASH = 2000003; class Vis { public: list&lt;ll&gt; vis[HASH]; void insert(ll x) { // 插入 if(!query(x)) vis[x % HASH].push_back(x); } bool query(ll x) { // 查询 for(ll y : vis[x % HASH]) if(x == y) return 1; return 0; } } vis; 4. 例题 Nocoder 眼花缭乱的街市（卡STL） * * * 三、拓扑排序 1. 定义 给出n个点，然后给出m个依赖关系，比如（u, v）表示必须先有u才有v，要求你输出一个满足依赖的点序列，或者输出无解。 2. 解析 拓扑排序是一种经典的模板题，来源于图论，一般有队列或dfs两种不同的写法（个人比较喜欢队列写法😀）。 需要维护的结构 int in[maxn]：维护每个点的入度数目 vector Next[maxn]：记录每个点的所有出度点 queue ready：维护依赖被满足的点（若题目需要按某种排序输出，则改成优先队列） 当题目中的“点”不是整型，而是用字符串表示时，需额外维护： vector id2str unordered_map&lt;string, int&gt; str2id 3. 模板 int in[maxn]; vector&lt;int&gt; Next[maxn]; void solve() { // 拓扑排序 priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; ready; for(int i = 0; i &lt; n; i ++) if(in[i] == 0) ready.push(i); // 压入一开始就没依赖的点 vector&lt;int&gt; ans; while(!ready.empty()) { int u = ready.top(); ready.pop(); ans.push_back(u); // 记录到答案序列中 for(int v : Next[u]) { in[v] --; // 入度减1 if(in[v] == 0) ready.push(v); // 新的无依赖结点 } } if(ans.size() != n) ...... // 无解 else .... // 打印ans } 4. 例题 Nowcoder 烦人的依赖 * * * 四、单调栈 1. 定义 维护一个栈（或双向队列），保持栈内元素的单调性，存放下标还是值可以依情况而定。由于每个元素最多弹出一次，因此单调栈算法是O(n)的。 单调递增栈作用：O(1)时间获取离当前位置最近的一个小于当前值的元素。 单调递减栈作用：O(1)时间获取离当前位置最近的一个大于当前值的元素。 2. 解析 以单调递增栈为例。 通过这个栈，可以得到到当前元素为止的单调递增序列，从而能得到左侧离自己最近的比自己小的元素。 原理：只有 [比自己大的元素]， 或者 [比自己小但是却被离得更近的更小的元素弹走的元素] 才不会出现在栈中。 3. 模板 存放下标，非严格单调递增栈： stack&lt;int&gt; stk; for(int i = 0; i &lt;= n; i ++) { while(!stk.empty() &amp;&amp; a[stk.top()] &gt; a[i]) { // 先将大于当前值的元素弹出 int temp = stk.top(); stk.pop(); ...... // Do something else | 可以在这里对弹出的元素temp进行一些操作 } ...... // Do something else | 此时栈顶为左侧离自己最近的比自己小的元素 stk.push(i); // 把当前值压栈 } 4. 例题 Hdu 1506 Uva 1619 Uva 12265 * * * 五、KMP算法 1. 定义 在O(n)时间实现从长串test中找到一个匹配子串pattern。 2. 解析 由pattern串生成一个Next[maxn]数组，表示匹配失败时，下标回溯到的位置。 Next[maxn]的含义: 当前匹配串的相同前后缀的前缀末端位置。 比如字符串 aabcaad，假设在匹配d时失败，下标位于6，则对于当前匹配串p[0...5]，相同的前后缀为aa，则将会回溯到前缀的末端位置，即b处，即下标2，因此有Next[6]=2。 3. 变式 循环节 问题 （只需要Next数组） 根据Next数组的定义，Next[i]=j表示j为s[i]匹配失败后需要跳回的位置，也即是i之前和j之前可能为相同的串。 对于一个循环串来说，它的Next数组“跳回”的长度正好就是一个循环节。因此通过 i-Next[i] 即可计算出s[1..i)的循环节长度。 但注意可能字符串不是循环字符串，因此还要判定字符串长度i是否能被循环节长度 i-Next[i] 整除。 注意这样算出来的循环节长度是最小循环节长度，如果需要算出所有可能循环节长度的话，就要用一个while循环一节一节往回跳+判定，由于往回跳的长度就是循环节的长度，因此实际上这是一个枚举循环节长度的过程。比如字符串aaaa，用KMP算法求出的循环节长度为1，但实际上2也是一个循环节长度，此时就要往回跳+判定来枚举全。 扩展KMP算法（需要求出每个位置匹配的长度） 通过一个Extend[maxn]数组来记录test串从每个位置开始的匹配长度 其中注意要通过 j = Next[j] 来回溯，避免遗漏记录，具体见代码EKMP 4. 模板 普通KMP int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 直接返回第一次匹配的写法 int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; } if(j == m) return i - j; return -1; } int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 返回匹配次数的写法 int i = 0, j = 0; while(i &lt; n) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; if(j == m) cnt ++, j = Next[j]; } return cnt; } void getNext(string&amp; p, int m) { // 求Next数组，在KMP之前调用 Next[0] = -1; int i = 0, j = -1; while(i &lt; m) { if(j == -1 || p[i] == p[j]) i ++, j ++, Next[i] = j; else j = Next[j]; } } 拓展KMP void EKMP(const string&amp; t, int n, const string&amp; p, int m, int* Next, int* Extend){ int i = 0, j = 0; while(i &lt; n){ if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; Extend[i - j] = j; // Extend数组记录test串每个位置匹配了多长的pattern前缀 if(j == m){ j = Next[j]; // 继续匹配 for(int k = j; k; k = Next[k]) Extend[i - k] = k; // 回溯 使记录完整 } } } 5. 例题 Uva 1328 Uva 12012 * * * 六、RMQ算法 1. 定义 通过动态规划在O(nlgn)时间内对一个序列进行RMQ-init预处理，然后就可以在O(1)时间内得到这个序列中任意区间[l, r)中的最值！ 注意：为了避免混淆，RMQ算法中所有的区间使用 左闭右开。 2. 解析 O(nlgn)时间预处理 用 dp[i][j] 表示从下标 i 开始的连续 2^j 个数中的最小（大）值，下面以最小值为例。 转移方程：dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]) 即将区间 [i, i + 2^j) 分为 [i, i + 2^(j-1)) 和 [i + 2^(j-1), i + 2^j) 两段. O(1)时间查区间 [i，j) 中的最值 求区间长度的log值，即 k = log(r - l)。（取整后会偏小，所以第2步中要求两段） 最值为 dp[l][k] 和 dp[r - (1 &lt;&lt; k)][k] 中更小的那个。 3. 变式 有时候题目中区间的“值”是比较抽象的，这个时候可以考虑在dp[i][j]中存放区间中取到最值时的下标值，而不是区间中的最值。这样的话 预处理 和 取最值 的函数都需要做出相应修改。 一个最典型的变式例子就是树中求LCA的问题。 4. 模板 const int maxn = 5e3 + 5, log2_maxn = 15; int n, a[maxn], dp[maxn][log2_maxn]; // 序列为a[0...(n-1)] void rmq_init(){ for(int i = 0; i &lt; n; i ++) dp[i][0] = a[i]; // 初始化最短区间 for(int j = 1; (1 &lt;&lt; j) &lt;= n; j ++) // 区间长度由小到大， 大区间的最值由小区间获得 for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i ++) // 循环条件：右端点&lt;n dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]); // 注意加减法优先级大于&lt;&lt; } int rmq_min(int l, int r){ // 返回闭区间 [l ,r) 中的最小值 int k = log2(r - l); return min(dp[l][k], dp[r - (1 &lt;&lt; k)][k]); } 5. 例题 LCA问题 * * * 七、O(n)时间求最小（大）循环字符串 1. 定义 给定一个循环字符串，要求你输出它字典序最小（大）的表示方法，即确定一个开始位置。 2. 解析 以最小表示为例。 基本思想是双指针i, j，用k表示从i、j开始的子串的当前比对到的完全一样的长度，当判断出i、j的某一条子串的i+k、j+k位置有所不同时，大的那一条（比如是j）就可以往后跳k+1个字符，因为以这些字符起始的循环字符串已经不可能是最小的（比它们小的在i开始的串的子串中）。用这样的方法当i、j串中的某一个超过n时就不用再判断了（因为n个可能的起始位置都判断过了）。此时剩余的那个串就是最小的循环字符串。 3. 模板 //求循环字符串的最小字典序 最大类似 int getMin(const string&amp; s, int n){ int i = 0, j = 1, k = 0; // i, j为双指针, k为当前匹配长度 while(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n){ int temp = s[(i + k) % n] - s[(j + k) % n]; if(temp == 0) k ++; //若当前位匹配, k ++ else{ if(temp &gt; 0) i += k + 1; else j += k + 1; /* 若 s[i...i+k]比s[j...j+k]更大, 设 i&lt;p&lt;i+k 则s[p..i+k]都比s[p-i+j, j+k]大 即前者不可能为最小字典序, 因此全部跳过, 即i += k+1 j同理 */ if(i == j) j ++; // 避免死循环 k = 0; // 更改i、j后重头匹配 } } return min(i, j); } 4. 例题 Uva 1584 * * * 八、二分答案 1. 定义 顾名思义，通过枚举答案的方法，将原先的最值为题转化为判定问题。时间复杂度为 O(lgN * 判定的时间复杂度)。 2. 解析 [最大值尽可能小]、[最小值尽可能大], 这类问题时，可以考虑二分答案。 注意二分时判断OK后r等于多少，l等于多少不要搞错了。一般我们把范围想为[l, r]闭区间不容易错。所以不OK时 l=mid+1，因为不应该包含mid。此为，最好用l=1, r=2来验证一下是否会陷入死循环。 3. 模板 ...... LL l = 0, r = INF; while(l &lt; r) { LL mid = l + (r - l) / 2; if(isOK(mid)) r = mid; else l = mid + 1; } ...... 4. 例题 Uva 714 * * * 九、康托展开（Cantor） 1. 定义 全排列与整数的一种完美双向Hash方法。 2. 解析 正变换 （排列 -&gt; 整数） 双重循环，数出每一位后面有几个比它小的数，据此算出当前排列为第几小的排列（从0计起） res += small * （当前位后面一共有多少位）！ 逆变换 （整数 -&gt; 排列） 令 temp 为原序列从小到大的排列。 逆循环除，商为下一个被除数，余数为small 取temp中剩余数第small+1小的数（index为small） 在temp中删去该数 3. 模板 int cantor(vector&lt;char&gt;&amp; a, int n){ // 由字符数组 转化为 对应的排序数 int res = 0; // res为 比当前排列要小的 排列的个数 for(int i = 0; i &lt; n; i ++){ int small = 0; for(int j = i + 1; j &lt; n; j ++){ if(a[j] &lt; a[i]) small ++; // 对每一位数(或字符), 数它后面有几个比它小 } res += small * Fac[n - 1 - i]; // Fac为阶乘 } return res; } vector&lt;char&gt; decantor(int num, int n){ // 把排序数 还原为 数组 vector&lt;char&gt; temp = a, res; sort(temp.begin(), temp.end()); //temp为按从小到大排列的数组 for(int i = n - 1; i &gt;= 0; i --){ int y = num % Fac[i], s = num / Fac[i]; // s即为small num = y; res.push_back(temp[s]); // 当前第s小的数 即为当前位 temp.erase(temp.begin() + s); // 删去temp[s], 避免影响之后判断 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/jing-dian-chang-jian-de-gao-xiao-suan-fa-gui-na/"},{"title":"[动态规划] 背包问题归纳","content":"背包问题是非常经典的一类动态规划题目，包括01背包、完全背包、多重背包等。 一、01背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积（volumn）是v[i]，价值（worth）是w[i]，问如何选择物品装入背包可使价值总和最大。 2. 解析 每种物品只有选和不选两种。我们可以使用多阶段动态规划的思想来解决。 用dp[i][j]表示前i个物品（或用“从第i个物品开始的后面所有物品”的反向定义也行）装入容量为j的背包中的最大价值量。 则转移方程为： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])dp[i][j]=max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i]) 其中每多考虑一个物品i，代表一个“阶段”。括号第一项表示选，第二项表示不选。 **（优化）**由于每一项都是依赖于i-1，因此可以使用滚动数组来优化空间复杂度： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 其中注意使用滚动数组时，j的遍历必须逆序，来保证等号右边使用的dp值是上一阶段的结果值. 如果需要打印路径，则必须使用第一种写法，否则可以使用优化写法来节省空间。 3. 模板 普通写法 int V, n, v[maxn], w[maxn], dp[maxn][maxv]; for(int j = 0; j &lt;= V; j ++) dp[0][j] = 0; for (int i = 1; i &lt;= n; i ++) { for (int j = v[i]; j &lt;= V; j ++) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); } } 优化写法 int V, n, v[maxn], w[maxn], dp[maxv]; for (int i = 1; i &lt;= n; i ++) { for (int j = V; j &gt;= w[i]; j --) { // 逆序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Uva 624 Luogu 2925 干草出售 Luogu 1616 疯狂的采药 Hdu 3466 Proud Merchants * * * 二、完全背包问题 1. 定义 有n种物品和一个容量为V的背包，每种物品都有无限个。第i种物品的体积为v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 由于有无限个，所以每种物品的选择就有无限种了，因此我们不能用01背包的套路了，需要换一种思路。我们先回顾一下01背包中的优化写法，之所以j要逆序遍历是为了使得等号右边的dp值对应的是上一物品计算完后的dp值。而回到完全背包问题，由于物品有无限个，因此对于已经选择了当前物品的dp值，我们依然可以继续添加当前物品，直到达到背包上限为止。这样一想，完全背包问题的递推式就大概是： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j])dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], dp[i][j - v[i]] + w[j]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j]) 其中第1、2项和01背包一样，第3项表示继续添加当前物品。 然而上述递推式实在是比较混乱，因此实际上大多数情况下使用的是滚动数组的版本： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 可以看到这里和01背包的转移方程是一样的，但是实际用的时候这里j的遍历顺序必须为正序。 在笔者看来，完全背包问题的写法其实还可以通过刷表法来理解。就是对于每一种新的物品i，用它来不断刷新所有体积的背包的状态（最大价值量）。j的顺序遍历使得刷新的效果可以“叠加”，从而实现放入多个物品的效果。 实际上紫薯还提供里完全背包的另一种思路，即看成是带权的DAG的最长路问题，不过其代码量相比于递推式要稍微大一些，因此这里略。感兴趣的可以看一下下面的例题，有使用了这种方法的题解。 3. 模板 int V, n, v[maxn], w[maxn], dp[maxv]; fill(dp, dp + V + 1, 0); for(int i = 1; i &lt;= n; i ++) { for(int j = v[i]; j &lt;= V; j ++) { // 顺序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Hdu 4508 Hdu 1114 Piggy-Bank Luogu 1853 投资的最大效益 * * * 三、多重背包问题 1. 定义 有n种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件体积是v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 多重背包问题限制了物品的数目，这里有一种显然的思路就是，把每一“个”物品看作一个不同的“种”物品，然后用01背包去做，但是这样大概率为超时（笑），时间复杂度为O(V*∑p[i]) 顺着上述思路，有一种二进制法可以将时间复杂度降到O(V*∑lgp[i])，并且一般够用了😀。 它的原理就是将一个数量为p[i]，价值为v[i]的物体拆分成 1、2、4、8...这若干份（每一份右2的幂次份原物体构成，构成的新物体价值为kw[i]，体积为kv[i]），然后 注意最后不足2的幂次的数量也单独做成1份，这样物体的总数量就降为了 O(∑lgn)。然后就可以按照01背包问题的套路来处理这∑lgn个新物体了。 正确性是由二进制原理保证的：因为原来可能选择的1~p[i]个原物体一定可以被替换为新物体的组合。 实际上还有一种使用单调队列的优化方式，但由于技巧性比较高，一般用不到 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示原物体i的数量限制 fill(dp, dp + V + 1, 0); for(int i = 0; i &lt; n; i ++) { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 每一个新物体由k个原物体组成 if(k &gt; num) k = num; // 最后不足2的幂次的单独一份 num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 对新物体使用01背包问题处理，这里使用的是01背包问题的滚动数组模板，当然也可以不用 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 其实还有另一种写法是将原物体分为新物体后用一个新数组装起来，然后再进行01背包操作，区别其实不大。这里直接写在外层嵌套了，因为代码量少一些所以我喜欢😀。 4. 例题 Hdu1059 Luogu P1776 宝物筛选 * * * 四、混合背包问题 1. 定义 如果将前面三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的有限次（多重背包），问如何选择物品装入背包可使价值总和最大。 2. 解析 首先01背包和多重背包在模板上只有j的遍历顺序不同，因此我们可以通过一个if语句来区分这两种背包，然后分别进行不同顺序的内层循环即可 然后其实01背包是一种特殊的多重背包，即01背包是数量上限为1的多重背包问题，这样一想其实就只用写多重背包的代码即可 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示每个物品的件数，-1代表无穷个 for (int i = 1; i &lt;= n; i++) if (p[i] == -1) // 完全背包 for (int j = v[i]; j &lt;= V; j++) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); else { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 01背包和多重背包 if(k &gt; num) k = num; num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 01背包只会执行k=1这一次 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 4. 例题 Luogu P1833 樱花 HDU 3535 AreYouBusy * * * 五、二维背包问题 1. 定义 对于每件物品，具有两种不同的代价v[i], g[i]，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）V, G，物品的价值为v[i]v[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 这个其实比较简单，就是让dp数组增加一维度即可。 即dp[i][j][k]表示前i件物品装入两种代价分别为j和k的背包时可获得的最大价值量。滚动数组后就变成dp[j][k]。直接看代码会就一目了然了。 3. 模板 int V, n, v[n], g[maxn], w[n], p[n], dp[maxv][maxg]; // v[i]和g[i]分别为两种代价 for (int i = 1; i &lt;= n; i ++) for (int j = V; j &gt;= v[i]; j --) for (int k = G; k &gt;= g[i]; k --) dp[j][k] = max(dp[j][k], dp[j - v[i]][k - g[i]] + w[i]); 4. 例题 Luogu 1507 NASA的食物计划 HDU 2159 FATE * * * 六、分组背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。问如何选择物品装入背包可使价值总和最大。 2. 解析 其实分组背包可以把每个组看作一个物体，即这其实就是一个01背包问题，每个物体依然还是选和不选两种状态，只不过选的时候可以从组内的多个原物体种任意选一个。同样看代码就一目了然了。 3. 模板（伪代码） for (所有的组k) for (int j = V; j &gt;= 0; j--) for (所有属于组k的i) dp[j] = max(dp[j], dp[j - v[i]] + w[i]) 4. 例题 Luogu 1757 通天之分组背包 HDU 1712 ACboy needs your help * * * 七、背包问题的其它要素 1. 问法不同 最大值、最小值： 一次对应max、min即可 方案数目：改为sum，同时注意初始化可能需要改变 2. 范围不同 最大化、最小化： 初始化时对于前0个物品的价值量dp[i][0...V]全部初始化为0，这样即使最终的dp[n][V]未达到边界值也能有最值答案（根据提问内容不同可能会有所改变） 恰好装满 初始化时dp[i][0]=0, dp[i][1...V]全部初始化为 -INF或INF，这样不能刚好达到V的方案的最终价值量就为 -INF或INF（根据提问内容不同可能会有所改变） 3. 打印路径 不使用滚动数组的写法，即有完整的dp[i][j]记录，然后通过递归的方法print_ans打印路径。这是我个人比较喜欢的写法，因为不用额外维护存储路径信息的数组😀 维护一个记录路径信息的数组 记录下每个状态的最优值是由状态转移方程的哪一项推出来的。然后就可以根据这条记录找到上一个状态，从上一个状态接着向上推，得到整条路径。 3. 情景 区分背包问题是简单的，但是..... 如何才能发现一道题考察的是背包问题呢？ 这就需要多刷题目，直到看到题目的某个情景就能反应出是在考察背包问题。 当然我还没到那种境界就是了hhh😀 * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-bei-bao-wen-ti-gui-na/"},{"title":"[贪心算法] 区间问题归纳","content":"贪心算法中的区间问题归纳，包括区间不相交问题、区间选点问题、区间覆盖问题、区间限制问题等。 基本定义 区间用一个结构体来表示： struct Internal { int l, r; bool operator &lt; (const Internal&amp; rhs) const { return ......; // 按左端点 或 右端点 或其它排序 } }; vector&lt;Internal&gt; vec; // 存放所有区间的容器 以下代码只使用一个int类型的ans进行计数，若题目需要打印出所选择的区间/点，则改成用一个vector类型的ans存储即可。 * * * 一、区间不相交问题 1. 定义 数轴上有n个区间（li, ri），选择尽量多的区间，使得这些区间两两不相交。 2. 解析 贪心策略：按r从小到大进行排序，即总是先选取r小的区间，这样就能给后面的区间留下更多空间。 当r相等时，l无所谓，因为只要选择其中不与前一个区间相交的任意一个即可。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最大右端点 for(const auto &amp; p : vec) if(p.l &gt;= cur) ans ++, cur = p.r; 4. 例题 UvaLive 6606 * * * 二、区间选点问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的点，使得每个区间内都至少有一个点。 2. 解析 贪心策略：按r从小到大进行排序。每次选点时，总是选取第一个不被包含的区间的最右端点处。这样能让这个点接触到最多区间。 当r相等时，l无所谓，因为不影响点数。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最右的点 for(const auto&amp; p : vec) if(cur &lt; p.l || cur &gt; p.r) ans ++, cur = p.r; 4. 例题 Uva 1615 * * * 三、区间覆盖问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的区间覆盖一条指定线段[s,t]。 2. 解析 贪心策略：按l从小到大进行排序。将l&lt;s的这些区间的小于s的部分截掉（因为这部分没有用），然后从这些区间中选择出剩余长度最长的进行覆盖，然后将s更新为该区间的右端点。接下来继续遍历以此类推，直到 s&gt;=t，说明已经覆盖完毕。 这道题贪心策略稍微复杂，代码写起来也稍微麻烦，要好好记忆。 3. 模板 sort(vec.begin(), vec.end()); // 按l排序 int s = 0, t = M, ans = 0; // 目标区间[s,t] auto L = vec.begin(); while(s &lt; t &amp;&amp; L != vec.end()) { // 右端点无法覆盖 auto R = upper_bound(L, vec.end(), Internal(s, s)); // [L,R)表示容器下标范围 if(L == R) break; // 左端点无法覆盖 auto chosen = *max_element(L, R, [](const Internal&amp; a, const Internal&amp; b) { return a.r &lt; b.r; }); // 找到最长的那个 ans ++; L = R, s = chosen.r; } if(s &lt; t) cout &lt;&lt; -1 &lt;&lt; endl; // 无法覆盖完全 4. 例题 Uva 10020 * * * 四、区间限制问题 之 用时相等 1. 定义 有若干个任务，每个任务有一段执行的时间区间[li, ri]限制，每个任务的用时都相等，比如都为1。 问能否完成所有任务。 2. 解析 贪心策略：按r从小到大进行排序（r相等时，按从长到短排序），每次尽量早地执行任务（可能就是从l开始，也可能不是，因为被之前的任务占用）。这里的r实际上就是ddl，总是先处理快到“ddl”的区间。ps：结合实际生活来看，这的确是显然的。 r相等时，l按照从小到大排序，这是为了能让任务地起始时间有可能更早。 3. 模板 struct task { // 一个任务 int l, r, idx; task(int l, int r, int idx) : l(l), r(r), idx(idx) {} bool operator &lt; (const task&amp; rhs) const { return r &lt; rhs.r || r == rhs.r &amp;&amp; l &lt; rhs.l; } }; vector&lt;task&gt; vec; ...... fill(vis, vis + n + 1, 0); // 用来标记某个时间是否被占用 sort(vec.begin(), vec.end()); // 按照 (r, l) 排序 for(const auto&amp; p : vec) { int j = p.l; while(j &lt;= p.r &amp;&amp; vis[j]) j ++; // 找第一个没被占用地时间点执行任务 if(j == p.r + 1) return 0; ans[p.idx] = j, vis[j] = 1; // 用ans记录任务p的执行时间 } ...... 4. 例题 Uva 11134 * * * 五、区间限制问题 之 用时不等 1. 定义 有若干个工作，只能串行进行，已知每个工作的用时need[i]和截止期限ddl[i]，问最多能完成多少个工作？ 2. 解析 这个是超典型的工作安排贪心问题。 一个比较简单的版本是给出工作的确切开始时间和结束时间，这种问题就是典型的区间限制问题，我们按照ddl排序，然后先完成ddl早的任务即可。 但是在这道题中，任务的开始时间是可以任意决定的（只要结束时不超过ddl期限），因此我们还应该结合考虑另一种贪心：即让短的任务优先。 也就是说，对于一个给定的时间点之前，我们需要先执行短的任务，这样才能让任务完成数量最大化。这里 需要用一个优先队列来存放到当前时间点为止，所有已经选择的任务 。用这个优先队列的目的是为了能获得已经选择的任务中用时最长的那一个，这样就能在当发现一个任务由于超时无法选择时可以有尝试替换的机会（即从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时）。 贪心策略：按r从小到大进行排序，每次尽量早地执行任务。当碰到一个任务超时，尝试从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时。 3. 模板 struct task { int need, ddl; task(int need, int ddl) : need(need), ddl(ddl) {} bool operator &lt; (const task&amp; rhs) const { return ddl &lt; rhs.ddl; } }; ...... sort(vec.begin(), vec.end()); priority_queue&lt;int&gt; que; int cur = 0; // 当前时间点 for(const task&amp; t : vec) { // 总体上还是优先考虑ddl早的任务 if(cur + t.need &lt;= t.ddl) { // 不超时 cur += t.need; que.push(t.need); } else if(!que.empty() &amp;&amp; que.top() &gt; t.need) { // 反正都会有一个任务不能完成，不如留下用时短的任务（当前任务） cur += t.need - que.top(); // 即用这个ddl更晚的但用时更短的task替换一个ddl早一些但是用时长的task que.pop(); // 由于当前任务的ddl更晚，用时也更短，因此替换后必然不会超时 que.push(t.need); } } cout &lt;&lt; que.size() &lt;&lt; endl; ...... 4. 例题 Uva 1153 * * * FinFin Fin ","link":"https://river861.github.io/post/tan-xin-suan-fa-qu-jian-wen-ti-gui-na/"}]}