{"posts":[{"title":"[图论] 最大匹配问题归纳","content":"包括匈牙利算法和Hopcroft_karp算法。 一、定义 即在一个二分图中，找到最大的匹配对数。每个点只能最多和另外一个点配对。 二、情景 为了方便理解，这里考虑一下最大匹配场景： 有一列男生1..n，还有一列女生女生n + 1..n + m。即结点分开存； 愿意配对的男女会有边相连； 要求出男女配对的最大匹配数目。 三、解析 有两种方法可以解决最大匹配问题：匈牙利算法、Hopcroft_karp算法。 匈牙利算法 时间复杂度O(VE) 优点是代码简单，不超时时优先使用 Hopcroft_karp算法 时间复杂度O(sqrt(V)*E) 优先时更快，缺点是代码复杂，类似最大流 其实该算法就是将匈牙利算法中的find部分通过bfs分段，一点点来找匹配而已。 四、匈牙利算法 模板 bool find(int u){ for(int v : G[u]){ if(vis[v]) continue; vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int maxMatch(){ int res = 0; for(int i = 1; i &lt;= n; i ++){ // 男生逐个去邀请追女生 memset(vis, 0, sizeof(vis)); // vis用于标记对象点是否判断过, 每次都要清零 if(find(i)) res ++; // 找到一个心仪的女生了 } return res; } 五、Hopcroft_karp算法 模板 /* 类似最大流算法 数组解释： dist[i]: 层数标记 belong[i]: i 的对象 */ bool bfs(){ queue&lt;int&gt; queue; memset(dist, -1, sizeof(dist)); fin_dist = INF; // dist为当前终点的层数标记 for(int u = 1; u &lt;= n; u ++) if(!belong[u]) que.push(u), dist[u] = 0; // 若干起点 while(!que.empty()){ int u = que.front(); que.pop(); if(dist[u] &gt; fin_dist) break; // 到增广路终点层数的点都标记好了就跳出, 后面不再标记 for(int v : G[u]){ if(dist[v] == -1){ // 未被标记 dist[v] = dist[u] + 1; if(!belong[v]) fin_dist = dist[v]; // 找到增广路, 确定增广路终点层数 else dist[belong[v]] = dist[v] + 1, que.push(belong[v]); // 继续bfs } } } return dist != INF; } bool find(int u){ if(dist[u] &gt; fin_dist) return 0； for(int v : G[u]){ if(vis[v] || dist[v] != dist[u] + 1) continue; // 询问过 || 不是上下层关系 则跳过 vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int Hopcroft_karp(){ int res = 0; while(bfs()){ // 搜索有无增广路 memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i ++) if(!belong[i] &amp;&amp; find(i)) res ++; // 若没有女朋友 &amp;&amp; 能找到 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-da-pi-pei-wen-ti-gui-na/"},{"title":"[图论][经典] 常见的图论方法归纳","content":"比如dfs、bfs、并查集、链式前向星、判断二分图等。 一、dfs 1. 定义 dfs，即深度优先搜索。顾名思义，即尽可能递归到达最深处，然后再回溯，以此类推，直到遍历完整个图。 2. 解析 通过递归实现。 主要用于解决找迷宫路径等问题。 dfs代码比bfs简单。 要领： 用vis数组维护是否走过，记得清零； dfs中continue的条件分三类：出界、已走过、不是所求。不要遗漏了。 3. 模板 const int Fx[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}; // 方向 string a[maxn]; // 记录地图 bool vis[maxn][maxm]; // vis数组记录是否走过 void dfs(int x, int y) { vis[x][y] = 1; for(int k = 0; k &lt; 8; k ++) { int nx = x + Fx[k][0], ny = y + Fx[k][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '*') continue; // 出界、已走过、不是所求 dfs(nx, ny); // 递归 } } 4. 例题 Uva 572 * * * 二、bfs 1. 定义 bfs，即广度优先搜索。顾名思义，即先走完这一层，再走下一层，以此类推，直到遍历完整个图。 2. 解析 通过队列实现。 主要用于解决简单（权值为1）的最短路问题。 要领： bfs问题要先想清楚**“状态点”如何定义，然后维护相应维度的vis、a数组（地图）。 如果需要打印路径需要用p数组**进行父节点的存储。 debug时不要太着急，可以将打印信息写的详细一点，这样才能有利于更快地发现问题！ 注意区分Dijkstra模板：bfs用的是普通队列，vis数组的更新位置在push后。 3. 变式 双向bfs 先通过逆向bfs求出距离d[maxn]，然后再进行正向的“bfs”，这样就能实现一些比较复杂的最短路径问题。 复杂状态的表示 有时后一些状态点具有很多维度（比如八数码），或取值范围很大（超过1e8），这时没有办法通过vis数组来存储，因为会爆空间。 这时可以考虑这些方法来保存vis状态：set、哈希法（推荐）、康托展开。 4. 模板 const int Fx[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; // 方向 struct node { // 队列中的结点 int x, y, dist; node(int x, int y, int dist) : x(x), y(y), dist(dist) {} }; int a[maxn][maxm], vis[maxn][maxm], ans; void bfs(int x0, int y0) { queue&lt;node&gt; que; que.push(node(x0, y0, 0)), vis[x0][y0] = 1; // 入队后紧接着更新vis while(!que.empty()) { node u = que.front(); que.pop(); if(u.x == n - 1 &amp;&amp; u.y == m - 1) { // 退出条件（可选） ans = u.dist; break; } for(int i = 0; i &lt; 4; i ++) { int nx = u.x + Fx[i][0], ny = u.y + Fx[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '#') continue; que.push(node(nx, ny, u.dist + 1)), vis[nx][ny] = 1; // 入队后紧接着更新vis } } } 5. 例题 Uva 1600 Uva 1599 Uva 10085 Uva 816 * * * 三、并查集 1. 定义 将若干点进行加边联通，每个连通块形成一个代表元Fa[i]（i为连通块中的任意一点）。 2. 解析 并查集通常用于解决与连通相关的图论问题。 优化方法有：路径压缩、启发式连接。一般为了方便，只是用路径压缩就足够了。 3. 变式 在一些比较复杂的题目中，除了要维护父子关系，要需要维护其它的关系，这个时候需要 使用额外的辅助数组。 4. 模板 普通并查集 int n, Fa[maxn]; // 并查集要使用的Fa数组 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); // 路径压缩 } int main() { ...... for(int i = 1; i &lt;= n; i ++) Fa[i] = i; // Fa初始化 ...... for(const auto&amp; e : E) { // 逐条加边 int u = find(e.u), v = find(e.v); if(u == v) continue; // 若连通 Fa[u] = v; // 若不连通则将其连通 ...... } ..... } 复杂并查集 int Fa[maxn], dist[maxn]; // 辅助数组：到father的距离（非路径压缩的距离） int find(int x) { if(Fa[x] == x) return x; int fx = Fa[x]; Fa[x] = find(fx); dist[x] += dist[fx]; // 在回溯过程中更新，需要用到原father即fx return Fa[x]; } 5. 例题 最小生成树专题 * * * 四、链式前向星 1. 定义 一种比vector快且省空间的存图方法。 2. 解析 链式向前星 就是一种用一个链表来存放每个结点的所有出边的结构，新的边从链表头插入，用于加快读图。 链表头数组：head[maxn]，head[u]指向一条包含了u的所有邻接边的链表 存所有边：E[maxm] 边序号：cnt 3. 模板 struct edge { int to, w, next; edge() {} edge(int to, int w, int next) : to(to), w(w), next(next) {} } E[maxm]; // 用链式向前星来存图 int cnt, head[maxn]; // head[u]指向一条包含了u的所有邻接边的链表 void addEdge(int u, int v, int w) { E[cnt] = edge(v, w, head[u]); // 从链表的头部插入 head[u] = cnt ++; // 更改头指针 } int main() { ...... fill(head, head + n + 1, -1); // 初始化链表头，-1表示链表尾部 cnt = 1; // cnt表示当前加入的边序号 while(m --) { ...... addEdge(u, v, w); ...... } ...... for(int i = head[u]; ~i; i = E[i].next) { // 遍历u的所有出边的方法 int v = E[i].to, w = E[i].w; ...... } } 4. 例题 Poj 3159 * * * 五、判断二分图 1. 定义 判断一个图是否为二分图。 2. 解析 通过 染色法 实现。 用 1 和 -1 两种颜色给图的点染色，用col[maxn]来存放点的颜色, 0 表示还没染色。 若无法相间染色，则不是二分图，否则是。 3. 模板 bool dye(int u, int color){ col[u] = color; // 先染色 for(int v : G[u]){ if(!col[v] &amp;&amp; !dye(v, -color)) return 0; // 下一个点没染色 就染上不同色，染不上则失败 else if(col[v] == color) return 0; // 若下一个点染了色且和当前点颜色相同， 则必不是二分图 } return 1; } int main() { ...... bool ok = 1; // 是否是二分图 for(int i = 1; ok &amp;&amp; i &lt;= n; i ++) { if(!col[i] &amp;&amp; !dye(i, 1)) ok = 0; } ...... } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-jing-dian-chang-jian-de-tu-lun-fang-fa-gui-na/"},{"title":"[图论] 复杂的图论问题归纳","content":"比如LCA问题、最大流问题等。 一、求最近公共祖先结点（LCA） 1. 定义 LCA（Lowest Common Ancestors），即最近公共祖先，是指在有根树中找出某两个结点u和v最近的公共祖先结点。 2. 解析 这里只说一种我个人比较喜欢的在线算法：欧拉序 + RMQ 时间复杂度：预处理 O(n+nlgn)，查询只需要O(1) 原理： 欧拉序 就是在dfs遍历一棵树时经过的结点序列（包括回溯时经过的结点），显然两个结点u、v的最近公共祖先就是 欧拉序中 区间[u, v] 中深度最小的结点。（其中u、v指的是u、v在欧拉序中的第一次出现，即递归过程中的记录） 因此我们只需要通过一遍dfs得到欧拉序euler[2 * maxn]、对应的结点深度dep[2 * maxn]，以及每个结点在欧拉序中的位置 pos[maxn]，就可以通过RMQ在O(1)实现内找到欧拉序中 区间[pos[u], pos[v]] 中深度最小的结点位置。 需要维护的结构： euler[2 * maxn]：欧拉序 dep[2 * maxn]：欧拉序中结点对应的深度 pos[maxn]：每个结点在欧拉序中第一次出现的位置（对应于进入递归的时候） cnt：欧拉序长度 dp[2 * maxn][log_2maxn = 25]：对欧拉序根据dep进行RMQ预处理，dp[i][j]表示区间[i，i+2^j)中深度最小的 结点下标 为了防止混乱，规定RMQ存储、询问的是区间中深度最浅的 结点下标值，并且也是通过 结点下标区间 进行询问。之后只需要利用euler数组即可映射到对应的点。另外，区间表示为 左闭右开。 3. 模板 int n, m, s; vector&lt;int&gt; G[maxn]; int cnt, euler[2 * maxn], dep[2 * maxn], pos[maxn]; int dp[2 * maxn][log_2maxn]; void dfs(int u, int fa, int d) { pos[u] = cnt, euler[cnt] = u, dep[cnt] = d, cnt ++; for(int v : G[u]) if(v != fa) { dfs(v, u, d + 1); euler[cnt] = u, dep[cnt] = d, cnt ++; } } void init_RMQ() { for(int i = 0; i &lt; cnt; i ++) dp[i][0] = i; // 最短的区间 for(int j = 1; (1 &lt;&lt; j) &lt;= cnt; j ++) { // 注意先计算小区间，所以先从小到大遍历j for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; cnt; i ++) { int idx1 = dp[i][j - 1], idx2 = dp[i + (1 &lt;&lt; (j-1))][j - 1]; dp[i][j] = (dep[idx1] &lt; dep[idx2] ? idx1 : idx2); // RMQ中存放的是深度最小结点的下标值 } } } int min_RMQ(int l, int r) { int k = log2(r - l); int idx1 = dp[l][k], idx2 = dp[r - (1 &lt;&lt; k)][k]; return dep[idx1] &lt; dep[idx2] ? idx1 : idx2; } int main() { ...... dfs(s, -1, 0); // 求欧拉序euler、dep、pos init_RMQ(); // RMQ预处理 while(m --) { ...... if(pos[u] &gt; pos[v]) swap(u, v); // 询问u、v两个点的LCA，注意要保持欧拉序中u在v前面 cout &lt;&lt; euler[min_RMQ(pos[u], pos[v] + 1)] &lt;&lt; endl; // min_RMQ的输入、输出都是下标值，区间表示为左闭右开 } } 4. 例题 Luogu P3379 * * * 二、最大流问题（Dinic算法） 1. 定义 设源点为1, 终点为N。用 G[u][v] 表示点u、v之间的容量大小，求这样一个网络图 G 中的最大流量大小ans。 2. 解析 Dinic算法 求最大流 用邻接矩阵G存图更方便 先进行bfs, 判断有无增广路的同时,标记每个点的层号 然后根据层号进行dfs, 找增广路, 更新流值, 可能有多条不相交的增广路 循环往复 3. 模板 bool bfs(){ memset(dist, -1, sizeof(dist)); // 每次重新标记dist, 因为增加了反向边, 图已经不同 dist[1] = 0; que.push(1); while(!que.empty()){ int u = que.front(); que.pop(); for(int v = 1; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == -1){ // 连接 &amp;&amp; 未被标记 的点 dist[v] = dist[u] + 1; que.push(v); } } if(dist[N] == -1) return 0; // 若无法增广到终点，则表示没有增广路了 return 1; } int find(int u, int low){ // low是源点到现在最窄的(剩余流量最小)的边的剩余流量 if(u == N) return low; // dfs出口 for(int v = 1, a; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == dist[u] + 1 &amp;&amp; (a = find(v, min(low, G[u][v])))){ // 连接的 &amp;&amp; 是上下层关系的 &amp;&amp; 能连通到汇点 min维护low G[u][v] -= a; G[v][u] += a; // 增加反向边 起容错作用 return a; //只要发现一条增广路, 就返回增广的流量 } } return 0; } int main(){ //.... int ans = 0; while(bfs()){ // 利用bfs为每个点标记dis, 若标记不到汇点, 说明已经没有增广路 int temp; // 每次增广的流量 while(temp = find(1, INF)) ans += temp; // 根据dist进行dfs找增广路, 直到找不到为止 } cout &lt;&lt; ans &lt;&lt; endl; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-fu-za-de-tu-lun-wen-ti-gui-na/"},{"title":"[区间问题] 树状数组与线段树归纳","content":"用树状数组和线段树解决一些区间问题。 一、树状数组 1. 定义 用一个数组C[maxn]模拟树状结构，来表示原数组A[maxn]的区间信息。各操作的复杂度为O(lgn)。 2. 解析 lowbit(x) 指一个数x的二进制中，最靠右的1的权值大小。如lowbit(6)=2^1, lowbit(7)=2^0，lowbit(8)=8。 树状数组就是用一个C[maxn]数组来存放原数组A[maxn]的去区间信息。具体而言，C[x]存放了从A[(x-lowbit(x))...x]区间中各元素之和。 A[0]为0，不存放有效值。 [单点更新 区间查询] 求A[1...x]的区间和就需要求出它所对应的那几个C[j]区间之和，这几个区间通过lowbit向下枚举即可得出；而更改一个值A[i]时就需要更改所有包含了A[i]的C[j]区间，同样可以通过lowit线上枚举来获得。 3. 变式 [区间更新 单点查询] 树状数组中存放 差分值 D[i] = A[i] - A[i - 1]，这样区间更新只用更新区间两端，单点查值就是getSum。 [区间更新 区间查询] 维护两个数组 sum1[maxn]存放差值 D[1]、D[2]、D[3]... 的树状数组； sum2[maxn]存放 0 * D[1]、1 * D[2]、2 * D[3]... 的树状数组 更新操作要同时更新 sum1[maxn]、sum2[maxn] 查询区间的和为：n * ∑D[i] - ∑[(i - 1) * D[i]] = n * sum1[i] - sum2[i] 证明如下： A[1] + A[2] + ... + A[n] = (D[1]) + (D[1] + D[2]) + ... + (D[1] + D[2] + ... + D[n]) = n * D[1] + (n - 1) * D[2] + ... + D[n] = n * (D[1] + D[2] + ... + D[n]) - (0 * D[1] + 1 * D[2] + ... + (n - 1) * D[n]) 4. 模板 [单点更新 区间查询] int A[100010], C[100010]; // 原数组 和 树状数组 A[1...n]有效 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 当 A[k] += v时 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 求 A[1]+...+A[k]时 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } [区间更新 单点查询] int A[100010], C[100010]; int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 不变 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 不变 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } int main(){ ...... for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); // 在[x, y]区间加上k, 即让这个区间向上突出 add(y + 1, -k); ...... int ans = getSum(q); // 查询q位置的值 ...... } [区间更新 区间查询] int A[100010]; int sum1[100010]; // 存放了差值D[1]、D[2]、D[3]...的树状数组 int sum2[100010]; // 存放了0*D[1]、1*D[2]、2*D[3]...的树状数组 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 加差值和sum2的同时还要加sum2 for(int i = k; i &lt;= n; i += lowbit(i)) sum1[i] += v, sum2[i] += (k - 1) * v; } int getSum(int k){ // 区间和为 n*∑D[i] - ∑[(i-1)*D[i]] = n*sum1[i] - sum2[i] int res = 0; for(int i = k; i; i -= lowbit(i)) res += k * sum1[i] - sum2[i]; return res; } int main(){ for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); //在[x, y]区间加上k add(y + 1, -k); ...... int ans = getSum(q) - getSum(p - 1); //查询[p, q]位置的值 } * * * 二、线段树 1. 定义 一种强大的能解决区间的修改、查询问题的方法。 2. 解析 与树状数组相比，线段树代码量更大，但是适用范围更广。 k为结点编号 根节点为1, 左孩子为 k2, 右孩子为 k2+1 每个函数都包含参数k 除建树外共4种情形：单点查询 单点更新 区间查询 区间更新(要用到懒标记f) 一个题目一般只会用到两种 线段树一般保持 左闭右闭 区间，这样代码会好写一点 注意： 无论是更新还是查询，都要down懒标记 一些线段树的变形主要需要特别注意 状态归并 和 懒标记的更新 3. 模板 #include &lt;iostream&gt; using namespace std; using ll = long long; const int maxn = 5e5 + 5; struct node { int l, r, f = 0; ll w; node() {} node(int l, int r, ll w) : l(l), r(r), w(w) {} } Tree[4 * maxn]; int n, m; ll a[maxn]; void down(int k) { int &amp; v = Tree[k].f; Tree[k * 2].w += v * (Tree[k * 2].r - Tree[k * 2].l + 1); Tree[k * 2].f += v; Tree[k * 2 + 1].w += v * (Tree[k * 2 + 1].r - Tree[k * 2 + 1].l + 1); Tree[k * 2 + 1].f += v; v = 0; } void build(int l, int r, int k) { // 建树 if(l == r) { Tree[k] = node(l, r, a[l]); return; } int mid = (l + r) / 2; build(l, mid, k * 2); build(mid + 1, r, k * 2 + 1); Tree[k] = node(l, r, Tree[k * 2].w + Tree[k * 2 + 1].w); } void update(int x, int v, int k) { // 单点更新 if(Tree[k].l == Tree[k].r) { Tree[k].w += v; return; } int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) update(x, v, k * 2); else update(x, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int l, int r, int k) { // 区间查值 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; ll res = 0; if(l &lt;= mid) res += query(l, r, k * 2); if(r &gt; mid) res += query(l, r, k * 2 + 1); return res; } void update(int l, int r, int v, int k) { // 区间更新 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) { Tree[k].w += v * (Tree[k].r - Tree[k].l + 1); // 注意是多个值更新 Tree[k].f += v; // 懒标记： 预记儿子们的变化 return; } if(Tree[k].f) down(k); // 懒标记下传 int mid = (Tree[k].l + Tree[k].r) / 2; if(l &lt;= mid) update(l, r, v, k * 2); if(r &gt; mid) update(l, r, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int x, int k) { // 单点查值 if(Tree[k].l == Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) return query(x, k * 2); else return query(x, k * 2 + 1); } int main() { ios::sync_with_stdio(0), cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, n, 1); while(m --) { int f, x, y, k; // 单点更新 + 区间查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y, update(x, y, 1); // else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; // 区间更新 + 单点查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); // else cin &gt;&gt; x, cout &lt;&lt; query(x, 1) &lt;&lt; endl; // 区间更新 + 区间查值 cin &gt;&gt; f; if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; } } * * * FinFin Fin ","link":"https://river861.github.io/post/qu-jian-wen-ti-shu-zhuang-shu-zu-yu-xian-duan-shu-gui-na/"},{"title":"[动态规划][经典] 常见的动态规划问题归纳","content":"比如LIS问题 一、最长上升子序列（LIS） 1. 定义 给出一个序列a[1...n]，要求你求出其中最长的递增子序列的长度。 2. 简单的 O(n2)O(n^2)O(n2) 算法 原理： 设 dp[i] 为把下标i作为最长上升子序列结尾位置 的最大长度，则 dp[i] = max(dp[1..i]+1)，所有dp[i]初始为1. 模板： int n, num[maxn], dp[maxn]; // num[maxn]存放了序列，dp[i]表示以a[i]为结尾的最长子序列长度 int main() { ...... int ans = 0; for(int i = 1; i &lt;= n; i ++) { dp[i] = 1; for(int j = 1; j &lt; i; j ++) { if(num[i] &gt;= num[j]) dp[i] = max(dp[i], dp[j] + 1); } ans = max(ans, dp[i]); } cout &lt;&lt; ans &lt;&lt; endl; } 3. 最快的 O(nlgn) 算法 原理： 以非严格递增子序列为例，主要思想是 贪心 + 二分。这种方法不需要dp数组，取而代之，使用的是一个low数组。 维护一个 low数组 和 ans low[i]表示到当前为止，长度为i的LIS结尾元素的最小值；ans为 当前最长LIS长度 对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长，因此该算法贪心地维护出每个长度最小的结尾元素，存放在low[i]中 维护方法 对于每一个a[i]，如果a[i] &gt; low[ans]，就把 a[i]接到当前最长的LIS后面，即 low[++ ans] = a[i]；否则， 用 a[i] 更新 low数组 中第一个大于 a[i] 的元素 low[j] = a[i] 举个例子 比如1 5 6 3 4，假设当前已经遍历到下标3，则low[] = {1, 5, 6}，下一个数字3将会把5更新为3，表示到目前为止（1 5 6 3），长度为2的结尾最小的上升子序列为 1 3 。更新后下一个4才会有可能成为长度为3的上升子序列的末尾（1 3 4），这就是贪心起到的作用（总是维护最小的结尾值）。 模板： int nums[maxn], low[maxn]; // num[maxn]存放了序列，low[i]表示长度为i的LIS结尾元素的最小值 // 贪心 + 二分 解法 O(nlogn) int main(){ fill(low + 1, low + n + 1, INF); int ans = 0; // low和ans搭配使用，ans就是当前维护到的最长长度 for(int i = 1; i &lt;= n; i ++){ if(ans == 0 || num[i] &gt;= low[ans]) low[++ ans] = nums[i]; // 若为严格递增，改为 &gt; else{ int j = upper_bound(low + 1, low + n + 1, nums[i]) - low; // 若为严格递增，改为 lower_bound low[j] = nums[i]; } } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Nowcoder 旅行青蛙 * * * FinFin Fin LIS-参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-jing-dian-chang-jian-de-dong-tai-gui-hua-wen-ti-gui-na/"},{"title":"[动态规划] 数位dp方法归纳","content":"数位dp问题其实就是模板题。 一、定义 求出在给定区间 [A,B] 内，符合条件 f(i) 的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关。由于数是按位dp，数的大小对复杂度的影响很小。 简单来说，就是解决一些与区间中的数字的计数问题，计数条件一般与数的组成有关。 二、状态量 一般采用记忆化搜索的方式来实现dp，dp的状态经常包括pos、pre、cnt、lead、limit这几项： pos：当前处理的是数位的第几项，一般从高往低走 pre：当前位的前几位的状态，由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定） cnt：随着pos的前进需要维护的一些答案值/计数值 lead：当前位是否位前导0位 limit：当前位的最大值是否存在限制 三、记忆化搜索 把dfs的答案值存放在dp[pos][pre][cnt][...]数组中，以避免重复计算。 原理：从pos开始的低位dp答案会在高位值的枚举遍历中被反复调用。若从某个pos开始的dp它的前置状态pre和之前的某一次处理完全一样，则无需再重复计算，直接返回之前的答案值即可。因为所拥有的条件和上一次完全一样。 注意：当当前位为前导0或当前位受到限制时，没有必要将该值记录到dp数组。因为这些状态并不会被重复使用。 四、模板 以下模板大多数情况可套用，但部分细节还是需要结合具体题意进行考虑。 ll a[20], dp[20][20]; // a是用来装数位最高值的数组，dp是memo数组 ll dfs(ll pos, ll pre, ll cnt, bool lead, bool limit) { if(pos == 0) return cnt; // 已经遍历完一个数的情形 if(!lead &amp;&amp; !limit &amp;&amp; dp[pos][pre][...] != -1) return dp[pos][pre][...]; // 记忆化搜索 ll res = 0, maxv = limit ? a[pos] : 9; // 计算当前位最大值 for(ll i = 0; i &lt;= maxv; i ++) { // 若当前位是前导0 if(i == 0 &amp;&amp; lead) res += dfs(pos - 1, ...., 1, limit &amp;&amp; i == maxv); // 若当前位是最高位 else if(i &amp;&amp; lead) res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); // 正常情况 else res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); } if(!lead &amp;&amp; !limit) dp[pos][cnt] = res; return res; // 注意区分res和cnt，res是问题的答案，cnt是当前状态维护的小答案，res由最终的cnt累加而成 } ll cal(ll num) { ll pos = 0; while(num) a[++ pos] = num % 10, num /= 10; // 把数按位拆分（数位dp的前提） memset(dp, -1, sizeof(dp)); // memo数组初始化为-1 return dfs(pos, 0, 1, 1); // 从高位往低位dp } int main() { ...... // 注意！！！l为0时一般要特别处理，因为数位dp的过程会将0一直当作前导0从而忽略了数值0这一个数，不过由于是计算差值所以大部分情况不影响 cout &lt;&lt; cal(r, i) - cal(l - 1, i); // 将区间计算转化为差值计算 ...... } 五、例题 Nowcoder 17867 ZJOI 2010 数位dp就是模板题！！！ * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-shu-wei-dp-fang-fa-gui-na/"},{"title":"[数学][经典] 常见的数学方法归纳","content":"一些数学算法题中常用的技巧，包括gcd、exgcd、快速幂、逆元、组合数等。 基本说明 由于数学类方法经常性混合使用（比如组合数+快速幂），因此例题在最后统一给出。 * * * 一、最大公约数和最小公倍数（gcd） 1. 定义 没啥好说，大家都懂。最大公约数 gcd(a,b) ，最小公倍数 lcm(a,b) 。 2. 解析 求最大公约一般用辗转相除法，最小公倍数可以由最大公约数导出： gcd(a,b)⋅lcm(a,b)=a⋅bgcd(a, b) \\cdot lcm(a, b) = a \\cdot b gcd(a,b)⋅lcm(a,b)=a⋅b 同时注意为了防止a*b溢出，最终我们最小公倍数用下述公式求解： lcm(a,b)=a/gcd(a,b)⋅blcm(a, b) = a / gcd(a, b) \\cdot b lcm(a,b)=a/gcd(a,b)⋅b 3. 模板 ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } * * * 二、扩展欧几里得算法（exgcd） 1. 定义 上面说的求最大公约数的方式实际上叫欧几里得算法，而这里要讲的是它的升级版，不仅可以计算出前面说的最小公约数，还可以求出相应的“不定方程解”. 2. 解析 exgcd可以快速求出下面方程中的x、y、gcd(a,b)： ax+by=gcd(a,b)ax + by = gcd(a, b) ax+by=gcd(a,b) 上面的公式为裴蜀定理，有很多有用的结论： 上述式子一定有整数解，通过exgcd可以求出其中一组整数解 若要求出其它解，只需要 x+=b/gcd(a,b)，y-=a/gcd(a,b) 即可 注意不要漏了除以 gcd(a, b) +、-可以互换，相当于从另一个方向找其它解 对于ax+by=c，若c不是gcd(a, b)的倍数，则该方程无解 ...... 3. 模板 注意 在求解 ax+by=c 时要特判 a、b等于0 的情况。 ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if(b == 0) { y = 0, x = 1; return a; } ll res = exgcd(b, a % b, y, x); y -= (a / b) * x; return res; } * * * 三、快速幂算法 1. 定义 一种用来快速求解指数很大的幂运算的算法。 2. 解析 原理是将幂次减半，底数平方，并以此类推直到幂次为0。比如310=95=(94)(91)=(812)(91)=(65611)(91)3^{10}=9^5=(9^4)(9^1)=(81^2)(9^1)=(6561^1)(9^1)310=95=(94)(91)=(812)(91)=(65611)(91)，这样原式的答案就是6561*9了。 3. 模板 普通版，注意用long long： LL fast_pow(LL a, LL b) { // 快速幂算法 LL res = 1; while(b) { if(b &amp; 1) res = res * a; // 指数为奇时分一个出来 b &gt;&gt;= 1; // 指数减半 a = a * a; // 底数平方 } return res; } 带mod版，注意用long long： LL fast_pow_mod(LL a, LL b) { // 快速幂算法 带mod版 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } * * * 四、除法求模（逆元） 1. 定义 我们都知道，对于加法、减法、乘法，求模运算都可以提前，即： (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p ) % p (a * b) % p = (a % p * b % p) % p 而除法求模不行，因此对于除法求模我们需要使用一种专门的方法，即转化为乘法求模。 2. 解析 由费马小定理： bm−1≡1(modm)b^{m - 1} \\equiv 1 (mod m) bm−1≡1(modm) 转化一下则有： 1b≡bm−2(modm)\\frac{1}{b} \\equiv b^{m-2} (mod m) b1​≡bm−2(modm) 也就是说，对于除以b取模可以转化为乘以b^(m-2)取模！ 这样就成功将除法取模转化为了乘法取模。但要注意b、m必须互质。好消息是，这里的m一般就是题目给出的mod值，一般题目给出的都是一个很大的质数。 因此我们一般称b^(m-2)为b的 逆元 ，除以b取模相当于乘以b的逆元取模。 而对于b^(m-2)的求法，参见前文的 快速幂算法 即可。 3. 模板 以求组合数的模为例，里面要用到除法（除数为阶乘）求模： int C(int n, int m) { // n! / (n-m)! / m! =&gt; n! * [(n-m)!]^(mod-2) * [m!]^(mod-2) return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * 四、指数求模 1. 定义 指数比较大的情况一般用快速幂可以解决，然而.... 有时用快速幂还是会超时....这个时候也需要将指数模一模. 2. 解析 由费马小定理： bm−1≡1 (mod m)b^{m-1} \\equiv 1\\ (mod\\ m) bm−1≡1 (mod m) 将k组上式乘到下面这个式子中 aB≡ans (mod m)a^{B} \\equiv ans\\ (mod\\ m) aB≡ans (mod m) 得到 aB+k(m−1)≡ans (mod m)a^{B+k(m-1)} \\equiv ans\\ (mod\\ m) aB+k(m−1)≡ans (mod m) 上面两个式子说明，可以对指数 模(m-1)，答案不会变化。 3. 结论 在计算指数运算时，要是指数太大，可以 模(m-1)，答案不会变化。m为题目指定的mod。 五、组合数（C(n, m)） 1. 定义 在一些题目中需要用到组合数，甚至通过组合数直接输出结果，因此有必要学习一下组合数的计算方式。 C(n,m)=n!(n−m)!m!C(n, m) = \\frac{n!}{(n - m)! m!} C(n,m)=(n−m)!m!n!​ 2. 解析 两种方法 方法一：通过动态规划预处理出C[maxn][maxn]数组，预处理用时O(n^2)，查询用时O(1) 一般只要预处理不会超时、空间不会爆 就优先用这个！！ C(n,m)=C(n−1,m−1)+C(n−1,m)C(n, m) = C(n - 1, m - 1) + C(n - 1, m) C(n,m)=C(n−1,m−1)+C(n−1,m) 方法二：仅预处理出阶乘数fac[maxn]和阶乘数的逆元inv_fac[maxn]，预处理时间O(n*lg(mod))，查询用时稍微慢一点的O(1) 若方法一预处理超时了 或 内存爆了 就用这个。 C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅modC(n, m) = fac[n]\\cdot inv\\_fac(n - m) \\cdot mod \\cdot inv\\_fac(m) \\cdot mod C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅mod 3. 模板 方法一： void init(ll n) { C[0][0] = 1; for(ll i = 1; i &lt;= n; i ++) { for(ll j = 0; j &lt;= i; j ++) { C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } } 方法二： LL fast_pow_mod(LL a, LL b) { // 快速幂 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } void init(int n) { // 预处理 fac[0] = inv_fac[0] = 1; for(int i = 1; i &lt;= n; i ++) { fac[i] = fac[i - 1] * i % mod; inv_fac[i] = fast_pow_mod(fac[i], mod - 2); } } int C(int n, int m) { // 计算组合数 return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * Last. 例题 Nowcoder 数列统计 Nowcoder 子序列 Nowcoder 火柴排队 * * * FinFin Fin ","link":"https://river861.github.io/post/shu-xue-jing-dian-chang-jian-de-shu-xue-fang-fa-gui-na/"},{"title":"[图论] 最短路问题归纳","content":"包括Dijkstra算法、Spfa算法、Floyd算法以及它们的变形。 基本原则 首先看题目n的数量级，当 n&lt;1000 时，可以使用 [Floyd算法] 快速秒杀几乎所有题型 否则 若题目中所有边全为正权，则使用 [Dijkstra算法] 否则 当出现负权时，使用 [spfa算法] 注意一些隐蔽的最短路问题，比如题目会换一种问法。详见最短路的各种变形题。 * * * 一、正权单源最短路 —— Dijkstra算法 1. 定义 计算正权图上的单源最短路，即从单个源点出发到所有结点的最短路。包含无向图或有向图。 2. 解析 使用Dijkstra算法。时间复杂度O(mlgn)，一般够用。 3. 模板 struct node { // node结构是存放在优先队列中的结构 int u, d; node(int u, int d) : u(u), d(d) {} bool operator &lt; (const node&amp; rhs) const { return d &gt; rhs.d; // 由于默认为最大堆, 而我们希望最小的先出列 } }; struct edge { //edge结构仅用于存图 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, m, vis[maxn], d[maxn]; void Dij(int s) { fill(d, d + n + 1, INF), d[s] = 0; // 初始化d数组 fill(vis, vis + n + 1, 0); priority_queue&lt;node&gt; que; que.push(node(s, 0)); while(!que.empty()) { int u = que.top().u; que.pop(); if(vis[u]) continue; // vis就写在这两行，是为了忽略掉松弛前的结点（因为并没有从队列中删除，只是压入了d更小的状态而已）， vis[u] = 1; // 因此放在这里进行判断，这是和bfs不同的 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(node(e.to, d[e.to])); // 压入了松弛后的结点，然而并没有删除原结点，因此要依靠上面的vis } } } } int main() { ...... Dij(1); ...... } 注意Dijkstra的模板和bfs有点像，但是还是不一样的： 一个用优先队列，一个用普通队列 使用vis数组的原因不同 4. 例题 Poj 2397 Poj 1847 Poj 1502 * * * 二、带负权的单源最短路 —— spfa算法 1. 定义 计算带负权的图上的单源最短路，由于可能存在负环，因此Dijkstra算法不可用。 2. 解析 这时可以使用spfa算法。最坏时间复杂度O(nm)。 带负权的最短路径问题，可以使用Bellman-Ford或它的优化版本，即spfa算法。spafa算法能解决带负权的单源最短路问题，同时判断是否存在负环。最坏时间复杂度为O(nm)。比Dijkstra慢，因此对于正权的单源最短路我们使用Dijkstra，而对于带负权的就只能使用spfa算法了。 spfa算法的原理：先从Bellman-Ford算法的原理开始，Bellman-Ford算法通过将每条边松弛n-1次来求出每个点的最终d[maxn]，即松弛到不能再松弛了。而如果第n次还存在边可以继续松弛，说明存在负环。而spfa通过让已经松弛得不能再松弛的边不再入队来实现减少冗余的松弛操作，用队列来存储每一轮迭代后还需要继续松弛的边，就是这样一个优化。 spfa的模板与Dijkstra有点像，需要注意区分。 3. 模板 struct edge { // 用于存图的edge结构 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, inq[maxn], cnt[maxn], d[maxn]; bool spfa(int s) { fill(d, d + n + 1, INF); d[s] = 0; fill(inq, inq + n + 1, 0); // inq用于标记每个点是否在队列中 fill(cnt, cnt + n + 1, 0); // cnt用于统计每个点的入队次数 queue&lt;int&gt; que; // 只需要使用普通队列 que.push(s), inq[s] = 1, ++ cnt[s]; while(!que.empty()) { int u = que.front(); que.pop(); inq[u] = 0; // 可以重复入队 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(e.to), inq[e.to] = 1; if(++ cnt[e.to] &gt; n) return 1; // 入队超过n次说明有负环 } } } return 0; } int main() { ...... spfa(1); ...... } 要注意区分Dijkstra模板和spafa模板： Dijkstra使用优先队列，spfa使用普通队列 Dijkstra使用vis数组排出重复点；spfa使用inq记录是否在队列中，用cnt记录入队次数，允许重复入队 若原图不连通，需要加一个点使得原图连通后再用spfa算法来判断负环，否则会漏判。 4. 例题 Poj 3259 Poj 3169 LightOJ 1074 * * * 三、多源最短路 —— Floyd算法 1. 定义 求任意两点之间的最短路。包含无向图或有向图，正权图、负权图。 2. 解析 使用Floyd算法。时间复杂度O(n^3)。对于多源最短路问题只能使用Floyd算法，对于单源最短路问题，若n比较小，也可以使用Floyd算法来快速解决。因为代码简单啊😀 3. 模板 const int INF = 1 &lt;&lt; 29; int n, d[maxn][maxn]; void init() { for(int i = 1; i &lt;= n; i ++) { // 初始化d for(int j = 1; j &lt;= n; j ++) d[i][j] = INF; d[i][i] = 0; } } void Floyd() { for(int k = 1; k &lt;= n; k ++) { // 枚举中间点 for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= n; j ++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main() { ...... init(); Floyd(); ...... } 要注意Floyd中会有INF相加的情况，因此INF值不能太大，这里取的是1&lt;&lt; 29. 4. 例题 Uva 567 * * * 四、差分约束问题与最短路的关系 1. 定义 即给出对n个数m组约束不等式，求其中某两个数的最值。 2. 解析 差分约束问题可以转化为最短路/最长路问题解决。 原理：以问最大值为例，问x-y&lt;=多少时，肯定是通过若干B-A&lt;=w的约束条件才可能获得，而B-A&lt;=w这一不等式可以理解为d[B]&lt;=d[A]+w，这正好符合与最短路问题中的松弛操作的条件（d[u]&gt;d[v]+w）相反，也就是松弛操作会使得这一个个约束条件被满足，因此最短路问题的算法就可以得到满足所有约束条件的不等式的一组解。这样就可以得到d[x]与d[y]的差值了。 3. 模板 具体规则如下： 首先看问题，若问题问最大值则可以转化为最短路问题；问最小值则可以转化为最长路问题； 若为最短路问题，则将所有约束转化为B-A&lt;=w的形式；最长路问题则转化为B-A&gt;=w的形式； B-A&lt;=w对应于d[B]&lt;=d[A]+w，也就是从点A到B的有向路径权值为w； 然后就可以用Dijkstra、spfa或Floyd算法来秒杀了。 若存在负环，则表示无解；若d为INF，表示有无限个解。 4. 例题 Poj 3159 * * * 五、几种常见的最短路变形题 1. 求最大边权的最小值 / 最小边权的最大值 做法 以求最大边权的最小值为例： Floyd做法： 原松弛操作：d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作：d[i][j]= min(d[i][j] ,max( d[i][k] , d[k][j])); Dijkstra/spfa算法： 原松弛操作 ： d[v]= min(d[v], d[u]+w); 变形后的松弛操作 ： d[v]= min(d[v] , max(d[u], w)); 例题 Poj 2253 Poj 1797 2. 求往返最短路的最大值 / 和 做法 数据量小的用Floyd算法秒杀； 否则通过对原图和反图（所有有向边反向）各做一次Dijkstra/spfa来解决。 例题 Poj 1511 Poj 3268 3. 确定排名 做法 用Floyd算法，dp[u][v]表示u打败了v： 原松弛操作 ： d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作 ： d[i][j] = (d[i][k] &amp;&amp; d[k][j]) ? 1 : 0; 例题 Poj 3660 * * * FinFin Fin 最短路变形-参考博客 差分约束-参考博客 ","link":"https://river861.github.io/post/tu-lun-zui-duan-lu-wen-ti-gui-na/"},{"title":"[图论] 最小生成树问题归纳","content":"包括最小生成树、次小生成树和边权极差最小的生成树算法。 基本定义 本文的代码基本按照如下的图论模型进行定义，后文用的结构若与此相同则不再赘述： struct edge { int u, v, w; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { // 边按权值排序 return w &lt; rhs.w; } }; vector&lt;edge&gt; E; // 存储所有边 int n, m, Fa[maxn]; // Fa为并查集所需的数组 int find(int x) { // 并查集的find函数 return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } * * * 一、最小生成树 1. 定义 把若干点连成连通图，求最少连成的连通图的最小边权和。 2. 解析 这是最基础的题型，直接套用Kruskal算法的模板即可 3. 模板 int main() { ...... for(int i = 0; i &lt; n; i ++) Fa[i] = i; // Fa初始化 sort(E.begin(), E.end()); // 按结点从小到大排序 int ans = 0; for(const auto&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; // 若不连通则将其连通 ans += e.w; } ..... } 4. 例题 Uva 10034 * * * 二. 次小生成树 1. 定义 顾名思义，就是边权和第二小的生成树 2. 解析 其实也比较简单，按照以下步骤即可： 求出最小生成树mst 通过以每个点为根分别进行dfs，得到maxW[maxn][maxn]数组。其中maxW[root][v]表示最小生成树mst上从root到v的路径上的最大的一条边的权值。 遍历所有不在mst上的边，比如为（u, v），用它去替换mst上从u到v路径上的最大边，从而得到一系列次小生成树替补。这些次小生成树替补权值和最小的那个就是次小生成树。 时间复杂度为O(n^2+mlogm)，基本够用了。 3. 模板 原理简单，就是代码量较大...要维护一个存放边的容器E，同时还要维护一个存放最小生成树的边的容器mst。 struct edge { int u, v, w; bool flag = 0; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { return w &lt; rhs.w; } }; struct mst_edge { int v, w; mst_edge(int v, int w) : v(v), w(w) {} }; vector&lt;edge&gt; E; // 存放所有边的容器 vector&lt;mst_edge&gt; mst[maxn]; // 存放最小生成树的容器 int n, m, Fa[maxn], maxW[maxn][maxn], ans1, ans2; // ans1, ans2分别为最小生成树和次小生成树的边权和 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } void Kruskal() { for(int i = 1; i &lt;= n; i ++) Fa[i] = i; sort(E.begin(), E.end()); ans1 = 0; for(edge&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; ans1 += e.w; e.flag = 1; // 标记这条边在mst中 mst[e.u].push_back(mst_edge(e.v, e.w)); // 将最小生成树保存起来 mst[e.v].push_back(mst_edge(e.u, e.w)); } } void dfs(int root, int cur, int fa, int val) { // 遍历最小生成树来生成maxW数组 maxW[root][cur] = val; for(const mst_edge&amp; e : mst[cur]) if(e.v != fa) { dfs(root, e.v, cur, max(val, e.w)); } } void SKruskal() { Kruskal(); // 1. 求最小生成树mst for(int i = 1; i &lt;= n; i ++) dfs(i, i, 0, 0); // 2. 求maxW[root][v]数组 ans = INF; for(const edge&amp; e : E) if(e.flag == 0) ans2 = min(ans2, ans1 - maxW[e.u][e.v] + e.w); // 3. 用不在树上的边逐个替换，然后取最小的那个树就是次小生成树 } int main() { ...... SKruskal(); ...... } 4. 例题 Uva 10600 * * * 三. 边权极差最小的生成树 1. 定义 即最大边减最小边的值尽量小的生成树 2. 解析 我们知道求最小生成树是用Kruskal算法，这里其实也是一样：我们枚举生成树的最小边E[l]，然后每次只从边权大于这条最小边边权的边中进行最小生成树的生成，这样就能得到这个生成树的最大边边权。这样枚举完后，我们就能得到边权极差最小的生成树了。 正确性证明：为什么最小生成树T就一定是这个最小边对应的苗条度最小的生成树呢？仔细回想一下Kruskal算法，最小生成树T是通过从小到大枚举边得到的，如果这个最小边对应的使得苗条度最小的最大边不在这个T中的话，那就是说存在一个由边权小于这个最大边的一组边构成的一棵更小的生成树，这就与T是最小生成树矛盾了。 3. 模板 int main() { ...... sort(E.begin(), E.end()); int ans = INF; for(int l = 0, r; l &lt; E.size(); l ++) { // 枚举最小边l，然后通过Kruskal求最大边r for(int i = 1; i &lt;= n; i ++) Fa[i] = i; int cnt = 0; // 用cnt记录加的边的条数，以此判断图是否连通完毕 for(int i = l; i &lt; E.size(); i ++) { int u = find(E[i].u), v = find(E[i].v); if(u == v) continue; Fa[u] = v; if(++ cnt == n - 1) { r = i; break; } } if(cnt == n - 1) ans = min(ans, E[r].w - E[l].w); } ...... } 4. 例题 Uva 1395 * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/"},{"title":"[枚举] 暴力求解之枚举方法归纳","content":"包括枚举排列、枚举集合、回溯法、IDA*等算法。 一、枚举排列 1. 定义 枚举出一个序列a[maxn]的所有排列。 2. 解析 枚举排列 最简单的方法是运用STL的 next_permutation函数. 3. 模板 int a[maxn]; int main(){ ...... sort(a, a + n); do{ for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 打印排列 cout &lt;&lt; endl; } while(next_permutation(a, a + n)); } * * * 二、枚举集合 1. 定义 枚举出一个序列a[maxn]的所有子集。 2. 解析 枚举子集 最简单的方法是 二进制法。 设A、B为两个集合的二进制表示，则 交集表示为 A &amp; B 并集表示为 A | B 对称差集表示为 A ^ B 补集表示为 ALL ^ A [其中 ALL = (1 &lt;&lt; n) - 1] [枚举所有子集]： 枚举 0 到 (1 &lt;&lt; n) - 1 中的每个数字 i，然后将数字 i 转化为二进制， 如果 i 的第 j 位是 1，表示集合 i 包含 a[j]； 如果 i 的第 j 位是 0，表示集合 i 不包含 a[j]。 3. 变式 [枚举大小为k的所有子集] 从 i = (1 &lt;&lt; k) - 1 开始枚举，每次找比它大的下一个包含k个1的二进制数，方法如下： 令 x = lowbit(i)，表示当前 i 的靠右的 1 的权值 令 y = i + x，即让 y 等于 i 的最低 “1” 发生进位后的数字，此时必然有 y 中 1 的个数小于等于k 通过 (i &amp; -y) 得到由于进位而导致的所有从 1 变成 0 的位，然后将其除以 x 来去掉右边的所有 0 , 然后再继续右移 1 位来去掉一个 1 (因为进位后在左侧会有一个 0 变成 1) 。这样得到的数再 和 y 或一下，就可以得到下一个包含 k 个 1 的数字。 总结起来就是 i = ((i &amp; -y) / x) &gt;&gt; 1 | y。 [枚举一个给定集合 x 的所有子集] 从 全集 i = x 开始，从大到小枚举子集，方法如下： i = (i - 1) &amp; x. 即通过减1来缩小子集，通过&amp;x来限定在x的子集中。 [枚举一个给定集合 x 的所有超集] 从 最小集 i = x 开始，从小到大枚举超集，方法如下： i = (i + 1) | x. 即通过+1来扩大集合，通过|x来限定生成的集合必定包含x。 4. 模板 打印数字 i 代表的集合 int n, a[maxn]; // 长度为 n 的序列 void print_subset(int s){ // 打印 s 所表示的子集 for(int i = 0; i &lt; n; i ++){ if(s &amp; (1 &lt;&lt; i)) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } 枚举所有子集 void solve() { for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) { print_subset(i); // 用二进制数字i表示一个子集 } } 枚举所有大小为 k 的子集 void solve(int k) { for(int i = (1 &lt;&lt; k) - 1; i &lt; (1 &lt;&lt; n);) { print_subset(i); int x = i &amp; -i, y = i + x; i = (((i &amp; ~y) / x ) &gt;&gt; 1) | y; } } [枚举一个给定集合 x 的所有子集] void solve(int x) { for (int i = x; i &gt;= 0; i = (i - 1) &amp; x) { print_subset(i); } } [枚举一个给定集合 x 的所有超集] void solve(int x) { for (int i = x; i &lt; (1 &lt;&lt; n); i = (i + 1) | x) { print_subset(i); } } * * * 三、回溯法 1. 定义 即利用递归的回溯过程，来进行状态的“还原”，从而枚举出所有的情形。 2. 解析 紫薯告诉我们，回溯法总是比生成-测试法快得多。 需要一个递归深度值 idx（或一个坐标x, y）表示当前递归进度 需要一个值 cur 表示根据当前选择所形成的值（如和值等）。 需要一个 vis 数组标记已经递归过的位置（在回溯时还原） 3. 模板 int n, vis[maxn]; void solve(int idx, int cur) { if(idx == n - 1) { // 递归出口 // 根据 cur 更新 ans return; } for(int i = 1; i &lt;= n; i ++) if(!vis[i] &amp;&amp; 其它条件) { vis[i] = 1; solve(idx + 1, cur + i); // 递归 vis[i] = 0; // 还原 } } int main() { ...... vis[1] = 1; solve(0, 1); ...... } 4. 例题 Uva 524 Uva 167 (八皇后) * * * 四、迭代加深搜索（IDA*） 1. 定义 一种通过多次dfs找解的算法。 从小到大枚举dfs深度上限maxd，每次执行只考虑不超过maxd的节点。 IDA* 能进行关于深度的剪枝，从而提高效率。 一般回溯法可以解决的问题，但是 回溯时枚举边界无法确定时，可以使用IDA*算法。 2. 解析 枚举深搜的最大深度maxd，然后在maxd的限制下去进行dfs，并利用maxd来对dfs进行剪枝，使得dfs的每一层可以很快枚举完。 每次针对一个maxd进行dfs时，实际上就是相当于反复去解答这道题，因此也要重新初始化。 由于需要由maxd限制递归层数，因此dfs函数的参数必须包括一个idx表示当前递归的层数。 剩下的参数就按照需要进行增添。 优化技巧（IDA 的精髓）： 1、考虑最优性剪枝，即通过maxd可以判断出该次迭代已经不可能得到答案时要及时退出*； 2、考虑节点的搜索顺序，以加快搜索到目标节点。 3. 模板 bool dfs(int maxd, int idx, ......) { if(idx == maxd) { // 达到当前枚举的最大深度maxd就处理完后退出 if(不满足条件) return 0; else { ...... // 记录答案 return 1; } } if(通过maxd可以判断出该次迭代已经不可能得到答案) return 0; // 精髓：最优性剪枝 for(正常的dfs枚举) { if(不满足条件) continue; if(dfs(maxd, idx + 1, ......)) return 1; } return 0; } int main() { ...... for(int maxd = 1; ; maxd ++) { memset(ans, -1, sizeof(ans)); // 每次 dfs 需要重新初始化 if(dfs(maxd, 0, ....)) break; // 找到解就退出 } ...... 4. 例题 Uva 12558 Uva 1343 * * * FinFin Fin ","link":"https://river861.github.io/post/mei-ju-bao-li-qiu-jie-zhi-mei-ju-fang-fa-gui-na/"},{"title":"[经典] 常见的高效算法归纳","content":"包括滑动窗口、哈希表、拓扑排序、单调栈、KMP、RMQ、最小表示法、二分答案、Cantor等算法。 一、滑动窗口 1. 定义 滑动窗口法（又叫双指针法），即用i,j双指针（一般用下标）对数组进行遍历，同时要需要一个额外的比如vis数组维护窗口中的元素信息，是一种O(n)的扫描方法。 2. 解析 一般比较常见的问题就是，维护窗口中的元素各不相同。 既可以用一个vis[maxn]数组来表示窗口中是否存在某个元素，也可以用一个pos[maxn]数组来存储上一次遇见某个元素的位置（为-1表示不在窗口中）。本质是一样的。 当元素数值比较大时，用unordered_map来实现vis或pos即可。 最好统一一下开闭区间，比如总是使用闭区间[i, j]作为窗口范围。 最好统一一下判断顺序，比如总是先处理当前元素已经在窗口中出现过的情况 3. 大致模板 额外维护pos ll n, a[maxn]; unordered_map&lt;ll, ll&gt; pos; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { // 维护闭区间窗口[i, j] ll num = a[j]; if(pos.count(num) &amp;&amp; pos[num] != -1) { // 先判断在数组中的情况 for(; i &lt;= pos[num]; i ++) pos[a[i]] = -1; // 注意一定要逐个退出并消除pos } pos[num] = j; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 额外维护vis ll n, a[maxn]; unordered_map&lt;int, int&gt; vis; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { ll num = a[j]; if(vis[num]) { // 先判断在数组中的情况 while(i &lt; j &amp;&amp; a[i] != num) vis[a[i]] = 0, i ++; // 注意一定要逐个退出并消除vis i ++; } else vis[num] = 1; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Uva 11572 Nowcoder 数糖纸 Uva 12174 * * * 二、哈希表 1. 定义 当你希望定义一个数组（比如vis数组），但是下标范围很大（比如1e9），这个时候就没有办法开一个vis[maxn]的数组了，因为会爆内存。 这时我们就可以通过hash的方式把下标映射到一个可以接受的小范围，比如[0...200003]。 2. 解析 一般情况下优先使用 unordered_map 或 unordered_set 但也不排除出题人把 map 和 set 给卡了...这个时候就用哈希表吧，使用最简单的开放寻址法来解决冲突， 其实就是一个链表数组。 3. 模板 const int HASH = 2000003; class Vis { public: list&lt;ll&gt; vis[HASH]; void insert(ll x) { // 插入 if(!query(x)) vis[x % HASH].push_back(x); } bool query(ll x) { // 查询 for(ll y : vis[x % HASH]) if(x == y) return 1; return 0; } } vis; 4. 例题 Nocoder 眼花缭乱的街市（卡STL） * * * 三、拓扑排序 1. 定义 给出n个点，然后给出m个依赖关系，比如（u, v）表示必须先有u才有v，要求你输出一个满足依赖的点序列，或者输出无解。 2. 解析 拓扑排序是一种经典的模板题，来源于图论，一般有队列或dfs两种不同的写法（个人比较喜欢队列写法😀）。 需要维护的结构 int in[maxn]：维护每个点的入度数目 vector Next[maxn]：记录每个点的所有出度点 queue ready：维护依赖被满足的点（若题目需要按某种排序输出，则改成优先队列） 当题目中的“点”不是整型，而是用字符串表示时，需额外维护： vector id2str unordered_map&lt;string, int&gt; str2id 3. 模板 int in[maxn]; vector&lt;int&gt; Next[maxn]; void solve() { // 拓扑排序 priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; ready; for(int i = 0; i &lt; n; i ++) if(in[i] == 0) ready.push(i); // 压入一开始就没依赖的点 vector&lt;int&gt; ans; while(!ready.empty()) { int u = ready.top(); ready.pop(); ans.push_back(u); // 记录到答案序列中 for(int v : Next[u]) { in[v] --; // 入度减1 if(in[v] == 0) ready.push(v); // 新的无依赖结点 } } if(ans.size() != n) ...... // 无解 else .... // 打印ans } 4. 例题 Nowcoder 烦人的依赖 * * * 四、单调栈 1. 定义 维护一个栈（或双向队列），保持栈内元素的单调性，存放下标还是值可以依情况而定。由于每个元素最多弹出一次，因此单调栈算法是O(n)的。 单调递增栈作用：O(1)时间获取离当前位置最近的一个小于当前值的元素。 单调递减栈作用：O(1)时间获取离当前位置最近的一个大于当前值的元素。 2. 解析 以单调递增栈为例。 通过这个栈，可以得到到当前元素为止的单调递增序列，从而能得到左侧离自己最近的比自己小的元素。 原理：只有 [比自己大的元素]， 或者 [比自己小但是却被离得更近的更小的元素弹走的元素] 才不会出现在栈中。 3. 模板 存放下标，非严格单调递增栈： stack&lt;int&gt; stk; for(int i = 0; i &lt;= n; i ++) { while(!stk.empty() &amp;&amp; a[stk.top()] &gt; a[i]) { // 先将大于当前值的元素弹出 int temp = stk.top(); stk.pop(); ...... // Do something else | 可以在这里对弹出的元素temp进行一些操作 } ...... // Do something else | 此时栈顶为左侧离自己最近的比自己小的元素 stk.push(i); // 把当前值压栈 } 4. 例题 Hdu 1506 Uva 1619 Uva 12265 * * * 五、KMP算法 1. 定义 在O(n)时间实现从长串test中找到一个匹配子串pattern。 2. 解析 由pattern串生成一个Next[maxn]数组，表示匹配失败时，下标回溯到的位置。 Next[maxn]的含义: 当前匹配串的相同前后缀的前缀末端位置。 比如字符串 aabcaad，假设在匹配d时失败，下标位于6，则对于当前匹配串p[0...5]，相同的前后缀为aa，则将会回溯到前缀的末端位置，即b处，即下标2，因此有Next[6]=2。 3. 变式 循环节 问题 （只需要Next数组） 根据Next数组的定义，Next[i]=j表示j为s[i]匹配失败后需要跳回的位置，也即是i之前和j之前可能为相同的串。 对于一个循环串来说，它的Next数组“跳回”的长度正好就是一个循环节。因此通过 i-Next[i] 即可计算出s[1..i)的循环节长度。 但注意可能字符串不是循环字符串，因此还要判定字符串长度i是否能被循环节长度 i-Next[i] 整除。 注意这样算出来的循环节长度是最小循环节长度，如果需要算出所有可能循环节长度的话，就要用一个while循环一节一节往回跳+判定，由于往回跳的长度就是循环节的长度，因此实际上这是一个枚举循环节长度的过程。比如字符串aaaa，用KMP算法求出的循环节长度为1，但实际上2也是一个循环节长度，此时就要往回跳+判定来枚举全。 扩展KMP算法（需要求出每个位置匹配的长度） 通过一个Extend[maxn]数组来记录test串从每个位置开始的匹配长度 其中注意要通过 j = Next[j] 来回溯，避免遗漏记录，具体见代码EKMP 4. 模板 普通KMP int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 直接返回第一次匹配的写法 int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; } if(j == m) return i - j; return -1; } int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 返回匹配次数的写法 int i = 0, j = 0; while(i &lt; n) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; if(j == m) cnt ++, j = Next[j]; } return cnt; } void getNext(string&amp; p, int m) { // 求Next数组，在KMP之前调用 Next[0] = -1; int i = 0, j = -1; while(i &lt; m) { if(j == -1 || p[i] == p[j]) i ++, j ++, Next[i] = j; else j = Next[j]; } } 拓展KMP void EKMP(const string&amp; t, int n, const string&amp; p, int m, int* Next, int* Extend){ int i = 0, j = 0; while(i &lt; n){ if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; Extend[i - j] = j; // Extend数组记录test串每个位置匹配了多长的pattern前缀 if(j == m){ j = Next[j]; // 继续匹配 for(int k = j; k; k = Next[k]) Extend[i - k] = k; // 回溯 使记录完整 } } } 5. 例题 Uva 1328 Uva 12012 * * * 六、RMQ算法 1. 定义 通过动态规划在O(nlgn)时间内对一个序列进行RMQ-init预处理，然后就可以在O(1)时间内得到这个序列中任意区间[l, r)中的最值！ 注意：为了避免混淆，RMQ算法中所有的区间使用 左闭右开。 2. 解析 O(nlgn)时间预处理 用 dp[i][j] 表示从下标 i 开始的连续 2^j 个数中的最小（大）值，下面以最小值为例。 转移方程：dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]) 即将区间 [i, i + 2^j) 分为 [i, i + 2^(j-1)) 和 [i + 2^(j-1), i + 2^j) 两段. O(1)时间查区间 [i，j) 中的最值 求区间长度的log值，即 k = log(r - l)。（取整后会偏小，所以第2步中要求两段） 最值为 dp[l][k] 和 dp[r - (1 &lt;&lt; k)][k] 中更小的那个。 3. 变式 有时候题目中区间的“值”是比较抽象的，这个时候可以考虑在dp[i][j]中存放区间中取到最值时的下标值，而不是区间中的最值。这样的话 预处理 和 取最值 的函数都需要做出相应修改。 一个最典型的变式例子就是树中求LCA的问题。 4. 模板 const int maxn = 5e3 + 5, log2_maxn = 15; int n, a[maxn], dp[maxn][log2_maxn]; // 序列为a[0...(n-1)] void rmq_init(){ for(int i = 0; i &lt; n; i ++) dp[i][0] = a[i]; // 初始化最短区间 for(int j = 1; (1 &lt;&lt; j) &lt;= n; j ++) // 区间长度由小到大， 大区间的最值由小区间获得 for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i ++) // 循环条件：右端点&lt;n dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]); // 注意加减法优先级大于&lt;&lt; } int rmq_min(int l, int r){ // 返回闭区间 [l ,r) 中的最小值 int k = log2(r - l); return min(dp[l][k], dp[r - (1 &lt;&lt; k)][k]); } 5. 例题 LCA问题 * * * 七、O(n)时间求最小（大）循环字符串 1. 定义 给定一个循环字符串，要求你输出它字典序最小（大）的表示方法，即确定一个开始位置。 2. 解析 以最小表示为例。 基本思想是双指针i, j，用k表示从i、j开始的子串的当前比对到的完全一样的长度，当判断出i、j的某一条子串的i+k、j+k位置有所不同时，大的那一条（比如是j）就可以往后跳k+1个字符，因为以这些字符起始的循环字符串已经不可能是最小的（比它们小的在i开始的串的子串中）。用这样的方法当i、j串中的某一个超过n时就不用再判断了（因为n个可能的起始位置都判断过了）。此时剩余的那个串就是最小的循环字符串。 3. 模板 //求循环字符串的最小字典序 最大类似 int getMin(const string&amp; s, int n){ int i = 0, j = 1, k = 0; // i, j为双指针, k为当前匹配长度 while(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n){ int temp = s[(i + k) % n] - s[(j + k) % n]; if(temp == 0) k ++; //若当前位匹配, k ++ else{ if(temp &gt; 0) i += k + 1; else j += k + 1; /* 若 s[i...i+k]比s[j...j+k]更大, 设 i&lt;p&lt;i+k 则s[p..i+k]都比s[p-i+j, j+k]大 即前者不可能为最小字典序, 因此全部跳过, 即i += k+1 j同理 */ if(i == j) j ++; // 避免死循环 k = 0; // 更改i、j后重头匹配 } } return min(i, j); } 4. 例题 Uva 1584 * * * 八、二分答案 1. 定义 顾名思义，通过枚举答案的方法，将原先的最值为题转化为判定问题。时间复杂度为 O(lgN * 判定的时间复杂度)。 2. 解析 [最大值尽可能小]、[最小值尽可能大], 这类问题时，可以考虑二分答案。 注意二分时判断OK后r等于多少，l等于多少不要搞错了。一般我们把范围想为[l, r]闭区间不容易错。所以不OK时 l=mid+1，因为不应该包含mid。此为，最好用l=1, r=2来验证一下是否会陷入死循环。 3. 模板 ...... LL l = 0, r = INF; while(l &lt; r) { LL mid = l + (r - l) / 2; if(isOK(mid)) r = mid; else l = mid + 1; } ...... 4. 例题 Uva 714 * * * 九、康托展开（Cantor） 1. 定义 全排列与整数的一种完美双向Hash方法。 2. 解析 正变换 （排列 -&gt; 整数） 双重循环，数出每一位后面有几个比它小的数，据此算出当前排列为第几小的排列（从0计起） res += small * （当前位后面一共有多少位）！ 逆变换 （整数 -&gt; 排列） 令 temp 为原序列从小到大的排列。 逆循环除，商为下一个被除数，余数为small 取temp中剩余数第small+1小的数（index为small） 在temp中删去该数 3. 模板 int cantor(vector&lt;char&gt;&amp; a, int n){ // 由字符数组 转化为 对应的排序数 int res = 0; // res为 比当前排列要小的 排列的个数 for(int i = 0; i &lt; n; i ++){ int small = 0; for(int j = i + 1; j &lt; n; j ++){ if(a[j] &lt; a[i]) small ++; // 对每一位数(或字符), 数它后面有几个比它小 } res += small * Fac[n - 1 - i]; // Fac为阶乘 } return res; } vector&lt;char&gt; decantor(int num, int n){ // 把排序数 还原为 数组 vector&lt;char&gt; temp = a, res; sort(temp.begin(), temp.end()); //temp为按从小到大排列的数组 for(int i = n - 1; i &gt;= 0; i --){ int y = num % Fac[i], s = num / Fac[i]; // s即为small num = y; res.push_back(temp[s]); // 当前第s小的数 即为当前位 temp.erase(temp.begin() + s); // 删去temp[s], 避免影响之后判断 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/jing-dian-chang-jian-de-gao-xiao-suan-fa-gui-na/"},{"title":"[动态规划] 背包问题归纳","content":"背包问题是非常经典的一类动态规划题目，包括01背包、完全背包、多重背包等。 一、01背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积（volumn）是v[i]，价值（worth）是w[i]，问如何选择物品装入背包可使价值总和最大。 2. 解析 每种物品只有选和不选两种。我们可以使用多阶段动态规划的思想来解决。 用dp[i][j]表示前i个物品（或用“从第i个物品开始的后面所有物品”的反向定义也行）装入容量为j的背包中的最大价值量。 则转移方程为： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])dp[i][j]=max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i]) 其中每多考虑一个物品i，代表一个“阶段”。括号第一项表示选，第二项表示不选。 **（优化）**由于每一项都是依赖于i-1，因此可以使用滚动数组来优化空间复杂度： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 其中注意使用滚动数组时，j的遍历必须逆序，来保证等号右边使用的dp值是上一阶段的结果值. 如果需要打印路径，则必须使用第一种写法，否则可以使用优化写法来节省空间。 3. 模板 普通写法 int V, n, v[maxn], w[maxn], dp[maxn][maxv]; for(int j = 0; j &lt;= V; j ++) dp[0][j] = 0; for (int i = 1; i &lt;= n; i ++) { for (int j = v[i]; j &lt;= V; j ++) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); } } 优化写法 int V, n, v[maxn], w[maxn], dp[maxv]; for (int i = 1; i &lt;= n; i ++) { for (int j = V; j &gt;= w[i]; j --) { // 逆序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Uva 624 Luogu 2925 干草出售 Luogu 1616 疯狂的采药 Hdu 3466 Proud Merchants * * * 二、完全背包问题 1. 定义 有n种物品和一个容量为V的背包，每种物品都有无限个。第i种物品的体积为v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 由于有无限个，所以每种物品的选择就有无限种了，因此我们不能用01背包的套路了，需要换一种思路。我们先回顾一下01背包中的优化写法，之所以j要逆序遍历是为了使得等号右边的dp值对应的是上一物品计算完后的dp值。而回到完全背包问题，由于物品有无限个，因此对于已经选择了当前物品的dp值，我们依然可以继续添加当前物品，直到达到背包上限为止。这样一想，完全背包问题的递推式就大概是： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j])dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], dp[i][j - v[i]] + w[j]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j]) 其中第1、2项和01背包一样，第3项表示继续添加当前物品。 然而上述递推式实在是比较混乱，因此实际上大多数情况下使用的是滚动数组的版本： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 可以看到这里和01背包的转移方程是一样的，但是实际用的时候这里j的遍历顺序必须为正序。 在笔者看来，完全背包问题的写法其实还可以通过刷表法来理解。就是对于每一种新的物品i，用它来不断刷新所有体积的背包的状态（最大价值量）。j的顺序遍历使得刷新的效果可以“叠加”，从而实现放入多个物品的效果。 实际上紫薯还提供里完全背包的另一种思路，即看成是带权的DAG的最长路问题，不过其代码量相比于递推式要稍微大一些，因此这里略。感兴趣的可以看一下下面的例题，有使用了这种方法的题解。 3. 模板 int V, n, v[maxn], w[maxn], dp[maxv]; fill(dp, dp + V + 1, 0); for(int i = 1; i &lt;= n; i ++) { for(int j = v[i]; j &lt;= V; j ++) { // 顺序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Hdu 4508 Hdu 1114 Piggy-Bank Luogu 1853 投资的最大效益 * * * 三、多重背包问题 1. 定义 有n种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件体积是v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 多重背包问题限制了物品的数目，这里有一种显然的思路就是，把每一“个”物品看作一个不同的“种”物品，然后用01背包去做，但是这样大概率为超时（笑），时间复杂度为O(V*∑p[i]) 顺着上述思路，有一种二进制法可以将时间复杂度降到O(V*∑lgp[i])，并且一般够用了😀。 它的原理就是将一个数量为p[i]，价值为v[i]的物体拆分成 1、2、4、8...这若干份（每一份右2的幂次份原物体构成，构成的新物体价值为kw[i]，体积为kv[i]），然后 注意最后不足2的幂次的数量也单独做成1份，这样物体的总数量就降为了 O(∑lgn)。然后就可以按照01背包问题的套路来处理这∑lgn个新物体了。 正确性是由二进制原理保证的：因为原来可能选择的1~p[i]个原物体一定可以被替换为新物体的组合。 实际上还有一种使用单调队列的优化方式，但由于技巧性比较高，一般用不到 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示原物体i的数量限制 fill(dp, dp + V + 1, 0); for(int i = 0; i &lt; n; i ++) { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 每一个新物体由k个原物体组成 if(k &gt; num) k = num; // 最后不足2的幂次的单独一份 num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 对新物体使用01背包问题处理，这里使用的是01背包问题的滚动数组模板，当然也可以不用 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 其实还有另一种写法是将原物体分为新物体后用一个新数组装起来，然后再进行01背包操作，区别其实不大。这里直接写在外层嵌套了，因为代码量少一些所以我喜欢😀。 4. 例题 Hdu1059 Luogu P1776 宝物筛选 * * * 四、混合背包问题 1. 定义 如果将前面三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的有限次（多重背包），问如何选择物品装入背包可使价值总和最大。 2. 解析 首先01背包和多重背包在模板上只有j的遍历顺序不同，因此我们可以通过一个if语句来区分这两种背包，然后分别进行不同顺序的内层循环即可 然后其实01背包是一种特殊的多重背包，即01背包是数量上限为1的多重背包问题，这样一想其实就只用写多重背包的代码即可 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示每个物品的件数，-1代表无穷个 for (int i = 1; i &lt;= n; i++) if (p[i] == -1) // 完全背包 for (int j = v[i]; j &lt;= V; j++) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); else { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 01背包和多重背包 if(k &gt; num) k = num; num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 01背包只会执行k=1这一次 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 4. 例题 Luogu P1833 樱花 HDU 3535 AreYouBusy * * * 五、二维背包问题 1. 定义 对于每件物品，具有两种不同的代价v[i], g[i]，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）V, G，物品的价值为v[i]v[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 这个其实比较简单，就是让dp数组增加一维度即可。 即dp[i][j][k]表示前i件物品装入两种代价分别为j和k的背包时可获得的最大价值量。滚动数组后就变成dp[j][k]。直接看代码会就一目了然了。 3. 模板 int V, n, v[n], g[maxn], w[n], p[n], dp[maxv][maxg]; // v[i]和g[i]分别为两种代价 for (int i = 1; i &lt;= n; i ++) for (int j = V; j &gt;= v[i]; j --) for (int k = G; k &gt;= g[i]; k --) dp[j][k] = max(dp[j][k], dp[j - v[i]][k - g[i]] + w[i]); 4. 例题 Luogu 1507 NASA的食物计划 HDU 2159 FATE * * * 六、分组背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。问如何选择物品装入背包可使价值总和最大。 2. 解析 其实分组背包可以把每个组看作一个物体，即这其实就是一个01背包问题，每个物体依然还是选和不选两种状态，只不过选的时候可以从组内的多个原物体种任意选一个。同样看代码就一目了然了。 3. 模板（伪代码） for (所有的组k) for (int j = V; j &gt;= 0; j--) for (所有属于组k的i) dp[j] = max(dp[j], dp[j - v[i]] + w[i]) 4. 例题 Luogu 1757 通天之分组背包 HDU 1712 ACboy needs your help * * * 七、背包问题的其它要素 1. 问法不同 最大值、最小值： 一次对应max、min即可 方案数目：改为sum，同时注意初始化可能需要改变 2. 范围不同 最大化、最小化： 初始化时对于前0个物品的价值量dp[i][0...V]全部初始化为0，这样即使最终的dp[n][V]未达到边界值也能有最值答案（根据提问内容不同可能会有所改变） 恰好装满 初始化时dp[i][0]=0, dp[i][1...V]全部初始化为 -INF或INF，这样不能刚好达到V的方案的最终价值量就为 -INF或INF（根据提问内容不同可能会有所改变） 3. 打印路径 不使用滚动数组的写法，即有完整的dp[i][j]记录，然后通过递归的方法print_ans打印路径。这是我个人比较喜欢的写法，因为不用额外维护存储路径信息的数组😀 维护一个记录路径信息的数组 记录下每个状态的最优值是由状态转移方程的哪一项推出来的。然后就可以根据这条记录找到上一个状态，从上一个状态接着向上推，得到整条路径。 3. 情景 区分背包问题是简单的，但是..... 如何才能发现一道题考察的是背包问题呢？ 这就需要多刷题目，直到看到题目的某个情景就能反应出是在考察背包问题。 当然我还没到那种境界就是了hhh😀 * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-bei-bao-wen-ti-gui-na/"},{"title":"[贪心算法] 区间问题归纳","content":"贪心算法中的区间问题归纳，包括区间不相交问题、区间选点问题、区间覆盖问题、区间限制问题等。 基本定义 区间用一个结构体来表示： struct Internal { int l, r; bool operator &lt; (const Internal&amp; rhs) const { return ......; // 按左端点 或 右端点 或其它排序 } }; vector&lt;Internal&gt; vec; // 存放所有区间的容器 以下代码只使用一个int类型的ans进行计数，若题目需要打印出所选择的区间/点，则改成用一个vector类型的ans存储即可。 * * * 一、区间不相交问题 1. 定义 数轴上有n个区间（li, ri），选择尽量多的区间，使得这些区间两两不相交。 2. 解析 贪心策略：按r从小到大进行排序，即总是先选取r小的区间，这样就能给后面的区间留下更多空间。 当r相等时，l无所谓，因为只要选择其中不与前一个区间相交的任意一个即可。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最大右端点 for(const auto &amp; p : vec) if(p.l &gt;= cur) ans ++, cur = p.r; 4. 例题 UvaLive 6606 * * * 二、区间选点问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的点，使得每个区间内都至少有一个点。 2. 解析 贪心策略：按r从小到大进行排序。每次选点时，总是选取第一个不被包含的区间的最右端点处。这样能让这个点接触到最多区间。 当r相等时，l无所谓，因为不影响点数。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最右的点 for(const auto&amp; p : vec) if(cur &lt; p.l || cur &gt; p.r) ans ++, cur = p.r; 4. 例题 Uva 1615 * * * 三、区间覆盖问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的区间覆盖一条指定线段[s,t]。 2. 解析 贪心策略：按l从小到大进行排序。将l&lt;s的这些区间的小于s的部分截掉（因为这部分没有用），然后从这些区间中选择出剩余长度最长的进行覆盖，然后将s更新为该区间的右端点。接下来继续遍历以此类推，直到 s&gt;=t，说明已经覆盖完毕。 这道题贪心策略稍微复杂，代码写起来也稍微麻烦，要好好记忆。 3. 模板 sort(vec.begin(), vec.end()); // 按l排序 int s = 0, t = M, ans = 0; // 目标区间[s,t] auto L = vec.begin(); while(s &lt; t &amp;&amp; L != vec.end()) { // 右端点无法覆盖 auto R = upper_bound(L, vec.end(), Internal(s, s)); // [L,R)表示容器下标范围 if(L == R) break; // 左端点无法覆盖 auto chosen = *max_element(L, R, [](const Internal&amp; a, const Internal&amp; b) { return a.r &lt; b.r; }); // 找到最长的那个 ans ++; L = R, s = chosen.r; } if(s &lt; t) cout &lt;&lt; -1 &lt;&lt; endl; // 无法覆盖完全 4. 例题 Uva 10020 * * * 四、区间限制问题 之 用时相等 1. 定义 有若干个任务，每个任务有一段执行的时间区间[li, ri]限制，每个任务的用时都相等，比如都为1。 问能否完成所有任务。 2. 解析 贪心策略：按r从小到大进行排序（r相等时，按从长到短排序），每次尽量早地执行任务（可能就是从l开始，也可能不是，因为被之前的任务占用）。这里的r实际上就是ddl，总是先处理快到“ddl”的区间。ps：结合实际生活来看，这的确是显然的。 r相等时，l按照从小到大排序，这是为了能让任务地起始时间有可能更早。 3. 模板 struct task { // 一个任务 int l, r, idx; task(int l, int r, int idx) : l(l), r(r), idx(idx) {} bool operator &lt; (const task&amp; rhs) const { return r &lt; rhs.r || r == rhs.r &amp;&amp; l &lt; rhs.l; } }; vector&lt;task&gt; vec; ...... fill(vis, vis + n + 1, 0); // 用来标记某个时间是否被占用 sort(vec.begin(), vec.end()); // 按照 (r, l) 排序 for(const auto&amp; p : vec) { int j = p.l; while(j &lt;= p.r &amp;&amp; vis[j]) j ++; // 找第一个没被占用地时间点执行任务 if(j == p.r + 1) return 0; ans[p.idx] = j, vis[j] = 1; // 用ans记录任务p的执行时间 } ...... 4. 例题 Uva 11134 * * * 五、区间限制问题 之 用时不等 1. 定义 有若干个工作，只能串行进行，已知每个工作的用时need[i]和截止期限ddl[i]，问最多能完成多少个工作？ 2. 解析 这个是超典型的工作安排贪心问题。 一个比较简单的版本是给出工作的确切开始时间和结束时间，这种问题就是典型的区间限制问题，我们按照ddl排序，然后先完成ddl早的任务即可。 但是在这道题中，任务的开始时间是可以任意决定的（只要结束时不超过ddl期限），因此我们还应该结合考虑另一种贪心：即让短的任务优先。 也就是说，对于一个给定的时间点之前，我们需要先执行短的任务，这样才能让任务完成数量最大化。这里 需要用一个优先队列来存放到当前时间点为止，所有已经选择的任务 。用这个优先队列的目的是为了能获得已经选择的任务中用时最长的那一个，这样就能在当发现一个任务由于超时无法选择时可以有尝试替换的机会（即从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时）。 贪心策略：按r从小到大进行排序，每次尽量早地执行任务。当碰到一个任务超时，尝试从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时。 3. 模板 struct task { int need, ddl; task(int need, int ddl) : need(need), ddl(ddl) {} bool operator &lt; (const task&amp; rhs) const { return ddl &lt; rhs.ddl; } }; ...... sort(vec.begin(), vec.end()); priority_queue&lt;int&gt; que; int cur = 0; // 当前时间点 for(const task&amp; t : vec) { // 总体上还是优先考虑ddl早的任务 if(cur + t.need &lt;= t.ddl) { // 不超时 cur += t.need; que.push(t.need); } else if(!que.empty() &amp;&amp; que.top() &gt; t.need) { // 反正都会有一个任务不能完成，不如留下用时短的任务（当前任务） cur += t.need - que.top(); // 即用这个ddl更晚的但用时更短的task替换一个ddl早一些但是用时长的task que.pop(); // 由于当前任务的ddl更晚，用时也更短，因此替换后必然不会超时 que.push(t.need); } } cout &lt;&lt; que.size() &lt;&lt; endl; ...... 4. 例题 Uva 1153 * * * FinFin Fin ","link":"https://river861.github.io/post/tan-xin-suan-fa-qu-jian-wen-ti-gui-na/"},{"title":"Student Elearning App","content":"复旦elearning系统的安卓app版，网络创新实验 PJ。 一、项目名称 ​ Student Elearning App 二、项目介绍 1. 项目功能、用途与设计思想 本项目为学校elearning系统的手机App版，使掌上浏览elearning成为了可能。在实现elearning大部分原有功能的基础上，本项目还针对elearning现有的缺陷做出有针对性地改进，实现对elearning功能的筛选、发扬和再创造。 在用途方面，就是让学生们能十分便捷地浏览elearning上的课件、作业等信息，另一方面，还可以通过日历功能进行待办的记录等，具体的功能与效果将在后面叙述。 本项目的设计思想为用户至上。即尽可能地提升用户的使用体验，在界面上做到尽可能的美观，在功能上做到尽可能的人性化。 2. 总体设计与框图 ​ 框图中客户端为用户的手机客户端，服务端为服务器端。 在客户端，Login模块负责用户的登陆界面，它包含的信息管理模块用于在用户手机上储存用户的用户名、密码；主模块即用户登录成功后进入的主界面，它包含Dashboard、Calendar、Home三个功能区，分别用于用户的课程管理、代办管理、个人信息管理。 其中，Dashboard功能区由若干个Course模块组成，每个Course模块代表用户所选的一门课程。在每个Course模块中，用户可以分别浏览公告、作业、人员、文件信息，这些分别由相应的模块实现，还可以通过Color模块为课程卡片换色。Home功能区除了复用的Files模块和Color模块外，还包含一个All-to-do模块，主要是用于对用户所有待办事项的集中显示。Calendar功能区由于功能之间联系紧密，因此没有子模块。 在服务端，按处理方式主要分两类请求。若是对TOKEN的请求，则利用爬虫的手段，通过用户的用户名和密码获取用户TOKEN，然后将其返回给客户端。在这之后的所有客户端请求都将附带TOKEN。对于这些其它请求，服务端将根据请求的内容构造相应的新请求，然后将之发送给Elearning-API文档所提供的相应接口获取用户数据，然后将数据清理、整理后发送回客户端。 3. 功能的效果展示 1） 登录 若之前已登录过，则用户名和密码将会被自动填充；每当进行数据请求时界面都会有loading动画。 2）Dashboard功能区 查看公告（Announcements） 可以在公告列表中查看该课程的公告，长公告支持滚动，同时支持图片渲染。这里是通过HTML模块实现的。 查看文件（Files） 如果是文件夹则可以继续打开，如果是文件则可以点击进行在线浏览，各类型文件用图标区分。在线浏览的功能在模拟器中无法运行，在真机上则可以，如下图： 在线浏览时可以放大、滚动。 查看作业（Homework） 可以在作业列表中查看该课程的作业，列表项中绿色图标表示已完成，未完成将是红色。点击进入可以查看该项作业的详细要求，这里也是通过HTML模块渲染实现的。 查看人员（Members） 在人员列表中可以查看该课程的人员信息，包括老师、助教和学生的头像、姓名、学号信息。 修改课程卡片颜色 点击右上角的颜色板按键，可以为该课程换色，除了选择颜色，还可以调节亮度。如图换成了深粉色。 3）Calendar功能区 上下滑动切换周视图和月视图；左右滑动则是进入上一周/月和进入下一周/月。 一句话任务的新增、删除、查询 日历右上角3个按键分别为：跳到今日，新增任务，切换周月视图 每个任务项右边的2个按键分别为：设为已完成，删除任务 每日任务的完成情况用颜色标记 绿色：表示过去某一天的任务全部完成 红色：表示过去某一天还有任务没有完成 蓝色：表示将来某一天有计划 4）Home功能区 个人界面的右上角3个按键分别为：退出登录，清空文件缓存，修改个人颜色 个人代办事项的集中显示 包括未完成的作业，以及在日历中进行的计划，都会在这里集中显示。 个人文件夹 这里复用的和课程文件一样的Files模块，可以在这里找到自己提交的课程作业文件。 4. 项目部署方法 部署前的说明： a. 保持网络连接，若是模拟器要注意设置好网络，确保网络能连接到服务端（特别是对于android自带的模拟器，可以使用 emulator @[模拟器设备名] -dns-server 8.8.8.8,114.114.114.114 指令来使用Google提供的DNS地址启动模拟器） b. 第一次登陆会有点慢，因为需要爬虫获取TOKEN，请耐心等待 1）方法一：使用远端服务器 这种方法将使用我已经在阿里云服务器上搭建的服务端。（2020.10到期） 如果认为不够安全，则可以在自己的服务器上将后端代码进行部署，然后修改源码中的 com.example.elearning.ElearningApi 中开头的 MyBackend 字符串并重新build出apk来安装运行。 将 elearning.apk 直接安装在真机或模拟器上即可登录运行。 2）方法二：使用本地服务端 使用python3运行 ElearningBackend\\MyBackend.py 来在本机启动服务端； 使用 ipconfig 找到本机的 IP 地址； 检查网络：在要运行 app 的设备（真机或模拟器）上访问 http://[本机IP地址]:5555/hello，若能访问成功，说明本地服务端可用，则可以直接进行下一步；若访问失败，请检查真机或模拟器的网络设置； 修改源码中的 com.example.elearning.ElearningApi 中开头的 MyBackend 字符串为 http://[本机IP地址]:5555，它表示服务端的 url； 重新 run 源代码即可启动 app 并登录运行（这里要注意 gradle 版本等问题）。 三、项目难点与解决技术 1. 登录比较麻烦 难点描述：学校elearning的所有api都需要用TOKEN作为请求的凭证，而获取TOKEN的api又需要用学校elearning系统的 Develop Key 作为请求的凭证。即没有权限的问题。 解决方法： 通过爬虫手段获取TOKEN信息。本项目直接使用的是 Selenium 自动化工具来爬取用户的TOKEN。这种方法优点是简单直接，缺点是有点慢。 解决爬取慢的问题。我在手机客户端实现了信息管理模块，不仅用来存储用户名和密码，还将用户第一次登录所获取的TOKEN也存储在了手机客户端中（具体为存储在 SharedPreferences 中），由于爬虫获取的是无限期的TOKEN，因此理论上一部手机安装完这个app后就只需要爬虫一次，之后的请求就直接使用本地已经存储的TOKEN即可。 技术总结：Selenium、android.content.SharedPreferences 2. 在线浏览如何实现 难点描述：android原生的web浏览器是没有办法打开复杂的文档的，比如elearning中常见的ppt、pdf类型的文件。 解决方法： 使用第三方的文件在线浏览技术，这里选择的是 腾讯TBS服务。腾讯TBS服务简单来说就是使用一种基于x5 内核的web浏览器来实现文件的在线浏览，目前可以支持多达46种文件的打开，像在微信、QQ等中打开文件都是使用的这种技术。缺点是由于模拟器中不支持x5内核，因此在模拟器中无法使用该功能。 解决模拟器无法使用的问题。即进行真机调试。由于我没有安卓手机，因此这里需要请有安卓手机的同学帮忙远程调试。 技术总结：腾讯TBS服务。接入教程参考官网 https://x5.tencent.com/tbs/guide/sdkInit.html 3. 需要实现的模块太多了 难点描述：由于app的功能繁多，项目工程量实在巨大。具体见前面的设计框图。 解决方法： 尽可能复用模块。在设计时，我将大部分界面设计为相似的列表结构，比如Course模块中的公告列表、文件列表、作业列表、人员列表以及Home模块中的待办列表，最终复用了同一个 ListView，只是每种列表项的布局和点击效果不同罢了。而要实现一个能装入不同类型Item的ListView，就需要设计一个可复用的自定义 BaseAdapter， Adapter是一种用来帮助填充数据的中间桥梁。 多使用第三方库。 为简化网络请求代码的复杂性，使用了开源的网络框架okhttp3 为简化json数据解析的复杂性，使用了第三方库fastjson 为简化图片的加载和缓冲的复杂性，使用了第三方库 glide 技术总结： 1） 可复用的自定义BaseAdapter。参考教程：https://www.runoob.com/w3cnote/android-tutorial-customer-baseadapter.html。最终的实现位于 com.example.elearning.util.SuperAdapter 2）好用的网络请求框架 okhttp3。导入包：com.squareup.okhttp3:okhttp:4.4.0 3）好用的json解析第三方库 fastjson。导入包：com.alibaba:fastjson:1.1.55.android 4）好用的图片处理第三方库 glide。导入包：com.github.bumptech.glide:glide:3.7.0 4. 界面美化太难了 难点描述：安卓原生开发的界面美化实在困难，很难达到像网页那样的界面质量。 解决方法： 尽可能挖掘可以美化的地方。例如我在课程卡片上增加了阴影效果，点击时增加了涟漪效果等，并且还重新自定义了toast的样式，这些是原生android可以实现的技术。 排版时设计尽可能规整。排版时大部分使用的是 LinearLayout 和 RelativeLayout，也因此支持横屏。 多使用第三方库。如 Loading 界面、Calendar 界面、Color 选择器，都使用了相应第三方库。 技术总结： 1）涟漪效果。最终实现的类位于 com.example.elearning.util.MyButton 2）好看的 Loading 界面。导入包：com.zyao89:zloading:1.2.0 3）好看的 Calendar 界面。导入包：com.haibin:calendarview:3.6.6 4）好看的 Color 选择器。导入包：com.github.QuadFlask:colorpicker:0.0.15 四、项目总结 选择一个有趣的项目内容很重要。若不是觉得有趣，我一定是做不完这个项目的。 多利用第三方库很重要。若不是借用了许多好用或好看的第三方库，我一定是做不到这样的效果的。并且学习的这些第三方库若以后还做app的话一定还能用上的。 一些遗憾。可惜这个app只能用在安卓手机上，并且我也不是用的安卓手机...不过感觉如果能给周围的同学带来便利，就已经很满足了！ * * * FinFin Fin Github源码 ","link":"https://river861.github.io/post/student-elearning-app/"},{"title":"WeTalk 简易聊天室","content":"顾名思义，一个简单的多人聊天室程序，计算机网络PJ。 一、项目基本聊天功能展示 运行环境：Ubuntu 18.04、Python 3.6、PyQt5 运行指令： 服务端启动：python server.py 客户端启动：python WeTalk.py 输入进入聊天室所用的昵称然后回车进入 第一个进入聊天室的用户将会被提示成为群主(Group Leader)。 主界面主要分为四部分：上方工具栏，包含该聊天室的各种功能；中部消息框，用于显示用户发送的即时消息；右方用户栏，用于显示当前加入的所有用户的昵称；下方输入框，用于本用户输入并发送消息。 在输入框中输入信息开始愉快的聊天！ 支持多人聊天。聊天消息会在消息框中渲染出气泡效果。支持中英文。 二、项目架构介绍 1. 服务端 1 + 2n 线程 主线程 监听连接请求，每收到一个客户端连接则分配一个Server类对象服务之。每个Server类对象会启动两个线程，一个receiver线程和一个sender线程，分别负责信息的接收和信息的发送。 while True: conn, addr = s.accept() print(f'new connection: addr={addr}') _ = Server(conn, addr) receiver线程 接收所连接的那个用户的所有请求。由于是端到端的连接，因此这里每个receiver只会接收到单个用户的请求信息，其他用户的请求信息会由它们专属的server对象的receiver线程接收和处理。 接收到消息后，首先根据消息的“头部”进行分类，具体的分类将在之后给出。大体分为两类： 群发请求 receiver接收到群发信息后，对服务端本地的全局数据缓冲池进行更新。利用缓冲池的全局性来让其他用户的server能探测到该用户做出的改变。根据消息具体所属类型的不同，会更新服务端不同的数据缓冲池或做出其它操作。缓冲池类型将在介绍具体功能时分别给出。 单发请求 receiver接收到单发信息后，对该server对象自己所维护的局部变量进行更新。对象内部变量的局部性让其它server探测不到该单发信息，从而实现该用户请求的隐蔽性。比如该用户下载文件的请求即为单发请求，sender只会将文件发给发出了请求的用户，而不是群发。 def update_buf(self, text): '''更新全局的数据缓冲池 ''' global msg_buf, msg_num, msg_lock, logIO_buf, logIO_num, logIO_lock ............ mark = text[:mark_len] text = text[mark_len:] ............ receiver会将收到的字符串信息传入上述函数，该函数首先从字符串中截取头部mark，之后将通过mark的不同对不同的全局缓冲池或局部变量进行更新。 sender线程 群发信息 需要群发给所有用户的信息，即为全局缓冲池中发生改变的信息。sender将这些改变发送给它所服务的客户端，这样一来n个sender线程的总体效果就是将全局缓冲池的变化“群发”给了n个不同的客户端。通过receiver改变全局变量，再通过sender将全局变量的改变群发出去，这就是该简易聊天室的基础原理。 while True: try: with logIO_lock: # 用户IO信息的群发，服务端并不需要知道有哪些用户，只需要转发用户进出的信息 while self.__next_logIO &lt; logIO_num: self.__send_UTF8(USER + logIO_buf[self.__next_logIO] + END) self.__next_logIO += 1 with msg_lock: # 群发消息的群发 while self.__next_msg &lt; msg_num: self.__send_UTF8(MSG + msg_buf[self.__next_msg] + END) self.__next_msg += 1 ....... 我们以用户IO消息为例。logIO表示用户login和logout的信息。其中logIO_buf、logIO_num、logIO_lock为全局变量，分别表示logIO信息的存储缓冲池、logIO信息的当前接收数量、logIO_buf对应的互斥锁。self.__next_logIO为该对象所维护的局部变量，表示该对象所负责的客户端已经接收的logIO数量。当self.__next_logIO&lt;logIO_num时，表示该客户端上的信息比服务端的旧，需要更新，于是就会发送需要发送的下一条新的logIO，直到客户端的信息数量和服务端一致。互斥锁的目的是防止sender线程和receiver线程对logIO_buf的访问冲突。 以服务端的全局缓冲池作为标准，更新各个客户端的缓冲池，是本项目群发的具体实现方式。 单发信息 单发消息较为简单，只需要通过检查局部变量是否发生了改变，若发生了改变，则发送给客户端即可。由于该局部变量只为该server所有，因此完全不会影响到其它server信息的发送。 2. 客户端 1 + 2 线程 主线程 GUI界面的响应线程，负责响应用户对程序界面的操作，并根据操作的具体内容进行相关函数的执行。本项目的GUI界面通过PyQt5 + html渲染实现。 receiver线程 与服务端receiver线程类似，该线程接收所有发送给该客户端的信息，并根据信息类型更改客户端本地的全局缓冲池或全局变量。这里使用全局变量是为了能让GUI模块探测到信息的变化，从而刷新界面。由于客户端不需要考虑对其它客户的影响，因此比较简单，全部改变通过维护本地全局变量来体现即可。 def update_buf(self, text): # 转存数据到本地全局变量就好了 '''更新客户端本地数据缓冲池 ''' global msg_buf, msg_num, msg_lock, logIO_buf, logIO_num, logIO_lock ............ mark = text[:mark_len] text = text[mark_len:] ............ receiver根据收到的信息头部mark来判断需要进行的更新操作，然后更新到全局变量中即可。 refresher线程 该线程专门用来探测客户端本地全局变量是否改变，若改变，则刷新相应的界面组件。实现方式是QTimer()，即定时探测。 # 起refresher线程 self.timer = QTimer() self.timer.timeout.connect(self.__refresh) self.timer.start(20) 本项目设置为每20毫秒进行一次刷新，即调用self.__refresh()函数 下面同样以logIO信息的刷新来简单说明一下刷新的实现方法： def __refresh(self): ''' refresh线程（由Qtimer维护） ''' global logIO_buf, logIO_num, logIO_lock ........ try: with logIO_lock: while self.__next_logIO &lt; logIO_num: opera = logIO_buf[self.__next_logIO] if opera[0] == '+': self.main_widget.userlist_widget.add(opera[1:]) elif opera[0] == '-': self.main_widget.userlist_widget.delete(opera[1:]) self.__next_logIO += 1 .......... 和服务端运用的是类似的方法。GUI自己维护一个用来表示上一次刷新到的信息的位置self.__next_logIO，然后将其与全局变量logIO_num进行比较，由此判断是否需要刷新用户列表。若需要，则调用用户列表组件userlist_widget的相关函数进行用户的增减，从而实现界面的更新。 顺便一提，无论是客户端全局还是服务端全局实际上都只储存了用户进出的信息，真正的用户列表实际上只储存在了userlist_widget组件中。 3. 通过加密算法实现安全传输 Diffie-Hellman 密钥交换 客户端： # 大素数p 原根g 秘钥a 公开秘钥A p = 1945555039024054273 g = 5 a = None A = None # 共享秘钥K 加密时要用到的初始化向量IV K = None IV = None 客户端初始持有一个大素数及其原根。一般来讲，大素数要求达到100位以上才能保证安全性，这里仅做模拟，以一个18位的素数为例。5为该素数的一个原根。 # 建立连接 conn = socket.socket() conn.connect((self.host, self.port)) # 开始交换秘钥 a = random.randint(0, p - 1) A = pow(g, a, p) # 计算公开秘钥A # 发送 g, p, A给服务端 conn.sendall(bytes(KEY + str(g) + DIV + str(p) + DIV + str(A) + END, encoding='utf-8')) 在客户端刚刚与服务端建立连接之后、启动接收线程和界面之前，进行密钥交换流程。 首先客户端产生随机数a(a&lt;p)a(a &lt; p)a(a&lt;p)，然后计算出客户端的公开秘钥A=ga mod pA=g^a\\ mod\\ pA=ga mod p ，计算完成后将g、p、A发送给服务端。 服务端 # 公开秘钥B 共享秘钥K 初始化向量IV self.__B = None self.__K = None self.__IV = None 服务端为每一个客户端都专门创建了相关的参数用于存储加密相关的秘钥和参数。 def __recv_key(self): recv_text = '' while True: recv_text += str(self.__conn.recv(4096), encoding='utf-8') index = recv_text.find(END) if index != -1: break start = recv_text.find(KEY) text = recv_text[start + mark_len: index] gpA = text.split(DIV, 2) g, p, A = int(gpA[0]), int(gpA[1]), int(gpA[2]) b = random.randint(0, p - 1) self.__B = pow(g, b, p) # 计算公开秘钥B self.__K = pow(A, b, p) # 计算出共享秘钥K self.__IV = str(self.__K)[-16:] self.__K = str(self.__K)[:16] 收到客户端发送的g、p、A后，服务端计算其针对于该用户的公开秘钥B=gb mod pB=g^b\\ mod\\ pB=gb mod p 和共享秘钥$K=A^b\\ mod\\ p $，计算完成后，服务端再将其计算出的公开秘钥B单发给客户端。 客户端收到后也能计算出共享秘钥K=Ba mod pK=B^a\\ mod\\ pK=Ba mod p。至此，客户端与服务端的密钥交换过程结束，它们拥有相同的共享秘钥K。之后的传输将用该共享秘钥K，采用AES算法进行加密。 由于AES算法要求向量IV和秘钥K都为16位串，因此这里分别截取后16位和前16位作为IV和K。 当且仅当客户端和服务端都得到了共享秘钥K后，客户端才开始初始化界面，然后发送Login消息。在此之前都会被阻塞。 使用AES加密传输内容 # 加密函数 def encrypt(text, K, IV): text = add_to_16(text) cryptos = AES.new(K.encode('utf-8'), AES.MODE_CBC, IV.encode('utf-8')) cipher_text = cryptos.encrypt(text) # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串 return b2a_hex(cipher_text) 加密采用的是AES中的CBC模式，其中还通过补零转16进制字符串的方法来防止传输出错。 # 解密后，去掉补足的空格用strip() 去掉 def decrypt(text, K, IV): cryptos = AES.new(K.encode('utf-8'), AES.MODE_CBC, IV.encode('utf-8')) plain_text = cryptos.decrypt(a2b_hex(text)) return plain_text.rstrip('\\0'.encode('utf-8')) 解密过程同理，要将多余的空格去除。这里解密我选择直接返回bytes序列，这是为了方面之后文件的传输。 效果 成功的实现了加密传输，之后的传输都会进行这样的加密。 4. 字符串标志位 通过设置必要的标志位来区分不同的信息类型。标志位又分为截断标志位和分类标志位。 截断标志位有2个： END = '__END___' DIV = '__DIV___' END用来标志一条传输信息的结尾位置，用来预防出现截断发送或合并发送的情形，具体之后会讲。 DIV用来分隔一条传输信息中的两个不同部分，例如在一条群发消息中，用户名和消息内容就需要用DIV分隔开，因为它们必须储存在同一条信息中配对传输。 分类标志位有很多个： MSG = '__MSG___' # 消息 USER = '__USER__' # 用户登录登出信息 LOGIN = '__LOGI__' # 新登录信息 LOGOUT= '__LOGO__' # 新登出信息 INIT = '__INIT__' # 初始化信息 HIS = '__HIS___' # 历史记录 ROLL = '__ROLL__' # 撤回消息信息 NAME = '__NAME__' # 重名信息 GRANT= '__GRANT_' # 任免信息 KICK = '__KICK__' # 踢人信息 UPLOAD= '__UPL___' # 上传信息 FNAME = '__FNAME_' # 新文件信息 DOWNLOAD='__DOWNL_' # 下载信息 FILE = '__FILE__' # 文件信息 KEY = '__KEY___' # 公开秘钥信息 FACE = '__FACE__' # 表情信息 mark_len = 8 分类标志位会加在发送信息的头部（即为前面提到的mark），用于区分该信息的类型。 例如一个叫River的用户发送一条Hello的消息，则该消息的传输形式如下： __MSG___River__DIV___Hello__END___ 其他标志位的具体含义将在下面介绍具体功能时相应给出。 注意到本项目中所有的标志位都规定为了8位，这样是为了方便字符串处理。 5. 三种不同的传输函数包装方式 def send_UTF8(text): # 负责发送utf-8可编码类的消息 global conn, K, IV try: conn.sendall(MyCrypto.encrypt(text, K, IV)) # 加密发送 except Exception as err: print(f'[send ERROR] {err}') def sendFile(filename, filebytes): # 负责发送文件 global conn, K, IV try: conn.sendall(MyCrypto.encrypt(UPLOAD + filename + DIV + str(len(filebytes)) + END, K, IV)) # 先发文件名和大小 conn.sendall(filebytes) # 然后发送文件bytes序列 return True except Exception as err: print(f'[sendFile ERROR] {err}') return False def recv_bytes(): # 负责接收加密的所有消息 global conn, K, IV try: text = conn.recv(4096) print(f'Recving Cipher: {text}') return MyCrypto.decrypt(text, K, IV) # 接收后解密 except Exception as err: print(f'[recv_file ERROR] {err}') 为了方便使用，本项目中将SOCKET中的函数自行进行了包装。发送函数将文件的发送单独的分离出来，因为文件的发送不能采用utf-8编码，且文件的发送序列较长。接收函数统一包装为接收bytes序列的形式，这样方便后续处理。加密和解密过程也包装在这三个函数中了。 文件的发送这里采用的是先发送一个包含了文件名和文件长度的短消息后，在单独进行文件的发送。短消息的格式为： __UPL___fileName__DIV___fileLength__END___ 发送的长度将保证接收方完整地接收文件。 注意到这里还通过try-except捕获收发过程中可能出现的错误。 三、特殊功能介绍 1. 快速退出 效果展示 出于人性化考虑，当点击窗口右上角的关闭键退出群聊时，会弹出是否退出的询问框。当需要快速退出时，点击工具栏第一个QuickExit按键即可直接退出。后面将提到的群主踢人功能就是通过强制触发被踢用户的QuickExit功能实现的。 实现方法 app.exec_() if nickname is not None: print('LOGOUT.') # 我走了 send_UTF8(LOGOUT + nickname + END) conn.close() 点击按钮后，窗口关闭，应用退出，然后会执行上面语句。发送相应的LOGOUT字符串，然后关闭连接。 __LOGO__River__END___ 服务端接收到上面字符串后，receiver线程提取出用户名River然后加入logIO_buf中，然后return，即结束了receiver线程。 if not self.__receiver.isAlive(): if(len(threading.enumerate()) == 2): # 当所有用户都退出时，清空缓存池和缓存文件 self.__cleanBuf() self.__conn.close() return sender线程将logIO_buf中更新的内容群发出去，告诉其它用户River退出这一信息后，会执行上述代码。当发现receiver线程死掉了后，首先检查服务端一共还剩下多少个线程，若只剩下2个，说明自己是最后一个非主线程，则清空所有缓冲池，然后也结束自己，同时关闭conn连接。 通过上述交互，就实现了用户的干净退出。清除缓存池是因为，当自己是最后一个非主线程时，说明自己是最后一个退出的用户，该用户退出后聊天室将为空，即表示当次聊天结束。下一个进来的人不应该访问得到上一批人群聊的信息。这保障了聊天信息的隐蔽性。 2. 查看历史消息 效果展示 点击工具栏的History按键会弹出在加入聊天室之前，之前的人的聊了啥，即展示历史消息。历史消息中被撤回的消息会被替换。 实现方法 # 请求历史记录 send_UTF8(HIS + END) self.history_widget = HistoryWidget() self.history_ok = False 实际上历史记录的这个窗口是在用户登录后就创建的。在用户登录后，马上发送请求历史记录的信息，然后构建历史记录窗口。History按键只是简单地让历史记录窗口显示出来而已。 __HIS_____END___ 这是一个单发请求。当服务端receiver接收到该请求后，将局部变量self.require_history的值置为True。然后sender会探测到该局部变量的变化，将历史记录单独发送给该客户： with msg_lock: if self.require_history is True: seq = str(msg_buf[:self.__next_msg]) self.__send_UTF8(HIS + seq + END) self.require_history = False msg_buf[:self.__next_msg]截取了该用户登录前的msg_buf直接转化为字符串传输。而从self.__next_msg开始的之后的信息，该用户则会通过服务端的群发接收到，即会显示在当前对话消息框中。这样的设计确保了信息不会遗漏。 然后客户端接收服务端发来的历史记录： elif mark == HIS: global history_buf, history_lock if text == '[]': global no_history no_history = True return with history_lock: history_buf = eval(text) print(text) 判断出HIS头部后，简单的改变全局变量no_history和history_buf的值即可。之后refresh()线程就会根据更新渲染历史消息框的内容。这里维护了一个no_history全局变量用来处理没有历史记录的情形。此时会弹出告知无历史消息提示，而不是历史消息框。 3. 消息撤回 效果展示 撤回前： 撤回后： 点击工具栏第三个Rollback按键实现消息的撤回。如图所示，撤回将在别人的客户端和自己的客户端撤回该用户最后一条发送的消息。同时会将服务端msg_buf中的相应消息替换走，即从历史记录中也掩盖掉该条消息。 实现方法 def rollBack(self): '''发送撤回请求 ''' send_UTF8(ROLL + nickname + END) Rollback按键直接触发上述函数，发送相关字符串形式的请求： __ROLL__River__END___ 服务端receiver接收到ROLL请求后，会更新roll_buf、roll_num，它们表示需要撤回消息的用户队列 elif mark == ROLL: global roll_buf, roll_lock, roll_num with roll_lock: roll_buf.append(text) roll_num += 1 with msg_lock: for i in range(len(msg_buf) - 1, -1, -1): if msg_buf[i].split(DIV, 1)[0] == text: # 覆盖该用户的最后一条信息，若删除的话会有下标麻烦 msg_buf[i] = 'NOTE' + DIV + '[==This Message Has Been Withdrawed.==]' break self.__debugInfo('RollBack -&gt; ' + text) 同时将服务端本地的msg_buf中撤回的消息替换掉。这里通过替换的方式而不是删除的方式是为了避免处理下标而带来的麻烦。 with roll_lock: while self.__next_roll &lt; roll_num: self.__send_UTF8(ROLL + roll_buf[self.__next_roll] + END) self.__next_roll += 1 然后sender通过上述代码利用老办法将roll_buf中更新的内容群发到客户端，然后客户端将撤回请求接收到本地全局缓冲池roll_buf后，等待refresher更新即可。 讲到这里，我们可以发现群发的操作其实几乎是一样的，无非是针对不同的消息头部、不同的全局缓冲池罢了。因此之后的群发操作若不是有特殊操作，我将不再赘述。 4. 表情/图片发送 效果展示 实现方法 客户端从本地选择要上传的图片后，将图片序列发送至服务端，采用的适合发送文件一样的先发送一个包含用户名和图片大小的短信息，在发送图片序列，保证图片发送的完整性： __FACE__River__DIV___255350__END___ def sendFace(filebytes): global conn, K, IV, nickname try: # 先发用户名和图片大小 conn.sendall(MyCrypto.encrypt(FACE + nickname + DIV + str(len(filebytes)) + END, K, IV)) conn.sendall(filebytes) return True except Exception as err: print(f'[sendFace ERROR] {err}') return False 服务端接收到图片后，先保存到服务端本地的文件夹中，并且给图片赋予uuid生成的随机图片名，然后按照群发消息一样的套路，更新全局的face_buf、face_num。face_buf中存储的为待群发的图片，face_num表示服务端总共收到的图片数量。然后由sender检测并依次发送图片： with face_lock: while self.__next_face &lt; face_num: temp = face_buf[self.__next_face] face_name = temp.split(DIV, 1)[1] with open('./face_buf/' + face_name + '.jpg', 'rb') as f: filebytes = f.read() self.__send_UTF8(FACE + temp + DIV + str(len(filebytes)) + END) self.__conn.sendall(filebytes) self.__next_face += 1 图片发送到客户端也是一样的形式，即先发送短信息再发送图片。客户端收到群发而来的图片字节序列后，将其转为base64编码然后通过html渲染到界面上： while(bytes_received &lt; bytes_total): # 按照长度接收图片 data = conn.recv(bytes_total - bytes_received) bytes_received += len(data) facebytes += data s = base64.b64encode(facebytes).decode() with face_lock: face_buf.append(user_name + DIV + s) face_num += 1 转换成base64后，就直接将图片作为html代码用渲染消息一样的方式渲染到每一个客户端的界面上即可。 &lt;img src=&quot;data:image/jpeg;base64, .....base64序列.....&quot; width=&quot;200&quot; alt=&quot;图像加载失败...&quot;&gt; 上述这种直接渲染图片的方法无需将图片缓存到客户端，是一种比较常见、便捷的图片渲染方法。 5. 群主特权与轮转制 效果展示 第一个进入群聊的人会获得群主资格： 群主具有踢人权限： 群主退出后，将由下一个最早进入的人继承群主权限： 实现方法 # sender ....... if groupLeader is None: with logIO_lock: groupLeader = self.__getFirstMember() if self.__nickname == groupLeader and self.become_leader is False: self.__send_UTF8(GRANT + END) self.become_leader = True ....... 上述代码为服务端sender线程主循环中的一部分代码。该代码探测当前是否有群主，若没有，则通过logIO_buf找到第一个进入聊天室且还没有退出的人，将它任命为groupLeader，然后将任免信息单发给被任命的客户端： __GRANT___END___ 客户端的receiver线程收到任免信息后，将全局变量getLeaderPower设为True： elif mark == GRANT: global getLeaderPower getLeaderPower = True 这个为True的getLeaderPower将使能界面上的踢人功能。 群主在踢人窗口中输入要踢的用户的名字，然后发送踢人请求给客户端： __KICK__Bob__END___ 服务端收到KICK请求后，执行以下代码： elif mark == KICK: # 强制退出 with logIO_lock: if not self.__isInUserList(text): # 若踢的人不在列表中，则什么事都不会发生 return logIO_buf.append('-' + text) logIO_num += 1 with kick_lock: kick_buf.append(text) self.__debugInfo('User- -&gt; ' + text) 上述代码首先创建被踢人的Logout信息加入logio_buf中，用于群发出去，告诉所有用户这个人退出了；然后将被踢人的名字加入全局的kick_buf中。 with kick_lock: if self.__nickname in kick_buf: kick_buf.remove(self.__nickname) self.__send_UTF8(KICK + END) return 服务端的sender然后不断扫描kick_buf，当发现它所服务的客户是被踢的对象之一时，则发送KICK给客户端用户强制关闭客户端；同时自己使用return来结束线程。当sender结束后，receiver也会随即探测到并结束，然后关闭连接，从而干净退出。群主其实还可以自己踢自己。 注意到这里的KICK信号虽然为单发信号，但还是维护了一个全局的kick_buf来实现。实际上通过局部变量也是可以实现的。这里只是两种方法二选一而已。 __KICK____END___ 客户端收到上述的被踢指令，按照老办法，通过全局变量让refresher探测到，refresher探测到后，通过qApp.quit()强制退出。 if isKicked is True: QMessageBox.critical(self, 'Announce', f'You have been kicked out by the Group Leader.') qApp.quit() 6. 文件传输 效果展示 上传： 上传后其他人可以找到并下载那个文件： 实现方法 def upLoad(self): filename, _ = QFileDialog.getOpenFileName(self, &quot;选取文件&quot;, self.__cwd, # 起始路径 &quot;All Files (*);;Text Files (*.txt)&quot;) # 设置文件扩展名过滤,用双分号间隔 if filename == &quot;&quot;: print(&quot;取消选择&quot;) return with open(filename, 'rb') as f: # 将文件打开，读取字节流 filebytes = f.read() if sendFile(os.path.basename(filename), filebytes): # 忽略等待 QMessageBox.information(self, 'Success', f'Upload successfully.') else: QMessageBox.critical(self, 'error', f'Upload fail.') 用户选择完要上传的文件后，客户端即能获取到要上传的文件路径。从文件路径中获取文件名filename，然后以'rb'模式打开文件获取文件字节流filebytes。 将文件名和文件长度先发送到服务端，服务端接收后就进入接收文件状态。 __UPL___filename__DIV___bytes_total__END___ filebytes = b'' bytes_received = 0 while(bytes_received &lt; bytes_total): # 按照长度接收文件 data = self.__conn.recv(bytes_total - bytes_received) bytes_received += len(data) filebytes += data 接收文件时采用上述结构，逐段接收直至接收总长达到文件长度，从而保证接收的完整性。前面的图片发送具体实现也是如此。 服务端接收到上述文件后，根据文件名将文件保存在服务端本地的files_buf文件夹中，然后在全局的filename_buf中增添新上传的文件名。 with open('./files_buf/' + filename, 'wb') as f: f.write(filebytes) with file_lock: filename_buf.append(filename) filename_num += 1 然后服务端sender根据全局的filename_buf、filename_num，利用相同的套路，将新上传的文件信息群发给所有用户。用户接收到新文件信息后也是用相同的套路储存在客户端本地全局缓冲池filename_buf中，之后refresher探测到新增的文件名，将其显示在下载界面上的可下拉选择器中供用户选择。 至此，服务端已经存储了上传的文件，所有客户端也获得了最新的已上传文件名列表。所以客户端就可以根据文件名列表选择想要的文件发送下载请求了： __DOWNL_filenameChosen__END___ 服务端receiver线程接收到上述请求后，首先分离出文件名，将其加入到局部列表变量self.require_files中。然后当sender线程探测到该局部变量列表不为空时，会逐个根据列表中的文件名将对应的文件从files_buf文件夹中打开，读取其字节流，然后以上传时同样的形式（先发长度后发文件）单发给请求的客户端。 客户端接收到上述文件后，结合之前选择的下载路径download_dir，将文件保存到本地即可。 四、细节处理 1. 保证接收消息的完整性和独立性 在进行代码调试的过程中，发现了socket API在接收过程中会出现以下两种情形：分段传输接收和合并接收 针对分段接收 分段传输主要出现在传输很长的字符序列的情形，比如传输文件的情形。 在接收函数conn.recv(n)中，n表示每次接收的最大字节数量。由于我们不可能将n设得无限大，因此当传输大文件时总会出现一次接收不完的情形。这是就需要通过循环接收的方式，将每次接收的片段累加起来，直到收到序列的结束标志END 针对合并接收 当两个短的传输序列在很接近的时刻到达时，conn.recv(n)会将它们合并接收为一个字符串。 这种情况将导致合并信息中的后一条会被当做前一条的内容，从而产生信息错误和信息遗失。针对这个问题，我们在每次接收到字符序列时，需要遍历找出所有的结束标志END，从而从每一次的接收序列中分离处所有的独立传输信息。 代码实现 def recv_proc(self): '''【接收工作线程】 接收服务端群发的更新数据，以此更新本地数据 ''' # 首先进行密钥交换 self.__recv_key() END_bytes = bytes(END, encoding='utf-8') recvBytes = b'' while True: recvBytes += recv_bytes() try: index = recvBytes.find(END_bytes) if index == -1: # 针对不完整情况 continue while index != -1: # 针对合并情况 self.update_buf(recvBytes[:index]) recvBytes = recvBytes[index + mark_len:] index = recvBytes.find(END_bytes) recvBytes = b'' except Exception as err: print(f'[update_buf ERROR] {err}') 上面为客户端receiver线程的函数实现，服务端的receiver类似。 当一次接收的序列recvBytes找不到结束标志END时，我们则通过continue等待下一次的接收序列，然后进行累加，直到找到结束标志为止。至此收到的序列至少包含一个独立的传输信息。 将上述序列通过循环不断搜索END标志然后切割分段，分出来的每一个段都是一个独立的传输信息。之后将每条独立信息输入self.update_buf()函数中进行相应的全局变量更新即可。 2. 用户允许中途加入 由于用户加入群聊有先后之分，之前加入的人可能会先进行聊天对话，而后加入的人就看不到前面的人的对话，于是就引入了之前提到的历史记录功能，供后加入的用户浏览前面用户的聊天内容；同样，后加入的人需要获取当前聊天室都已经有哪些人存在以及之前都传输了哪些文件。因此，在一个用户login时，服务端会对该用户单发之前的历史记录、当前的用户列表以及上传文件名列表。这样一来用户登录时就能接收到这些信息，然后更新历史记录框、用户列表和文件列表。 __INIT__userlist__DIV___filelist__END___ 这条信息传输的是当前用户列表和文件名列表 __HIS___msglist__END___ 这条信息传输的是历史记录 理论上这三个列表是可以一起传输的，但考虑到历史记录可能较多，因此将其分开来传输处理了。 3. 重名处理 处理重名问题理论上有两种办法：一是在用户登录时输入用户名时，就进行检测；二是在用户登录后已经进入聊天室后，对重名进行强制更改，然后告知用户。 考虑到检测用户名必须在连接建立之后才能实现，而在用户名输入界面就进行连接是不划算的（因为可能会反复登录退出），因此本项目中用的是第二种方法。 if name in user_list: self.__nickname = self.name_change = name + '#' return name + '#' # 若有重复用户名，则当前要增加的用户名变为 ...# self.__nickname = name # 记录本连接的用户名 服务端是按照上述代码来处理重名的，即简单的在新加入的重复用户名后加'#'。例如第一个进入的用户名为River，则之后以River命名的用户将会被重新赋予River#、River##....的新昵称。赋予新名称后，服务端会单发提示信息给相应的客户： __NAME__newname__END___ 客户端收到上述提示后就会弹出提示框告知用户。考虑到这是一个简易的灵活式聊天室，这样的设计是合理的。 4. 群聊结束后清空缓存 当所有人都退出聊天室后，说明本次聊天已经全部结束，此时将服务端的所有消息记录、用户记录、文件缓存、表情包缓存全部清空是更加合理的，因为下一个连接的用户应该被认为是发起了一个全新的群聊。 前面讲快速退出功能时已经提到过，服务端是通过获取剩余的线程数来判断本次群聊是否已经结束。当判断出群聊结束后，就开始执行清空缓存的函数： def __cleanBuf(self): '''清空缓存池 ''' global msg_buf, logIO_buf, roll_buf, kick_buf, filename_buf global groupLeader, msg_num, logIO_num, roll_num, filename_num shutil.rmtree('./files_buf') os.mkdir('./files_buf') shutil.rmtree('./face_buf') os.mkdir('./face_buf') msg_buf = [] logIO_buf = [] roll_buf = [] kick_buf = [] filename_buf = [] groupLeader = None msg_num = 0 logIO_num = 0 roll_num = 0 filename_num = 0 print('NOTE: Clean ALL bufs done.') 清空操作非常简单，即清空所有的全局缓存变量以及服务端本地的文件缓存文件夹、表情包缓存文件夹即可。 5. 利用html进行消息框渲染 这可以说是我自认为的本项目中最得意的亮点了。单纯用PyQt5是难以实现消息框中聊天气泡效果的，因此需要借助静态html和css渲染来实现。而静态的html如何实现动态的聊天消息变化呢？在本项目中，这是通过在每个客户端中维护一个全局的html长代码串，当收到新消息或需要撤回旧消息时，就相应地更改这个html代码串，然后将更新完后的html重新加载到界面上即可。 五、项目总结 这是一个简易但又包含众多实用功能的聊天室，是通过严密的传输规定和接收逻辑来实现的，轻量而高效。由于代码的逻辑性较强，群发传输和单发传输存在着一定的固定方法，因此代码的维护和功能的增加都较为方便。若有时间，我将会继续为其加入其它实用的功能，如私聊等。 * * * FinFin Fin Github源码 ","link":"https://river861.github.io/post/wetalk-jian-yi-liao-tian-shi/"}]}