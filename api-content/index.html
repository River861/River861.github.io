{"posts":[{"title":"[图论] 最大匹配问题归纳","content":"包括匈牙利算法和Hopcroft_karp算法。 一、定义 即在一个二分图中，找到最大的匹配对数。每个点只能最多和另外一个点配对。 二、情景 为了方便理解，这里考虑一下最大匹配场景： 有一列男生1..n，还有一列女生女生n + 1..n + m。即结点分开存； 愿意配对的男女会有边相连； 要求出男女配对的最大匹配数目。 三、解析 有两种方法可以解决最大匹配问题：匈牙利算法、Hopcroft_karp算法。 匈牙利算法 时间复杂度O(VE) 优点是代码简单，不超时时优先使用 Hopcroft_karp算法 时间复杂度O(sqrt(V)*E) 优先时更快，缺点是代码复杂，类似最大流 其实该算法就是将匈牙利算法中的find部分通过bfs分段，一点点来找匹配而已。 四、匈牙利算法 模板 bool find(int u){ for(int v : G[u]){ if(vis[v]) continue; vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int maxMatch(){ int res = 0; for(int i = 1; i &lt;= n; i ++){ // 男生逐个去邀请追女生 memset(vis, 0, sizeof(vis)); // vis用于标记对象点是否判断过, 每次都要清零 if(find(i)) res ++; // 找到一个心仪的女生了 } return res; } 五、Hopcroft_karp算法 模板 /* 类似最大流算法 数组解释： dist[i]: 层数标记 belong[i]: i 的对象 */ bool bfs(){ queue&lt;int&gt; queue; memset(dist, -1, sizeof(dist)); fin_dist = INF; // dist为当前终点的层数标记 for(int u = 1; u &lt;= n; u ++) if(!belong[u]) que.push(u), dist[u] = 0; // 若干起点 while(!que.empty()){ int u = que.front(); que.pop(); if(dist[u] &gt; fin_dist) break; // 到增广路终点层数的点都标记好了就跳出, 后面不再标记 for(int v : G[u]){ if(dist[v] == -1){ // 未被标记 dist[v] = dist[u] + 1; if(!belong[v]) fin_dist = dist[v]; // 找到增广路, 确定增广路终点层数 else dist[belong[v]] = dist[v] + 1, que.push(belong[v]); // 继续bfs } } } return dist != INF; } bool find(int u){ if(dist[u] &gt; fin_dist) return 0； for(int v : G[u]){ if(vis[v] || dist[v] != dist[u] + 1) continue; // 询问过 || 不是上下层关系 则跳过 vis[v] = 1; if(belong[v] == 0 || find(belong[v])){ // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 belong[v] = u, belong[u] = v; return 1; } } return 0; } int Hopcroft_karp(){ int res = 0; while(bfs()){ // 搜索有无增广路 memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i ++) if(!belong[i] &amp;&amp; find(i)) res ++; // 若没有女朋友 &amp;&amp; 能找到 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-da-pi-pei-wen-ti-gui-na/"},{"title":"[图论][经典] 常见的图论方法归纳","content":"比如dfs、bfs、并查集、链式前向星、判断二分图等。 一、dfs 1. 定义 dfs，即深度优先搜索。顾名思义，即尽可能递归到达最深处，然后再回溯，以此类推，直到遍历完整个图。 2. 解析 通过递归实现。 主要用于解决找迷宫路径等问题。 dfs代码比bfs简单。 要领： 用vis数组维护是否走过，记得清零； dfs中continue的条件分三类：出界、已走过、不是所求。不要遗漏了。 3. 模板 const int Fx[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}; // 方向 string a[maxn]; // 记录地图 bool vis[maxn][maxm]; // vis数组记录是否走过 void dfs(int x, int y) { vis[x][y] = 1; for(int k = 0; k &lt; 8; k ++) { int nx = x + Fx[k][0], ny = y + Fx[k][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '*') continue; // 出界、已走过、不是所求 dfs(nx, ny); // 递归 } } 4. 例题 Uva 572 * * * 二、bfs 1. 定义 bfs，即广度优先搜索。顾名思义，即先走完这一层，再走下一层，以此类推，直到遍历完整个图。 2. 解析 通过队列实现。 主要用于解决简单（权值为1）的最短路问题。 要领： bfs问题要先想清楚**“状态点”如何定义，然后维护相应维度的vis、a数组（地图）。 如果需要打印路径需要用p数组**进行父节点的存储。 debug时不要太着急，可以将打印信息写的详细一点，这样才能有利于更快地发现问题！ 注意区分Dijkstra模板：bfs用的是普通队列，vis数组的更新位置在push后。 3. 变式 双向bfs 先通过逆向bfs求出距离d[maxn]，然后再进行正向的“bfs”，这样就能实现一些比较复杂的最短路径问题。 复杂状态的表示 有时后一些状态点具有很多维度（比如八数码），或取值范围很大（超过1e8），这时没有办法通过vis数组来存储，因为会爆空间。 这时可以考虑这些方法来保存vis状态：set、哈希法（推荐）、康托展开。 4. 模板 const int Fx[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; // 方向 struct node { // 队列中的结点 int x, y, dist; node(int x, int y, int dist) : x(x), y(y), dist(dist) {} }; int a[maxn][maxm], vis[maxn][maxm], ans; void bfs(int x0, int y0) { queue&lt;node&gt; que; que.push(node(x0, y0, 0)), vis[x0][y0] = 1; // 入队后紧接着更新vis while(!que.empty()) { node u = que.front(); que.pop(); if(u.x == n - 1 &amp;&amp; u.y == m - 1) { // 退出条件（可选） ans = u.dist; break; } for(int i = 0; i &lt; 4; i ++) { int nx = u.x + Fx[i][0], ny = u.y + Fx[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '#') continue; que.push(node(nx, ny, u.dist + 1)), vis[nx][ny] = 1; // 入队后紧接着更新vis } } } 5. 例题 Uva 1600 Uva 1599 Uva 10085 Uva 816 * * * 三、并查集 1. 定义 将若干点进行加边联通，每个连通块形成一个代表元Fa[i]（i为连通块中的任意一点）。 2. 解析 并查集通常用于解决与连通相关的图论问题。 优化方法有：路径压缩、启发式连接。一般为了方便，只是用路径压缩就足够了。 3. 变式 在一些比较复杂的题目中，除了要维护父子关系，要需要维护其它的关系，这个时候需要 使用额外的辅助数组。 4. 模板 普通并查集 int n, Fa[maxn]; // 并查集要使用的Fa数组 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); // 路径压缩 } int main() { ...... for(int i = 1; i &lt;= n; i ++) Fa[i] = i; // Fa初始化 ...... for(const auto&amp; e : E) { // 逐条加边 int u = find(e.u), v = find(e.v); if(u == v) continue; // 若连通 Fa[u] = v; // 若不连通则将其连通 ...... } ..... } 复杂并查集 int Fa[maxn], dist[maxn]; // 辅助数组：到father的距离（非路径压缩的距离） int find(int x) { if(Fa[x] == x) return x; int fx = Fa[x]; Fa[x] = find(fx); dist[x] += dist[fx]; // 在回溯过程中更新，需要用到原father即fx return Fa[x]; } 5. 例题 最小生成树专题 * * * 四、链式前向星 1. 定义 一种比vector快且省空间的存图方法。 2. 解析 链式向前星 就是一种用一个链表来存放每个结点的所有出边的结构，新的边从链表头插入，用于加快读图。 链表头数组：head[maxn]，head[u]指向一条包含了u的所有邻接边的链表 存所有边：E[maxm] 边序号：cnt 3. 模板 struct edge { int to, w, next; edge() {} edge(int to, int w, int next) : to(to), w(w), next(next) {} } E[maxm]; // 用链式向前星来存图 int cnt, head[maxn]; // head[u]指向一条包含了u的所有邻接边的链表 void addEdge(int u, int v, int w) { E[cnt] = edge(v, w, head[u]); // 从链表的头部插入 head[u] = cnt ++; // 更改头指针 } int main() { ...... fill(head, head + n + 1, -1); // 初始化链表头，-1表示链表尾部 cnt = 1; // cnt表示当前加入的边序号 while(m --) { ...... addEdge(u, v, w); ...... } ...... for(int i = head[u]; ~i; i = E[i].next) { // 遍历u的所有出边的方法 int v = E[i].to, w = E[i].w; ...... } } 4. 例题 Poj 3159 * * * 五、判断二分图 1. 定义 判断一个图是否为二分图。 2. 解析 通过 染色法 实现。 用 1 和 -1 两种颜色给图的点染色，用col[maxn]来存放点的颜色, 0 表示还没染色。 若无法相间染色，则不是二分图，否则是。 3. 模板 bool dye(int u, int color){ col[u] = color; // 先染色 for(int v : G[u]){ if(!col[v] &amp;&amp; !dye(v, -color)) return 0; // 下一个点没染色 就染上不同色，染不上则失败 else if(col[v] == color) return 0; // 若下一个点染了色且和当前点颜色相同， 则必不是二分图 } return 1; } int main() { ...... bool ok = 1; // 是否是二分图 for(int i = 1; ok &amp;&amp; i &lt;= n; i ++) { if(!col[i] &amp;&amp; !dye(i, 1)) ok = 0; } ...... } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-jing-dian-chang-jian-de-tu-lun-fang-fa-gui-na/"},{"title":"[图论] 复杂的图论问题归纳","content":"比如LCA问题、最大流问题等。 一、求最近公共祖先结点（LCA） 1. 定义 LCA（Lowest Common Ancestors），即最近公共祖先，是指在有根树中找出某两个结点u和v最近的公共祖先结点。 2. 解析 这里只说一种我个人比较喜欢的在线算法：欧拉序 + RMQ 时间复杂度：预处理 O(n+nlgn)，查询只需要O(1) 原理： 欧拉序 就是在dfs遍历一棵树时经过的结点序列（包括回溯时经过的结点），显然两个结点u、v的最近公共祖先就是 欧拉序中 区间[u, v] 中深度最小的结点。（其中u、v指的是u、v在欧拉序中的第一次出现，即递归过程中的记录） 因此我们只需要通过一遍dfs得到欧拉序euler[2 * maxn]、对应的结点深度dep[2 * maxn]，以及每个结点在欧拉序中的位置 pos[maxn]，就可以通过RMQ在O(1)实现内找到欧拉序中 区间[pos[u], pos[v]] 中深度最小的结点位置。 需要维护的结构： euler[2 * maxn]：欧拉序 dep[2 * maxn]：欧拉序中结点对应的深度 pos[maxn]：每个结点在欧拉序中第一次出现的位置（对应于进入递归的时候） cnt：欧拉序长度 dp[2 * maxn][log_2maxn = 25]：对欧拉序根据dep进行RMQ预处理，dp[i][j]表示区间[i，i+2^j)中深度最小的 结点下标 为了防止混乱，规定RMQ存储、询问的是区间中深度最浅的 结点下标值，并且也是通过 结点下标区间 进行询问。之后只需要利用euler数组即可映射到对应的点。另外，区间表示为 左闭右开。 3. 模板 int n, m, s; vector&lt;int&gt; G[maxn]; int cnt, euler[2 * maxn], dep[2 * maxn], pos[maxn]; int dp[2 * maxn][log_2maxn]; void dfs(int u, int fa, int d) { pos[u] = cnt, euler[cnt] = u, dep[cnt] = d, cnt ++; for(int v : G[u]) if(v != fa) { dfs(v, u, d + 1); euler[cnt] = u, dep[cnt] = d, cnt ++; } } void init_RMQ() { for(int i = 0; i &lt; cnt; i ++) dp[i][0] = i; // 最短的区间 for(int j = 1; (1 &lt;&lt; j) &lt;= cnt; j ++) { // 注意先计算小区间，所以先从小到大遍历j for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; cnt; i ++) { int idx1 = dp[i][j - 1], idx2 = dp[i + (1 &lt;&lt; (j-1))][j - 1]; dp[i][j] = (dep[idx1] &lt; dep[idx2] ? idx1 : idx2); // RMQ中存放的是深度最小结点的下标值 } } } int min_RMQ(int l, int r) { int k = log2(r - l); int idx1 = dp[l][k], idx2 = dp[r - (1 &lt;&lt; k)][k]; return dep[idx1] &lt; dep[idx2] ? idx1 : idx2; } int main() { ...... dfs(s, -1, 0); // 求欧拉序euler、dep、pos init_RMQ(); // RMQ预处理 while(m --) { ...... if(pos[u] &gt; pos[v]) swap(u, v); // 询问u、v两个点的LCA，注意要保持欧拉序中u在v前面 cout &lt;&lt; euler[min_RMQ(pos[u], pos[v] + 1)] &lt;&lt; endl; // min_RMQ的输入、输出都是下标值，区间表示为左闭右开 } } 4. 例题 Luogu P3379 * * * 二、最大流问题（Dinic算法） 1. 定义 设源点为1, 终点为N。用 G[u][v] 表示点u、v之间的容量大小，求这样一个网络图 G 中的最大流量大小ans。 2. 解析 Dinic算法 求最大流 用邻接矩阵G存图更方便 先进行bfs, 判断有无增广路的同时,标记每个点的层号 然后根据层号进行dfs, 找增广路, 更新流值, 可能有多条不相交的增广路 循环往复 3. 模板 bool bfs(){ memset(dist, -1, sizeof(dist)); // 每次重新标记dist, 因为增加了反向边, 图已经不同 dist[1] = 0; que.push(1); while(!que.empty()){ int u = que.front(); que.pop(); for(int v = 1; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == -1){ // 连接 &amp;&amp; 未被标记 的点 dist[v] = dist[u] + 1; que.push(v); } } if(dist[N] == -1) return 0; // 若无法增广到终点，则表示没有增广路了 return 1; } int find(int u, int low){ // low是源点到现在最窄的(剩余流量最小)的边的剩余流量 if(u == N) return low; // dfs出口 for(int v = 1, a; v &lt;= N; i ++){ if(G[u][v] &amp;&amp; dist[v] == dist[u] + 1 &amp;&amp; (a = find(v, min(low, G[u][v])))){ // 连接的 &amp;&amp; 是上下层关系的 &amp;&amp; 能连通到汇点 min维护low G[u][v] -= a; G[v][u] += a; // 增加反向边 起容错作用 return a; //只要发现一条增广路, 就返回增广的流量 } } return 0; } int main(){ //.... int ans = 0; while(bfs()){ // 利用bfs为每个点标记dis, 若标记不到汇点, 说明已经没有增广路 int temp; // 每次增广的流量 while(temp = find(1, INF)) ans += temp; // 根据dist进行dfs找增广路, 直到找不到为止 } cout &lt;&lt; ans &lt;&lt; endl; } * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-fu-za-de-tu-lun-wen-ti-gui-na/"},{"title":"[区间问题] 树状数组与线段树归纳","content":"用树状数组和线段树解决一些区间问题。 一、树状数组 1. 定义 用一个数组C[maxn]模拟树状结构，来表示原数组A[maxn]的区间信息。各操作的复杂度为O(lgn)。 2. 解析 lowbit(x) 指一个数x的二进制中，最靠右的1的权值大小。如lowbit(6)=2^1, lowbit(7)=2^0，lowbit(8)=8。 树状数组就是用一个C[maxn]数组来存放原数组A[maxn]的去区间信息。具体而言，C[x]存放了从A[(x-lowbit(x))...x]区间中各元素之和。 A[0]为0，不存放有效值。 [单点更新 区间查询] 求A[1...x]的区间和就需要求出它所对应的那几个C[j]区间之和，这几个区间通过lowbit向下枚举即可得出；而更改一个值A[i]时就需要更改所有包含了A[i]的C[j]区间，同样可以通过lowit线上枚举来获得。 3. 变式 [区间更新 单点查询] 树状数组中存放 差分值 D[i] = A[i] - A[i - 1]，这样区间更新只用更新区间两端，单点查值就是getSum。 [区间更新 区间查询] 维护两个数组 sum1[maxn]存放差值 D[1]、D[2]、D[3]... 的树状数组； sum2[maxn]存放 0 * D[1]、1 * D[2]、2 * D[3]... 的树状数组 更新操作要同时更新 sum1[maxn]、sum2[maxn] 查询区间的和为：n * ∑D[i] - ∑[(i - 1) * D[i]] = n * sum1[i] - sum2[i] 证明如下： A[1] + A[2] + ... + A[n] = (D[1]) + (D[1] + D[2]) + ... + (D[1] + D[2] + ... + D[n]) = n * D[1] + (n - 1) * D[2] + ... + D[n] = n * (D[1] + D[2] + ... + D[n]) - (0 * D[1] + 1 * D[2] + ... + (n - 1) * D[n]) 4. 模板 [单点更新 区间查询] int A[100010], C[100010]; // 原数组 和 树状数组 A[1...n]有效 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 当 A[k] += v时 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 求 A[1]+...+A[k]时 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } [区间更新 单点查询] int A[100010], C[100010]; int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 不变 for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; } int getSum(int k){ // 不变 int res = 0; for(int i = k; i; i -= lowbit(i)) res += C[i]; return res; } int main(){ ...... for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); // 在[x, y]区间加上k, 即让这个区间向上突出 add(y + 1, -k); ...... int ans = getSum(q); // 查询q位置的值 ...... } [区间更新 区间查询] int A[100010]; int sum1[100010]; // 存放了差值D[1]、D[2]、D[3]...的树状数组 int sum2[100010]; // 存放了0*D[1]、1*D[2]、2*D[3]...的树状数组 int lowbit(int x){ return x &amp; -x; } void add(int k, int v){ // 加差值和sum2的同时还要加sum2 for(int i = k; i &lt;= n; i += lowbit(i)) sum1[i] += v, sum2[i] += (k - 1) * v; } int getSum(int k){ // 区间和为 n*∑D[i] - ∑[(i-1)*D[i]] = n*sum1[i] - sum2[i] int res = 0; for(int i = k; i; i -= lowbit(i)) res += k * sum1[i] - sum2[i]; return res; } int main(){ for(int i = 1; i &lt;= n; i ++){ //从1开始放 cin &gt;&gt; A[i]; add(i, A[i] - A[i - 1]); // 树状数组放差值 } ...... add(x, k); //在[x, y]区间加上k add(y + 1, -k); ...... int ans = getSum(q) - getSum(p - 1); //查询[p, q]位置的值 } * * * 二、线段树 1. 定义 一种强大的能解决区间的修改、查询问题的方法。 2. 解析 与树状数组相比，线段树代码量更大，但是适用范围更广。 k为结点编号 根节点为1, 左孩子为 k2, 右孩子为 k2+1 每个函数都包含参数k 除建树外共4种情形：单点查询 单点更新 区间查询 区间更新(要用到懒标记f) 一个题目一般只会用到两种 线段树一般保持 左闭右闭 区间，这样代码会好写一点 注意： 无论是更新还是查询，都要down懒标记 一些线段树的变形主要需要特别注意 状态归并 和 懒标记的更新 3. 模板 #include &lt;iostream&gt; using namespace std; using ll = long long; const int maxn = 5e5 + 5; struct node { int l, r, f = 0; ll w; node() {} node(int l, int r, ll w) : l(l), r(r), w(w) {} } Tree[4 * maxn]; int n, m; ll a[maxn]; void down(int k) { int &amp; v = Tree[k].f; Tree[k * 2].w += v * (Tree[k * 2].r - Tree[k * 2].l + 1); Tree[k * 2].f += v; Tree[k * 2 + 1].w += v * (Tree[k * 2 + 1].r - Tree[k * 2 + 1].l + 1); Tree[k * 2 + 1].f += v; v = 0; } void build(int l, int r, int k) { // 建树 if(l == r) { Tree[k] = node(l, r, a[l]); return; } int mid = (l + r) / 2; build(l, mid, k * 2); build(mid + 1, r, k * 2 + 1); Tree[k] = node(l, r, Tree[k * 2].w + Tree[k * 2 + 1].w); } void update(int x, int v, int k) { // 单点更新 if(Tree[k].l == Tree[k].r) { Tree[k].w += v; return; } int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) update(x, v, k * 2); else update(x, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int l, int r, int k) { // 区间查值 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; ll res = 0; if(l &lt;= mid) res += query(l, r, k * 2); if(r &gt; mid) res += query(l, r, k * 2 + 1); return res; } void update(int l, int r, int v, int k) { // 区间更新 if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) { Tree[k].w += v * (Tree[k].r - Tree[k].l + 1); // 注意是多个值更新 Tree[k].f += v; // 懒标记： 预记儿子们的变化 return; } if(Tree[k].f) down(k); // 懒标记下传 int mid = (Tree[k].l + Tree[k].r) / 2; if(l &lt;= mid) update(l, r, v, k * 2); if(r &gt; mid) update(l, r, v, k * 2 + 1); Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w; } ll query(int x, int k) { // 单点查值 if(Tree[k].l == Tree[k].r) return Tree[k].w; if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！ int mid = (Tree[k].l + Tree[k].r) / 2; if(x &lt;= mid) return query(x, k * 2); else return query(x, k * 2 + 1); } int main() { ios::sync_with_stdio(0), cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, n, 1); while(m --) { int f, x, y, k; // 单点更新 + 区间查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y, update(x, y, 1); // else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; // 区间更新 + 单点查值 // cin &gt;&gt; f; // if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); // else cin &gt;&gt; x, cout &lt;&lt; query(x, 1) &lt;&lt; endl; // 区间更新 + 区间查值 cin &gt;&gt; f; if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1); else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl; } } * * * FinFin Fin ","link":"https://river861.github.io/post/qu-jian-wen-ti-shu-zhuang-shu-zu-yu-xian-duan-shu-gui-na/"},{"title":"[动态规划][经典] 常见的动态规划问题归纳","content":"比如LIS问题 一、最长上升子序列（LIS） 1. 定义 给出一个序列a[1...n]，要求你求出其中最长的递增子序列的长度。 2. 简单的 O(n2)O(n^2)O(n2) 算法 原理： 设 dp[i] 为把下标i作为最长上升子序列结尾位置 的最大长度，则 dp[i] = max(dp[1..i]+1)，所有dp[i]初始为1. 模板： int n, num[maxn], dp[maxn]; // num[maxn]存放了序列，dp[i]表示以a[i]为结尾的最长子序列长度 int main() { ...... int ans = 0; for(int i = 1; i &lt;= n; i ++) { dp[i] = 1; for(int j = 1; j &lt; i; j ++) { if(num[i] &gt;= num[j]) dp[i] = max(dp[i], dp[j] + 1); } ans = max(ans, dp[i]); } cout &lt;&lt; ans &lt;&lt; endl; } 3. 最快的 O(nlgn) 算法 原理： 以非严格递增子序列为例，主要思想是 贪心 + 二分。这种方法不需要dp数组，取而代之，使用的是一个low数组。 维护一个 low数组 和 ans low[i]表示到当前为止，长度为i的LIS结尾元素的最小值；ans为 当前最长LIS长度 对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长，因此该算法贪心地维护出每个长度最小的结尾元素，存放在low[i]中 维护方法 对于每一个a[i]，如果a[i] &gt; low[ans]，就把 a[i]接到当前最长的LIS后面，即 low[++ ans] = a[i]；否则， 用 a[i] 更新 low数组 中第一个大于 a[i] 的元素 low[j] = a[i] 举个例子 比如1 5 6 3 4，假设当前已经遍历到下标3，则low[] = {1, 5, 6}，下一个数字3将会把5更新为3，表示到目前为止（1 5 6 3），长度为2的结尾最小的上升子序列为 1 3 。更新后下一个4才会有可能成为长度为3的上升子序列的末尾（1 3 4），这就是贪心起到的作用（总是维护最小的结尾值）。 模板： int nums[maxn], low[maxn]; // num[maxn]存放了序列，low[i]表示长度为i的LIS结尾元素的最小值 // 贪心 + 二分 解法 O(nlogn) int main(){ fill(low + 1, low + n + 1, INF); int ans = 0; // low和ans搭配使用，ans就是当前维护到的最长长度 for(int i = 1; i &lt;= n; i ++){ if(ans == 0 || num[i] &gt;= low[ans]) low[++ ans] = nums[i]; // 若为严格递增，改为 &gt; else{ int j = upper_bound(low + 1, low + n + 1, nums[i]) - low; // 若为严格递增，改为 lower_bound low[j] = nums[i]; } } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Nowcoder 旅行青蛙 * * * FinFin Fin LIS-参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-jing-dian-chang-jian-de-dong-tai-gui-hua-wen-ti-gui-na/"},{"title":"[动态规划] 数位dp方法归纳","content":"数位dp问题其实就是模板题。 一、定义 求出在给定区间 [A,B] 内，符合条件 f(i) 的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关。由于数是按位dp，数的大小对复杂度的影响很小。 简单来说，就是解决一些与区间中的数字的计数问题，计数条件一般与数的组成有关。 二、状态量 一般采用记忆化搜索的方式来实现dp，dp的状态经常包括pos、pre、cnt、lead、limit这几项： pos：当前处理的是数位的第几项，一般从高往低走 pre：当前位的前几位的状态，由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定） cnt：随着pos的前进需要维护的一些答案值/计数值 lead：当前位是否位前导0位 limit：当前位的最大值是否存在限制 三、记忆化搜索 把dfs的答案值存放在dp[pos][pre][cnt][...]数组中，以避免重复计算。 原理：从pos开始的低位dp答案会在高位值的枚举遍历中被反复调用。若从某个pos开始的dp它的前置状态pre和之前的某一次处理完全一样，则无需再重复计算，直接返回之前的答案值即可。因为所拥有的条件和上一次完全一样。 注意：当当前位为前导0或当前位受到限制时，没有必要将该值记录到dp数组。因为这些状态并不会被重复使用。 四、模板 以下模板大多数情况可套用，但部分细节还是需要结合具体题意进行考虑。 ll a[20], dp[20][20]; // a是用来装数位最高值的数组，dp是memo数组 ll dfs(ll pos, ll pre, ll cnt, bool lead, bool limit) { if(pos == 0) return cnt; // 已经遍历完一个数的情形 if(!lead &amp;&amp; !limit &amp;&amp; dp[pos][pre][...] != -1) return dp[pos][pre][...]; // 记忆化搜索 ll res = 0, maxv = limit ? a[pos] : 9; // 计算当前位最大值 for(ll i = 0; i &lt;= maxv; i ++) { // 若当前位是前导0 if(i == 0 &amp;&amp; lead) res += dfs(pos - 1, ...., 1, limit &amp;&amp; i == maxv); // 若当前位是最高位 else if(i &amp;&amp; lead) res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); // 正常情况 else res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv); } if(!lead &amp;&amp; !limit) dp[pos][cnt] = res; return res; // 注意区分res和cnt，res是问题的答案，cnt是当前状态维护的小答案，res由最终的cnt累加而成 } ll cal(ll num) { ll pos = 0; while(num) a[++ pos] = num % 10, num /= 10; // 把数按位拆分（数位dp的前提） memset(dp, -1, sizeof(dp)); // memo数组初始化为-1 return dfs(pos, 0, 1, 1); // 从高位往低位dp } int main() { ...... // 注意！！！l为0时一般要特别处理，因为数位dp的过程会将0一直当作前导0从而忽略了数值0这一个数，不过由于是计算差值所以大部分情况不影响 cout &lt;&lt; cal(r, i) - cal(l - 1, i); // 将区间计算转化为差值计算 ...... } 五、例题 Nowcoder 17867 ZJOI 2010 数位dp就是模板题！！！ * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-shu-wei-dp-fang-fa-gui-na/"},{"title":"[数学][经典] 常见的数学方法归纳","content":"一些数学算法题中常用的技巧，包括gcd、exgcd、快速幂、逆元、组合数等。 基本说明 由于数学类方法经常性混合使用（比如组合数+快速幂），因此例题在最后统一给出。 * * * 一、最大公约数和最小公倍数（gcd） 1. 定义 没啥好说，大家都懂。最大公约数 gcd(a,b) ，最小公倍数 lcm(a,b) 。 2. 解析 求最大公约一般用辗转相除法，最小公倍数可以由最大公约数导出： gcd(a,b)⋅lcm(a,b)=a⋅bgcd(a, b) \\cdot lcm(a, b) = a \\cdot b gcd(a,b)⋅lcm(a,b)=a⋅b 同时注意为了防止a*b溢出，最终我们最小公倍数用下述公式求解： lcm(a,b)=a/gcd(a,b)⋅blcm(a, b) = a / gcd(a, b) \\cdot b lcm(a,b)=a/gcd(a,b)⋅b 3. 模板 ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } * * * 二、扩展欧几里得算法（exgcd） 1. 定义 上面说的求最大公约数的方式实际上叫欧几里得算法，而这里要讲的是它的升级版，不仅可以计算出前面说的最小公约数，还可以求出相应的“不定方程解”. 2. 解析 exgcd可以快速求出下面方程中的x、y、gcd(a,b)： ax+by=gcd(a,b)ax + by = gcd(a, b) ax+by=gcd(a,b) 上面的公式为裴蜀定理，有很多有用的结论： 上述式子一定有整数解，通过exgcd可以求出其中一组整数解 若要求出其它解，只需要 x+=b/gcd(a,b)，y-=a/gcd(a,b) 即可 注意不要漏了除以 gcd(a, b) +、-可以互换，相当于从另一个方向找其它解 对于ax+by=c，若c不是gcd(a, b)的倍数，则该方程无解 ...... 3. 模板 注意 在求解 ax+by=c 时要特判 a、b等于0 的情况。 ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if(b == 0) { y = 0, x = 1; return a; } ll res = exgcd(b, a % b, y, x); y -= (a / b) * x; return res; } * * * 三、快速幂算法 1. 定义 一种用来快速求解指数很大的幂运算的算法。 2. 解析 原理是将幂次减半，底数平方，并以此类推直到幂次为0。比如310=95=(94)(91)=(812)(91)=(65611)(91)3^{10}=9^5=(9^4)(9^1)=(81^2)(9^1)=(6561^1)(9^1)310=95=(94)(91)=(812)(91)=(65611)(91)，这样原式的答案就是6561*9了。 3. 模板 普通版，注意用long long： LL fast_pow(LL a, LL b) { // 快速幂算法 LL res = 1; while(b) { if(b &amp; 1) res = res * a; // 指数为奇时分一个出来 b &gt;&gt;= 1; // 指数减半 a = a * a; // 底数平方 } return res; } 带mod版，注意用long long： LL fast_pow_mod(LL a, LL b) { // 快速幂算法 带mod版 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } * * * 四、除法求模（逆元） 1. 定义 我们都知道，对于加法、减法、乘法，求模运算都可以提前，即： (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p ) % p (a * b) % p = (a % p * b % p) % p 而除法求模不行，因此对于除法求模我们需要使用一种专门的方法，即转化为乘法求模。 2. 解析 由费马小定理： bm−1≡1(modm)b^{m - 1} \\equiv 1 (mod m) bm−1≡1(modm) 转化一下则有： 1b≡bm−2(modm)\\frac{1}{b} \\equiv b^{m-2} (mod m) b1​≡bm−2(modm) 也就是说，对于除以b取模可以转化为乘以b^(m-2)取模！ 这样就成功将除法取模转化为了乘法取模。但要注意b、m必须互质。好消息是，这里的m一般就是题目给出的mod值，一般题目给出的都是一个很大的质数。 因此我们一般称b^(m-2)为b的 逆元 ，除以b取模相当于乘以b的逆元取模。 而对于b^(m-2)的求法，参见前文的 快速幂算法 即可。 3. 模板 以求组合数的模为例，里面要用到除法（除数为阶乘）求模： int C(int n, int m) { // n! / (n-m)! / m! =&gt; n! * [(n-m)!]^(mod-2) * [m!]^(mod-2) return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * 四、指数求模 1. 定义 指数比较大的情况一般用快速幂可以解决，然而.... 有时用快速幂还是会超时....这个时候也需要将指数模一模. 2. 解析 由费马小定理： bm−1≡1 (mod m)b^{m-1} \\equiv 1\\ (mod\\ m) bm−1≡1 (mod m) 将k组上式乘到下面这个式子中 aB≡ans (mod m)a^{B} \\equiv ans\\ (mod\\ m) aB≡ans (mod m) 得到 aB+k(m−1)≡ans (mod m)a^{B+k(m-1)} \\equiv ans\\ (mod\\ m) aB+k(m−1)≡ans (mod m) 上面两个式子说明，可以对指数 模(m-1)，答案不会变化。 3. 结论 在计算指数运算时，要是指数太大，可以 模(m-1)，答案不会变化。m为题目指定的mod。 五、组合数（C(n, m)） 1. 定义 在一些题目中需要用到组合数，甚至通过组合数直接输出结果，因此有必要学习一下组合数的计算方式。 C(n,m)=n!(n−m)!m!C(n, m) = \\frac{n!}{(n - m)! m!} C(n,m)=(n−m)!m!n!​ 2. 解析 两种方法 方法一：通过动态规划预处理出C[maxn][maxn]数组，预处理用时O(n^2)，查询用时O(1) 一般只要预处理不会超时、空间不会爆 就优先用这个！！ C(n,m)=C(n−1,m−1)+C(n−1,m)C(n, m) = C(n - 1, m - 1) + C(n - 1, m) C(n,m)=C(n−1,m−1)+C(n−1,m) 方法二：仅预处理出阶乘数fac[maxn]和阶乘数的逆元inv_fac[maxn]，预处理时间O(n*lg(mod))，查询用时稍微慢一点的O(1) 若方法一预处理超时了 或 内存爆了 就用这个。 C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅modC(n, m) = fac[n]\\cdot inv\\_fac(n - m) \\cdot mod \\cdot inv\\_fac(m) \\cdot mod C(n,m)=fac[n]⋅inv_fac(n−m)⋅mod⋅inv_fac(m)⋅mod 3. 模板 方法一： void init(ll n) { C[0][0] = 1; for(ll i = 1; i &lt;= n; i ++) { for(ll j = 0; j &lt;= i; j ++) { C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } } 方法二： LL fast_pow_mod(LL a, LL b) { // 快速幂 LL res = 1; while(b) { if(b &amp; 1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return res % mod; } void init(int n) { // 预处理 fac[0] = inv_fac[0] = 1; for(int i = 1; i &lt;= n; i ++) { fac[i] = fac[i - 1] * i % mod; inv_fac[i] = fast_pow_mod(fac[i], mod - 2); } } int C(int n, int m) { // 计算组合数 return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod; } * * * Last. 例题 Nowcoder 数列统计 Nowcoder 子序列 Nowcoder 火柴排队 * * * FinFin Fin ","link":"https://river861.github.io/post/shu-xue-jing-dian-chang-jian-de-shu-xue-fang-fa-gui-na/"},{"title":"[图论] 最短路问题归纳","content":"包括Dijkstra算法、Spfa算法、Floyd算法以及它们的变形。 基本原则 首先看题目n的数量级，当 n&lt;1000 时，可以使用 [Floyd算法] 快速秒杀几乎所有题型 否则 若题目中所有边全为正权，则使用 [Dijkstra算法] 否则 当出现负权时，使用 [spfa算法] 注意一些隐蔽的最短路问题，比如题目会换一种问法。详见最短路的各种变形题。 * * * 一、正权单源最短路 —— Dijkstra算法 1. 定义 计算正权图上的单源最短路，即从单个源点出发到所有结点的最短路。包含无向图或有向图。 2. 解析 使用Dijkstra算法。时间复杂度O(mlgn)，一般够用。 3. 模板 struct node { // node结构是存放在优先队列中的结构 int u, d; node(int u, int d) : u(u), d(d) {} bool operator &lt; (const node&amp; rhs) const { return d &gt; rhs.d; // 由于默认为最大堆, 而我们希望最小的先出列 } }; struct edge { //edge结构仅用于存图 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, m, vis[maxn], d[maxn]; void Dij(int s) { fill(d, d + n + 1, INF), d[s] = 0; // 初始化d数组 fill(vis, vis + n + 1, 0); priority_queue&lt;node&gt; que; que.push(node(s, 0)); while(!que.empty()) { int u = que.top().u; que.pop(); if(vis[u]) continue; // vis就写在这两行，是为了忽略掉松弛前的结点（因为并没有从队列中删除，只是压入了d更小的状态而已）， vis[u] = 1; // 因此放在这里进行判断，这是和bfs不同的 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(node(e.to, d[e.to])); // 压入了松弛后的结点，然而并没有删除原结点，因此要依靠上面的vis } } } } int main() { ...... Dij(1); ...... } 注意Dijkstra的模板和bfs有点像，但是还是不一样的： 一个用优先队列，一个用普通队列 使用vis数组的原因不同 4. 例题 Poj 2397 Poj 1847 Poj 1502 * * * 二、带负权的单源最短路 —— spfa算法 1. 定义 计算带负权的图上的单源最短路，由于可能存在负环，因此Dijkstra算法不可用。 2. 解析 这时可以使用spfa算法。最坏时间复杂度O(nm)。 带负权的最短路径问题，可以使用Bellman-Ford或它的优化版本，即spfa算法。spafa算法能解决带负权的单源最短路问题，同时判断是否存在负环。最坏时间复杂度为O(nm)。比Dijkstra慢，因此对于正权的单源最短路我们使用Dijkstra，而对于带负权的就只能使用spfa算法了。 spfa算法的原理：先从Bellman-Ford算法的原理开始，Bellman-Ford算法通过将每条边松弛n-1次来求出每个点的最终d[maxn]，即松弛到不能再松弛了。而如果第n次还存在边可以继续松弛，说明存在负环。而spfa通过让已经松弛得不能再松弛的边不再入队来实现减少冗余的松弛操作，用队列来存储每一轮迭代后还需要继续松弛的边，就是这样一个优化。 spfa的模板与Dijkstra有点像，需要注意区分。 3. 模板 struct edge { // 用于存图的edge结构 int to, w; edge(int to, int w) : to(to), w(w) {} }; vector&lt;edge&gt; G[maxn]; int n, inq[maxn], cnt[maxn], d[maxn]; bool spfa(int s) { fill(d, d + n + 1, INF); d[s] = 0; fill(inq, inq + n + 1, 0); // inq用于标记每个点是否在队列中 fill(cnt, cnt + n + 1, 0); // cnt用于统计每个点的入队次数 queue&lt;int&gt; que; // 只需要使用普通队列 que.push(s), inq[s] = 1, ++ cnt[s]; while(!que.empty()) { int u = que.front(); que.pop(); inq[u] = 0; // 可以重复入队 for(const edge&amp; e : G[u]) { if(d[e.to] &gt; d[u] + e.w) { // 松弛操作 d[e.to] = d[u] + e.w; que.push(e.to), inq[e.to] = 1; if(++ cnt[e.to] &gt; n) return 1; // 入队超过n次说明有负环 } } } return 0; } int main() { ...... spfa(1); ...... } 要注意区分Dijkstra模板和spafa模板： Dijkstra使用优先队列，spfa使用普通队列 Dijkstra使用vis数组排出重复点；spfa使用inq记录是否在队列中，用cnt记录入队次数，允许重复入队 若原图不连通，需要加一个点使得原图连通后再用spfa算法来判断负环，否则会漏判。 4. 例题 Poj 3259 Poj 3169 LightOJ 1074 * * * 三、多源最短路 —— Floyd算法 1. 定义 求任意两点之间的最短路。包含无向图或有向图，正权图、负权图。 2. 解析 使用Floyd算法。时间复杂度O(n^3)。对于多源最短路问题只能使用Floyd算法，对于单源最短路问题，若n比较小，也可以使用Floyd算法来快速解决。因为代码简单啊😀 3. 模板 const int INF = 1 &lt;&lt; 29; int n, d[maxn][maxn]; void init() { for(int i = 1; i &lt;= n; i ++) { // 初始化d for(int j = 1; j &lt;= n; j ++) d[i][j] = INF; d[i][i] = 0; } } void Floyd() { for(int k = 1; k &lt;= n; k ++) { // 枚举中间点 for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= n; j ++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main() { ...... init(); Floyd(); ...... } 要注意Floyd中会有INF相加的情况，因此INF值不能太大，这里取的是1&lt;&lt; 29. 4. 例题 Uva 567 * * * 四、差分约束问题与最短路的关系 1. 定义 即给出对n个数m组约束不等式，求其中某两个数的最值。 2. 解析 差分约束问题可以转化为最短路/最长路问题解决。 原理：以问最大值为例，问x-y&lt;=多少时，肯定是通过若干B-A&lt;=w的约束条件才可能获得，而B-A&lt;=w这一不等式可以理解为d[B]&lt;=d[A]+w，这正好符合与最短路问题中的松弛操作的条件（d[u]&gt;d[v]+w）相反，也就是松弛操作会使得这一个个约束条件被满足，因此最短路问题的算法就可以得到满足所有约束条件的不等式的一组解。这样就可以得到d[x]与d[y]的差值了。 3. 模板 具体规则如下： 首先看问题，若问题问最大值则可以转化为最短路问题；问最小值则可以转化为最长路问题； 若为最短路问题，则将所有约束转化为B-A&lt;=w的形式；最长路问题则转化为B-A&gt;=w的形式； B-A&lt;=w对应于d[B]&lt;=d[A]+w，也就是从点A到B的有向路径权值为w； 然后就可以用Dijkstra、spfa或Floyd算法来秒杀了。 若存在负环，则表示无解；若d为INF，表示有无限个解。 4. 例题 Poj 3159 * * * 五、几种常见的最短路变形题 1. 求最大边权的最小值 / 最小边权的最大值 做法 以求最大边权的最小值为例： Floyd做法： 原松弛操作：d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作：d[i][j]= min(d[i][j] ,max( d[i][k] , d[k][j])); Dijkstra/spfa算法： 原松弛操作 ： d[v]= min(d[v], d[u]+w); 变形后的松弛操作 ： d[v]= min(d[v] , max(d[u], w)); 例题 Poj 2253 Poj 1797 2. 求往返最短路的最大值 / 和 做法 数据量小的用Floyd算法秒杀； 否则通过对原图和反图（所有有向边反向）各做一次Dijkstra/spfa来解决。 例题 Poj 1511 Poj 3268 3. 确定排名 做法 用Floyd算法，dp[u][v]表示u打败了v： 原松弛操作 ： d[i][j]= min(d[i][j], d[i][k] + d[k][j]); 变形后的松弛操作 ： d[i][j] = (d[i][k] &amp;&amp; d[k][j]) ? 1 : 0; 例题 Poj 3660 * * * FinFin Fin 最短路变形-参考博客 差分约束-参考博客 ","link":"https://river861.github.io/post/tu-lun-zui-duan-lu-wen-ti-gui-na/"},{"title":"[图论] 最小生成树问题归纳","content":"包括最小生成树、次小生成树和边权极差最小的生成树算法。 基本定义 本文的代码基本按照如下的图论模型进行定义，后文用的结构若与此相同则不再赘述： struct edge { int u, v, w; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { // 边按权值排序 return w &lt; rhs.w; } }; vector&lt;edge&gt; E; // 存储所有边 int n, m, Fa[maxn]; // Fa为并查集所需的数组 int find(int x) { // 并查集的find函数 return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } * * * 一、最小生成树 1. 定义 把若干点连成连通图，求最少连成的连通图的最小边权和。 2. 解析 这是最基础的题型，直接套用Kruskal算法的模板即可 3. 模板 int main() { ...... for(int i = 0; i &lt; n; i ++) Fa[i] = i; // Fa初始化 sort(E.begin(), E.end()); // 按结点从小到大排序 int ans = 0; for(const auto&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; // 若不连通则将其连通 ans += e.w; } ..... } 4. 例题 Uva 10034 * * * 二. 次小生成树 1. 定义 顾名思义，就是边权和第二小的生成树 2. 解析 其实也比较简单，按照以下步骤即可： 求出最小生成树mst 通过以每个点为根分别进行dfs，得到maxW[maxn][maxn]数组。其中maxW[root][v]表示最小生成树mst上从root到v的路径上的最大的一条边的权值。 遍历所有不在mst上的边，比如为（u, v），用它去替换mst上从u到v路径上的最大边，从而得到一系列次小生成树替补。这些次小生成树替补权值和最小的那个就是次小生成树。 时间复杂度为O(n^2+mlogm)，基本够用了。 3. 模板 原理简单，就是代码量较大...要维护一个存放边的容器E，同时还要维护一个存放最小生成树的边的容器mst。 struct edge { int u, v, w; bool flag = 0; edge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator &lt; (const edge&amp; rhs) const { return w &lt; rhs.w; } }; struct mst_edge { int v, w; mst_edge(int v, int w) : v(v), w(w) {} }; vector&lt;edge&gt; E; // 存放所有边的容器 vector&lt;mst_edge&gt; mst[maxn]; // 存放最小生成树的容器 int n, m, Fa[maxn], maxW[maxn][maxn], ans1, ans2; // ans1, ans2分别为最小生成树和次小生成树的边权和 int find(int x) { return Fa[x] == x ? x : Fa[x] = find(Fa[x]); } void Kruskal() { for(int i = 1; i &lt;= n; i ++) Fa[i] = i; sort(E.begin(), E.end()); ans1 = 0; for(edge&amp; e : E) { int u = find(e.u), v = find(e.v); if(u == v) continue; Fa[u] = v; ans1 += e.w; e.flag = 1; // 标记这条边在mst中 mst[e.u].push_back(mst_edge(e.v, e.w)); // 将最小生成树保存起来 mst[e.v].push_back(mst_edge(e.u, e.w)); } } void dfs(int root, int cur, int fa, int val) { // 遍历最小生成树来生成maxW数组 maxW[root][cur] = val; for(const mst_edge&amp; e : mst[cur]) if(e.v != fa) { dfs(root, e.v, cur, max(val, e.w)); } } void SKruskal() { Kruskal(); // 1. 求最小生成树mst for(int i = 1; i &lt;= n; i ++) dfs(i, i, 0, 0); // 2. 求maxW[root][v]数组 ans = INF; for(const edge&amp; e : E) if(e.flag == 0) ans2 = min(ans2, ans1 - maxW[e.u][e.v] + e.w); // 3. 用不在树上的边逐个替换，然后取最小的那个树就是次小生成树 } int main() { ...... SKruskal(); ...... } 4. 例题 Uva 10600 * * * 三. 边权极差最小的生成树 1. 定义 即最大边减最小边的值尽量小的生成树 2. 解析 我们知道求最小生成树是用Kruskal算法，这里其实也是一样：我们枚举生成树的最小边E[l]，然后每次只从边权大于这条最小边边权的边中进行最小生成树的生成，这样就能得到这个生成树的最大边边权。这样枚举完后，我们就能得到边权极差最小的生成树了。 正确性证明：为什么最小生成树T就一定是这个最小边对应的苗条度最小的生成树呢？仔细回想一下Kruskal算法，最小生成树T是通过从小到大枚举边得到的，如果这个最小边对应的使得苗条度最小的最大边不在这个T中的话，那就是说存在一个由边权小于这个最大边的一组边构成的一棵更小的生成树，这就与T是最小生成树矛盾了。 3. 模板 int main() { ...... sort(E.begin(), E.end()); int ans = INF; for(int l = 0, r; l &lt; E.size(); l ++) { // 枚举最小边l，然后通过Kruskal求最大边r for(int i = 1; i &lt;= n; i ++) Fa[i] = i; int cnt = 0; // 用cnt记录加的边的条数，以此判断图是否连通完毕 for(int i = l; i &lt; E.size(); i ++) { int u = find(E[i].u), v = find(E[i].v); if(u == v) continue; Fa[u] = v; if(++ cnt == n - 1) { r = i; break; } } if(cnt == n - 1) ans = min(ans, E[r].w - E[l].w); } ...... } 4. 例题 Uva 1395 * * * FinFin Fin ","link":"https://river861.github.io/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/"},{"title":"[枚举] 暴力求解之枚举方法归纳","content":"包括枚举排列、枚举集合、回溯法、IDA*等算法。 一、枚举排列 1. 定义 枚举出一个序列a[maxn]的所有排列。 2. 解析 枚举排列 最简单的方法是运用STL的 next_permutation函数. 3. 模板 int a[maxn]; int main(){ ...... sort(a, a + n); do{ for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 打印排列 cout &lt;&lt; endl; } while(next_permutation(a, a + n)); } * * * 二、枚举集合 1. 定义 枚举出一个序列a[maxn]的所有子集。 2. 解析 枚举子集 最简单的方法是 二进制法。 设A、B为两个集合的二进制表示，则 交集表示为 A &amp; B 并集表示为 A | B 对称差集表示为 A ^ B 补集表示为 ALL ^ A [其中 ALL = (1 &lt;&lt; n) - 1] [枚举所有子集]： 枚举 0 到 (1 &lt;&lt; n) - 1 中的每个数字 i，然后将数字 i 转化为二进制， 如果 i 的第 j 位是 1，表示集合 i 包含 a[j]； 如果 i 的第 j 位是 0，表示集合 i 不包含 a[j]。 3. 变式 [枚举大小为k的所有子集] 从 i = (1 &lt;&lt; k) - 1 开始枚举，每次找比它大的下一个包含k个1的二进制数，方法如下： 令 x = lowbit(i)，表示当前 i 的靠右的 1 的权值 令 y = i + x，即让 y 等于 i 的最低 “1” 发生进位后的数字，此时必然有 y 中 1 的个数小于等于k 通过 (i &amp; -y) 得到由于进位而导致的所有从 1 变成 0 的位，然后将其除以 x 来去掉右边的所有 0 , 然后再继续右移 1 位来去掉一个 1 (因为进位后在左侧会有一个 0 变成 1) 。这样得到的数再 和 y 或一下，就可以得到下一个包含 k 个 1 的数字。 总结起来就是 i = ((i &amp; -y) / x) &gt;&gt; 1 | y。 [枚举一个给定集合 x 的所有子集] 从 全集 i = x 开始，从大到小枚举子集，方法如下： i = (i - 1) &amp; x. 即通过减1来缩小子集，通过&amp;x来限定在x的子集中。 [枚举一个给定集合 x 的所有超集] 从 最小集 i = x 开始，从小到大枚举超集，方法如下： i = (i + 1) | x. 即通过+1来扩大集合，通过|x来限定生成的集合必定包含x。 4. 模板 打印数字 i 代表的集合 int n, a[maxn]; // 长度为 n 的序列 void print_subset(int s){ // 打印 s 所表示的子集 for(int i = 0; i &lt; n; i ++){ if(s &amp; (1 &lt;&lt; i)) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } 枚举所有子集 void solve() { for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) { print_subset(i); // 用二进制数字i表示一个子集 } } 枚举所有大小为 k 的子集 void solve(int k) { for(int i = (1 &lt;&lt; k) - 1; i &lt; (1 &lt;&lt; n);) { print_subset(i); int x = i &amp; -i, y = i + x; i = (((i &amp; ~y) / x ) &gt;&gt; 1) | y; } } [枚举一个给定集合 x 的所有子集] void solve(int x) { for (int i = x; i &gt;= 0; i = (i - 1) &amp; x) { print_subset(i); } } [枚举一个给定集合 x 的所有超集] void solve(int x) { for (int i = x; i &lt; (1 &lt;&lt; n); i = (i + 1) | x) { print_subset(i); } } * * * 三、回溯法 1. 定义 即利用递归的回溯过程，来进行状态的“还原”，从而枚举出所有的情形。 2. 解析 紫薯告诉我们，回溯法总是比生成-测试法快得多。 需要一个递归深度值 idx（或一个坐标x, y）表示当前递归进度 需要一个值 cur 表示根据当前选择所形成的值（如和值等）。 需要一个 vis 数组标记已经递归过的位置（在回溯时还原） 3. 模板 int n, vis[maxn]; void solve(int idx, int cur) { if(idx == n - 1) { // 递归出口 // 根据 cur 更新 ans return; } for(int i = 1; i &lt;= n; i ++) if(!vis[i] &amp;&amp; 其它条件) { vis[i] = 1; solve(idx + 1, cur + i); // 递归 vis[i] = 0; // 还原 } } int main() { ...... vis[1] = 1; solve(0, 1); ...... } 4. 例题 Uva 524 Uva 167 (八皇后) * * * 四、迭代加深搜索（IDA*） 1. 定义 一种通过多次dfs找解的算法。 从小到大枚举dfs深度上限maxd，每次执行只考虑不超过maxd的节点。 IDA* 能进行关于深度的剪枝，从而提高效率。 一般回溯法可以解决的问题，但是 回溯时枚举边界无法确定时，可以使用IDA*算法。 2. 解析 枚举深搜的最大深度maxd，然后在maxd的限制下去进行dfs，并利用maxd来对dfs进行剪枝，使得dfs的每一层可以很快枚举完。 每次针对一个maxd进行dfs时，实际上就是相当于反复去解答这道题，因此也要重新初始化。 由于需要由maxd限制递归层数，因此dfs函数的参数必须包括一个idx表示当前递归的层数。 剩下的参数就按照需要进行增添。 优化技巧（IDA 的精髓）： 1、考虑最优性剪枝，即通过maxd可以判断出该次迭代已经不可能得到答案时要及时退出*； 2、考虑节点的搜索顺序，以加快搜索到目标节点。 3. 模板 bool dfs(int maxd, int idx, ......) { if(idx == maxd) { // 达到当前枚举的最大深度maxd就处理完后退出 if(不满足条件) return 0; else { ...... // 记录答案 return 1; } } if(通过maxd可以判断出该次迭代已经不可能得到答案) return 0; // 精髓：最优性剪枝 for(正常的dfs枚举) { if(不满足条件) continue; if(dfs(maxd, idx + 1, ......)) return 1; } return 0; } int main() { ...... for(int maxd = 1; ; maxd ++) { memset(ans, -1, sizeof(ans)); // 每次 dfs 需要重新初始化 if(dfs(maxd, 0, ....)) break; // 找到解就退出 } ...... 4. 例题 Uva 12558 Uva 1343 * * * FinFin Fin ","link":"https://river861.github.io/post/mei-ju-bao-li-qiu-jie-zhi-mei-ju-fang-fa-gui-na/"},{"title":"[经典] 常见的高效算法归纳","content":"包括滑动窗口、哈希表、拓扑排序、单调栈、KMP、RMQ、最小表示法、二分答案、Cantor等算法。 一、滑动窗口 1. 定义 滑动窗口法（又叫双指针法），即用i,j双指针（一般用下标）对数组进行遍历，同时要需要一个额外的比如vis数组维护窗口中的元素信息，是一种O(n)的扫描方法。 2. 解析 一般比较常见的问题就是，维护窗口中的元素各不相同。 既可以用一个vis[maxn]数组来表示窗口中是否存在某个元素，也可以用一个pos[maxn]数组来存储上一次遇见某个元素的位置（为-1表示不在窗口中）。本质是一样的。 当元素数值比较大时，用unordered_map来实现vis或pos即可。 最好统一一下开闭区间，比如总是使用闭区间[i, j]作为窗口范围。 最好统一一下判断顺序，比如总是先处理当前元素已经在窗口中出现过的情况 3. 大致模板 额外维护pos ll n, a[maxn]; unordered_map&lt;ll, ll&gt; pos; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { // 维护闭区间窗口[i, j] ll num = a[j]; if(pos.count(num) &amp;&amp; pos[num] != -1) { // 先判断在数组中的情况 for(; i &lt;= pos[num]; i ++) pos[a[i]] = -1; // 注意一定要逐个退出并消除pos } pos[num] = j; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 额外维护vis ll n, a[maxn]; unordered_map&lt;int, int&gt; vis; int main() { ...... ll i = 0, j = 0, ans = 0; while(j &lt; n) { ll num = a[j]; if(vis[num]) { // 先判断在数组中的情况 while(i &lt; j &amp;&amp; a[i] != num) vis[a[i]] = 0, i ++; // 注意一定要逐个退出并消除vis i ++; } else vis[num] = 1; ans = max(ans, j - i + 1); j ++; } cout &lt;&lt; ans &lt;&lt; endl; } 4. 例题 Uva 11572 Nowcoder 数糖纸 Uva 12174 * * * 二、哈希表 1. 定义 当你希望定义一个数组（比如vis数组），但是下标范围很大（比如1e9），这个时候就没有办法开一个vis[maxn]的数组了，因为会爆内存。 这时我们就可以通过hash的方式把下标映射到一个可以接受的小范围，比如[0...200003]。 2. 解析 一般情况下优先使用 unordered_map 或 unordered_set 但也不排除出题人把 map 和 set 给卡了...这个时候就用哈希表吧，使用最简单的开放寻址法来解决冲突， 其实就是一个链表数组。 3. 模板 const int HASH = 2000003; class Vis { public: list&lt;ll&gt; vis[HASH]; void insert(ll x) { // 插入 if(!query(x)) vis[x % HASH].push_back(x); } bool query(ll x) { // 查询 for(ll y : vis[x % HASH]) if(x == y) return 1; return 0; } } vis; 4. 例题 Nocoder 眼花缭乱的街市（卡STL） * * * 三、拓扑排序 1. 定义 给出n个点，然后给出m个依赖关系，比如（u, v）表示必须先有u才有v，要求你输出一个满足依赖的点序列，或者输出无解。 2. 解析 拓扑排序是一种经典的模板题，来源于图论，一般有队列或dfs两种不同的写法（个人比较喜欢队列写法😀）。 需要维护的结构 int in[maxn]：维护每个点的入度数目 vector Next[maxn]：记录每个点的所有出度点 queue ready：维护依赖被满足的点（若题目需要按某种排序输出，则改成优先队列） 当题目中的“点”不是整型，而是用字符串表示时，需额外维护： vector id2str unordered_map&lt;string, int&gt; str2id 3. 模板 int in[maxn]; vector&lt;int&gt; Next[maxn]; void solve() { // 拓扑排序 priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; ready; for(int i = 0; i &lt; n; i ++) if(in[i] == 0) ready.push(i); // 压入一开始就没依赖的点 vector&lt;int&gt; ans; while(!ready.empty()) { int u = ready.top(); ready.pop(); ans.push_back(u); // 记录到答案序列中 for(int v : Next[u]) { in[v] --; // 入度减1 if(in[v] == 0) ready.push(v); // 新的无依赖结点 } } if(ans.size() != n) ...... // 无解 else .... // 打印ans } 4. 例题 Nowcoder 烦人的依赖 * * * 四、单调栈 1. 定义 维护一个栈（或双向队列），保持栈内元素的单调性，存放下标还是值可以依情况而定。由于每个元素最多弹出一次，因此单调栈算法是O(n)的。 单调递增栈作用：O(1)时间获取离当前位置最近的一个小于当前值的元素。 单调递减栈作用：O(1)时间获取离当前位置最近的一个大于当前值的元素。 2. 解析 以单调递增栈为例。 通过这个栈，可以得到到当前元素为止的单调递增序列，从而能得到左侧离自己最近的比自己小的元素。 原理：只有 [比自己大的元素]， 或者 [比自己小但是却被离得更近的更小的元素弹走的元素] 才不会出现在栈中。 3. 模板 存放下标，非严格单调递增栈： stack&lt;int&gt; stk; for(int i = 0; i &lt;= n; i ++) { while(!stk.empty() &amp;&amp; a[stk.top()] &gt; a[i]) { // 先将大于当前值的元素弹出 int temp = stk.top(); stk.pop(); ...... // Do something else | 可以在这里对弹出的元素temp进行一些操作 } ...... // Do something else | 此时栈顶为左侧离自己最近的比自己小的元素 stk.push(i); // 把当前值压栈 } 4. 例题 Hdu 1506 Uva 1619 Uva 12265 * * * 五、KMP算法 1. 定义 在O(n)时间实现从长串test中找到一个匹配子串pattern。 2. 解析 由pattern串生成一个Next[maxn]数组，表示匹配失败时，下标回溯到的位置。 Next[maxn]的含义: 当前匹配串的相同前后缀的前缀末端位置。 比如字符串 aabcaad，假设在匹配d时失败，下标位于6，则对于当前匹配串p[0...5]，相同的前后缀为aa，则将会回溯到前缀的末端位置，即b处，即下标2，因此有Next[6]=2。 3. 变式 循环节 问题 （只需要Next数组） 根据Next数组的定义，Next[i]=j表示j为s[i]匹配失败后需要跳回的位置，也即是i之前和j之前可能为相同的串。 对于一个循环串来说，它的Next数组“跳回”的长度正好就是一个循环节。因此通过 i-Next[i] 即可计算出s[1..i)的循环节长度。 但注意可能字符串不是循环字符串，因此还要判定字符串长度i是否能被循环节长度 i-Next[i] 整除。 注意这样算出来的循环节长度是最小循环节长度，如果需要算出所有可能循环节长度的话，就要用一个while循环一节一节往回跳+判定，由于往回跳的长度就是循环节的长度，因此实际上这是一个枚举循环节长度的过程。比如字符串aaaa，用KMP算法求出的循环节长度为1，但实际上2也是一个循环节长度，此时就要往回跳+判定来枚举全。 扩展KMP算法（需要求出每个位置匹配的长度） 通过一个Extend[maxn]数组来记录test串从每个位置开始的匹配长度 其中注意要通过 j = Next[j] 来回溯，避免遗漏记录，具体见代码EKMP 4. 模板 普通KMP int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 直接返回第一次匹配的写法 int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; } if(j == m) return i - j; return -1; } int KMP(const string&amp; t, int n, const string&amp; p, int m, int* Next) { // 返回匹配次数的写法 int i = 0, j = 0; while(i &lt; n) { if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; if(j == m) cnt ++, j = Next[j]; } return cnt; } void getNext(string&amp; p, int m) { // 求Next数组，在KMP之前调用 Next[0] = -1; int i = 0, j = -1; while(i &lt; m) { if(j == -1 || p[i] == p[j]) i ++, j ++, Next[i] = j; else j = Next[j]; } } 拓展KMP void EKMP(const string&amp; t, int n, const string&amp; p, int m, int* Next, int* Extend){ int i = 0, j = 0; while(i &lt; n){ if(j == -1 || t[i] == p[j]) i ++, j ++; else j = Next[j]; Extend[i - j] = j; // Extend数组记录test串每个位置匹配了多长的pattern前缀 if(j == m){ j = Next[j]; // 继续匹配 for(int k = j; k; k = Next[k]) Extend[i - k] = k; // 回溯 使记录完整 } } } 5. 例题 Uva 1328 Uva 12012 * * * 六、RMQ算法 1. 定义 通过动态规划在O(nlgn)时间内对一个序列进行RMQ-init预处理，然后就可以在O(1)时间内得到这个序列中任意区间[l, r)中的最值！ 注意：为了避免混淆，RMQ算法中所有的区间使用 左闭右开。 2. 解析 O(nlgn)时间预处理 用 dp[i][j] 表示从下标 i 开始的连续 2^j 个数中的最小（大）值，下面以最小值为例。 转移方程：dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]) 即将区间 [i, i + 2^j) 分为 [i, i + 2^(j-1)) 和 [i + 2^(j-1), i + 2^j) 两段. O(1)时间查区间 [i，j) 中的最值 求区间长度的log值，即 k = log(r - l)。（取整后会偏小，所以第2步中要求两段） 最值为 dp[l][k] 和 dp[r - (1 &lt;&lt; k)][k] 中更小的那个。 3. 变式 有时候题目中区间的“值”是比较抽象的，这个时候可以考虑在dp[i][j]中存放区间中取到最值时的下标值，而不是区间中的最值。这样的话 预处理 和 取最值 的函数都需要做出相应修改。 一个最典型的变式例子就是树中求LCA的问题。 4. 模板 const int maxn = 5e3 + 5, log2_maxn = 15; int n, a[maxn], dp[maxn][log2_maxn]; // 序列为a[0...(n-1)] void rmq_init(){ for(int i = 0; i &lt; n; i ++) dp[i][0] = a[i]; // 初始化最短区间 for(int j = 1; (1 &lt;&lt; j) &lt;= n; j ++) // 区间长度由小到大， 大区间的最值由小区间获得 for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i ++) // 循环条件：右端点&lt;n dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; j-1)][j - 1]); // 注意加减法优先级大于&lt;&lt; } int rmq_min(int l, int r){ // 返回闭区间 [l ,r) 中的最小值 int k = log2(r - l); return min(dp[l][k], dp[r - (1 &lt;&lt; k)][k]); } 5. 例题 LCA问题 * * * 七、O(n)时间求最小（大）循环字符串 1. 定义 给定一个循环字符串，要求你输出它字典序最小（大）的表示方法，即确定一个开始位置。 2. 解析 以最小表示为例。 基本思想是双指针i, j，用k表示从i、j开始的子串的当前比对到的完全一样的长度，当判断出i、j的某一条子串的i+k、j+k位置有所不同时，大的那一条（比如是j）就可以往后跳k+1个字符，因为以这些字符起始的循环字符串已经不可能是最小的（比它们小的在i开始的串的子串中）。用这样的方法当i、j串中的某一个超过n时就不用再判断了（因为n个可能的起始位置都判断过了）。此时剩余的那个串就是最小的循环字符串。 3. 模板 //求循环字符串的最小字典序 最大类似 int getMin(const string&amp; s, int n){ int i = 0, j = 1, k = 0; // i, j为双指针, k为当前匹配长度 while(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n){ int temp = s[(i + k) % n] - s[(j + k) % n]; if(temp == 0) k ++; //若当前位匹配, k ++ else{ if(temp &gt; 0) i += k + 1; else j += k + 1; /* 若 s[i...i+k]比s[j...j+k]更大, 设 i&lt;p&lt;i+k 则s[p..i+k]都比s[p-i+j, j+k]大 即前者不可能为最小字典序, 因此全部跳过, 即i += k+1 j同理 */ if(i == j) j ++; // 避免死循环 k = 0; // 更改i、j后重头匹配 } } return min(i, j); } 4. 例题 Uva 1584 * * * 八、二分答案 1. 定义 顾名思义，通过枚举答案的方法，将原先的最值为题转化为判定问题。时间复杂度为 O(lgN * 判定的时间复杂度)。 2. 解析 [最大值尽可能小]、[最小值尽可能大], 这类问题时，可以考虑二分答案。 注意二分时判断OK后r等于多少，l等于多少不要搞错了。一般我们把范围想为[l, r]闭区间不容易错。所以不OK时 l=mid+1，因为不应该包含mid。此为，最好用l=1, r=2来验证一下是否会陷入死循环。 3. 模板 ...... LL l = 0, r = INF; while(l &lt; r) { LL mid = l + (r - l) / 2; if(isOK(mid)) r = mid; else l = mid + 1; } ...... 4. 例题 Uva 714 * * * 九、康托展开（Cantor） 1. 定义 全排列与整数的一种完美双向Hash方法。 2. 解析 正变换 （排列 -&gt; 整数） 双重循环，数出每一位后面有几个比它小的数，据此算出当前排列为第几小的排列（从0计起） res += small * （当前位后面一共有多少位）！ 逆变换 （整数 -&gt; 排列） 令 temp 为原序列从小到大的排列。 逆循环除，商为下一个被除数，余数为small 取temp中剩余数第small+1小的数（index为small） 在temp中删去该数 3. 模板 int cantor(vector&lt;char&gt;&amp; a, int n){ // 由字符数组 转化为 对应的排序数 int res = 0; // res为 比当前排列要小的 排列的个数 for(int i = 0; i &lt; n; i ++){ int small = 0; for(int j = i + 1; j &lt; n; j ++){ if(a[j] &lt; a[i]) small ++; // 对每一位数(或字符), 数它后面有几个比它小 } res += small * Fac[n - 1 - i]; // Fac为阶乘 } return res; } vector&lt;char&gt; decantor(int num, int n){ // 把排序数 还原为 数组 vector&lt;char&gt; temp = a, res; sort(temp.begin(), temp.end()); //temp为按从小到大排列的数组 for(int i = n - 1; i &gt;= 0; i --){ int y = num % Fac[i], s = num / Fac[i]; // s即为small num = y; res.push_back(temp[s]); // 当前第s小的数 即为当前位 temp.erase(temp.begin() + s); // 删去temp[s], 避免影响之后判断 } return res; } * * * FinFin Fin ","link":"https://river861.github.io/post/jing-dian-chang-jian-de-gao-xiao-suan-fa-gui-na/"},{"title":"[动态规划] 背包问题归纳","content":"背包问题是非常经典的一类动态规划题目，包括01背包、完全背包、多重背包等。 一、01背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积（volumn）是v[i]，价值（worth）是w[i]，问如何选择物品装入背包可使价值总和最大。 2. 解析 每种物品只有选和不选两种。我们可以使用多阶段动态规划的思想来解决。 用dp[i][j]表示前i个物品（或用“从第i个物品开始的后面所有物品”的反向定义也行）装入容量为j的背包中的最大价值量。 则转移方程为： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])dp[i][j]=max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i]) 其中每多考虑一个物品i，代表一个“阶段”。括号第一项表示选，第二项表示不选。 **（优化）**由于每一项都是依赖于i-1，因此可以使用滚动数组来优化空间复杂度： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 其中注意使用滚动数组时，j的遍历必须逆序，来保证等号右边使用的dp值是上一阶段的结果值. 如果需要打印路径，则必须使用第一种写法，否则可以使用优化写法来节省空间。 3. 模板 普通写法 int V, n, v[maxn], w[maxn], dp[maxn][maxv]; for(int j = 0; j &lt;= V; j ++) dp[0][j] = 0; for (int i = 1; i &lt;= n; i ++) { for (int j = v[i]; j &lt;= V; j ++) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); } } 优化写法 int V, n, v[maxn], w[maxn], dp[maxv]; for (int i = 1; i &lt;= n; i ++) { for (int j = V; j &gt;= w[i]; j --) { // 逆序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Uva 624 Luogu 2925 干草出售 Luogu 1616 疯狂的采药 Hdu 3466 Proud Merchants * * * 二、完全背包问题 1. 定义 有n种物品和一个容量为V的背包，每种物品都有无限个。第i种物品的体积为v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 由于有无限个，所以每种物品的选择就有无限种了，因此我们不能用01背包的套路了，需要换一种思路。我们先回顾一下01背包中的优化写法，之所以j要逆序遍历是为了使得等号右边的dp值对应的是上一物品计算完后的dp值。而回到完全背包问题，由于物品有无限个，因此对于已经选择了当前物品的dp值，我们依然可以继续添加当前物品，直到达到背包上限为止。这样一想，完全背包问题的递推式就大概是： dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j])dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], dp[i][j - v[i]] + w[j]) dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i],dp[i][j−v[i]]+w[j]) 其中第1、2项和01背包一样，第3项表示继续添加当前物品。 然而上述递推式实在是比较混乱，因此实际上大多数情况下使用的是滚动数组的版本： dp[j]=max(dp[j],dp[j−v[i]]+w[i])dp[j] = max(dp[j], dp[j - v[i]] + w[i]) dp[j]=max(dp[j],dp[j−v[i]]+w[i]) 可以看到这里和01背包的转移方程是一样的，但是实际用的时候这里j的遍历顺序必须为正序。 在笔者看来，完全背包问题的写法其实还可以通过刷表法来理解。就是对于每一种新的物品i，用它来不断刷新所有体积的背包的状态（最大价值量）。j的顺序遍历使得刷新的效果可以“叠加”，从而实现放入多个物品的效果。 实际上紫薯还提供里完全背包的另一种思路，即看成是带权的DAG的最长路问题，不过其代码量相比于递推式要稍微大一些，因此这里略。感兴趣的可以看一下下面的例题，有使用了这种方法的题解。 3. 模板 int V, n, v[maxn], w[maxn], dp[maxv]; fill(dp, dp + V + 1, 0); for(int i = 1; i &lt;= n; i ++) { for(int j = v[i]; j &lt;= V; j ++) { // 顺序遍历 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } 4. 例题 Hdu 4508 Hdu 1114 Piggy-Bank Luogu 1853 投资的最大效益 * * * 三、多重背包问题 1. 定义 有n种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件体积是v[i]，价值是w[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 多重背包问题限制了物品的数目，这里有一种显然的思路就是，把每一“个”物品看作一个不同的“种”物品，然后用01背包去做，但是这样大概率为超时（笑），时间复杂度为O(V*∑p[i]) 顺着上述思路，有一种二进制法可以将时间复杂度降到O(V*∑lgp[i])，并且一般够用了😀。 它的原理就是将一个数量为p[i]，价值为v[i]的物体拆分成 1、2、4、8...这若干份（每一份右2的幂次份原物体构成，构成的新物体价值为kw[i]，体积为kv[i]），然后 注意最后不足2的幂次的数量也单独做成1份，这样物体的总数量就降为了 O(∑lgn)。然后就可以按照01背包问题的套路来处理这∑lgn个新物体了。 正确性是由二进制原理保证的：因为原来可能选择的1~p[i]个原物体一定可以被替换为新物体的组合。 实际上还有一种使用单调队列的优化方式，但由于技巧性比较高，一般用不到 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示原物体i的数量限制 fill(dp, dp + V + 1, 0); for(int i = 0; i &lt; n; i ++) { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 每一个新物体由k个原物体组成 if(k &gt; num) k = num; // 最后不足2的幂次的单独一份 num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 对新物体使用01背包问题处理，这里使用的是01背包问题的滚动数组模板，当然也可以不用 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 其实还有另一种写法是将原物体分为新物体后用一个新数组装起来，然后再进行01背包操作，区别其实不大。这里直接写在外层嵌套了，因为代码量少一些所以我喜欢😀。 4. 例题 Hdu1059 Luogu P1776 宝物筛选 * * * 四、混合背包问题 1. 定义 如果将前面三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的有限次（多重背包），问如何选择物品装入背包可使价值总和最大。 2. 解析 首先01背包和多重背包在模板上只有j的遍历顺序不同，因此我们可以通过一个if语句来区分这两种背包，然后分别进行不同顺序的内层循环即可 然后其实01背包是一种特殊的多重背包，即01背包是数量上限为1的多重背包问题，这样一想其实就只用写多重背包的代码即可 3. 模板 int V, n, v[n], w[n], p[n], dp[maxv]; // p[i]表示每个物品的件数，-1代表无穷个 for (int i = 1; i &lt;= n; i++) if (p[i] == -1) // 完全背包 for (int j = v[i]; j &lt;= V; j++) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); else { for(int k = 1, num = min(p[i], V / v[i]); num &gt; 0; k &lt;&lt;= 1) { // 01背包和多重背包 if(k &gt; num) k = num; num -= k; for(int j = V; j &gt;= k * v[i]; j --) { // 01背包只会执行k=1这一次 dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]); } } } 4. 例题 Luogu P1833 樱花 HDU 3535 AreYouBusy * * * 五、二维背包问题 1. 定义 对于每件物品，具有两种不同的代价v[i], g[i]，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）V, G，物品的价值为v[i]v[i]。问如何选择物品装入背包可使价值总和最大。 2. 解析 这个其实比较简单，就是让dp数组增加一维度即可。 即dp[i][j][k]表示前i件物品装入两种代价分别为j和k的背包时可获得的最大价值量。滚动数组后就变成dp[j][k]。直接看代码会就一目了然了。 3. 模板 int V, n, v[n], g[maxn], w[n], p[n], dp[maxv][maxg]; // v[i]和g[i]分别为两种代价 for (int i = 1; i &lt;= n; i ++) for (int j = V; j &gt;= v[i]; j --) for (int k = G; k &gt;= g[i]; k --) dp[j][k] = max(dp[j][k], dp[j - v[i]][k - g[i]] + w[i]); 4. 例题 Luogu 1507 NASA的食物计划 HDU 2159 FATE * * * 六、分组背包问题 1. 定义 有n件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。问如何选择物品装入背包可使价值总和最大。 2. 解析 其实分组背包可以把每个组看作一个物体，即这其实就是一个01背包问题，每个物体依然还是选和不选两种状态，只不过选的时候可以从组内的多个原物体种任意选一个。同样看代码就一目了然了。 3. 模板（伪代码） for (所有的组k) for (int j = V; j &gt;= 0; j--) for (所有属于组k的i) dp[j] = max(dp[j], dp[j - v[i]] + w[i]) 4. 例题 Luogu 1757 通天之分组背包 HDU 1712 ACboy needs your help * * * 七、背包问题的其它要素 1. 问法不同 最大值、最小值： 一次对应max、min即可 方案数目：改为sum，同时注意初始化可能需要改变 2. 范围不同 最大化、最小化： 初始化时对于前0个物品的价值量dp[i][0...V]全部初始化为0，这样即使最终的dp[n][V]未达到边界值也能有最值答案（根据提问内容不同可能会有所改变） 恰好装满 初始化时dp[i][0]=0, dp[i][1...V]全部初始化为 -INF或INF，这样不能刚好达到V的方案的最终价值量就为 -INF或INF（根据提问内容不同可能会有所改变） 3. 打印路径 不使用滚动数组的写法，即有完整的dp[i][j]记录，然后通过递归的方法print_ans打印路径。这是我个人比较喜欢的写法，因为不用额外维护存储路径信息的数组😀 维护一个记录路径信息的数组 记录下每个状态的最优值是由状态转移方程的哪一项推出来的。然后就可以根据这条记录找到上一个状态，从上一个状态接着向上推，得到整条路径。 3. 情景 区分背包问题是简单的，但是..... 如何才能发现一道题考察的是背包问题呢？ 这就需要多刷题目，直到看到题目的某个情景就能反应出是在考察背包问题。 当然我还没到那种境界就是了hhh😀 * * * FinFin Fin 参考博客 ","link":"https://river861.github.io/post/dong-tai-gui-hua-bei-bao-wen-ti-gui-na/"},{"title":"[贪心算法] 区间问题归纳","content":"贪心算法中的区间问题归纳，包括区间不相交问题、区间选点问题、区间覆盖问题、区间限制问题等。 基本定义 区间用一个结构体来表示： struct Internal { int l, r; bool operator &lt; (const Internal&amp; rhs) const { return ......; // 按左端点 或 右端点 或其它排序 } }; vector&lt;Internal&gt; vec; // 存放所有区间的容器 以下代码只使用一个int类型的ans进行计数，若题目需要打印出所选择的区间/点，则改成用一个vector类型的ans存储即可。 * * * 一、区间不相交问题 1. 定义 数轴上有n个区间（li, ri），选择尽量多的区间，使得这些区间两两不相交。 2. 解析 贪心策略：按r从小到大进行排序，即总是先选取r小的区间，这样就能给后面的区间留下更多空间。 当r相等时，l无所谓，因为只要选择其中不与前一个区间相交的任意一个即可。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最大右端点 for(const auto &amp; p : vec) if(p.l &gt;= cur) ans ++, cur = p.r; 4. 例题 UvaLive 6606 * * * 二、区间选点问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的点，使得每个区间内都至少有一个点。 2. 解析 贪心策略：按r从小到大进行排序。每次选点时，总是选取第一个不被包含的区间的最右端点处。这样能让这个点接触到最多区间。 当r相等时，l无所谓，因为不影响点数。 3. 模板 sort(vec.begin(), vec.end()); // 按r排序 int ans = 0, cur = -INF; // cur表示当前已选择的最右的点 for(const auto&amp; p : vec) if(cur &lt; p.l || cur &gt; p.r) ans ++, cur = p.r; 4. 例题 Uva 1615 * * * 三、区间覆盖问题 1. 定义 数轴上有n个区间[li, ri]，选择尽量少的区间覆盖一条指定线段[s,t]。 2. 解析 贪心策略：按l从小到大进行排序。将l&lt;s的这些区间的小于s的部分截掉（因为这部分没有用），然后从这些区间中选择出剩余长度最长的进行覆盖，然后将s更新为该区间的右端点。接下来继续遍历以此类推，直到 s&gt;=t，说明已经覆盖完毕。 这道题贪心策略稍微复杂，代码写起来也稍微麻烦，要好好记忆。 3. 模板 sort(vec.begin(), vec.end()); // 按l排序 int s = 0, t = M, ans = 0; // 目标区间[s,t] auto L = vec.begin(); while(s &lt; t &amp;&amp; L != vec.end()) { // 右端点无法覆盖 auto R = upper_bound(L, vec.end(), Internal(s, s)); // [L,R)表示容器下标范围 if(L == R) break; // 左端点无法覆盖 auto chosen = *max_element(L, R, [](const Internal&amp; a, const Internal&amp; b) { return a.r &lt; b.r; }); // 找到最长的那个 ans ++; L = R, s = chosen.r; } if(s &lt; t) cout &lt;&lt; -1 &lt;&lt; endl; // 无法覆盖完全 4. 例题 Uva 10020 * * * 四、区间限制问题 之 用时相等 1. 定义 有若干个任务，每个任务有一段执行的时间区间[li, ri]限制，每个任务的用时都相等，比如都为1。 问能否完成所有任务。 2. 解析 贪心策略：按r从小到大进行排序（r相等时，按从长到短排序），每次尽量早地执行任务（可能就是从l开始，也可能不是，因为被之前的任务占用）。这里的r实际上就是ddl，总是先处理快到“ddl”的区间。ps：结合实际生活来看，这的确是显然的。 r相等时，l按照从小到大排序，这是为了能让任务地起始时间有可能更早。 3. 模板 struct task { // 一个任务 int l, r, idx; task(int l, int r, int idx) : l(l), r(r), idx(idx) {} bool operator &lt; (const task&amp; rhs) const { return r &lt; rhs.r || r == rhs.r &amp;&amp; l &lt; rhs.l; } }; vector&lt;task&gt; vec; ...... fill(vis, vis + n + 1, 0); // 用来标记某个时间是否被占用 sort(vec.begin(), vec.end()); // 按照 (r, l) 排序 for(const auto&amp; p : vec) { int j = p.l; while(j &lt;= p.r &amp;&amp; vis[j]) j ++; // 找第一个没被占用地时间点执行任务 if(j == p.r + 1) return 0; ans[p.idx] = j, vis[j] = 1; // 用ans记录任务p的执行时间 } ...... 4. 例题 Uva 11134 * * * 五、区间限制问题 之 用时不等 1. 定义 有若干个工作，只能串行进行，已知每个工作的用时need[i]和截止期限ddl[i]，问最多能完成多少个工作？ 2. 解析 这个是超典型的工作安排贪心问题。 一个比较简单的版本是给出工作的确切开始时间和结束时间，这种问题就是典型的区间限制问题，我们按照ddl排序，然后先完成ddl早的任务即可。 但是在这道题中，任务的开始时间是可以任意决定的（只要结束时不超过ddl期限），因此我们还应该结合考虑另一种贪心：即让短的任务优先。 也就是说，对于一个给定的时间点之前，我们需要先执行短的任务，这样才能让任务完成数量最大化。这里 需要用一个优先队列来存放到当前时间点为止，所有已经选择的任务 。用这个优先队列的目的是为了能获得已经选择的任务中用时最长的那一个，这样就能在当发现一个任务由于超时无法选择时可以有尝试替换的机会（即从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时）。 贪心策略：按r从小到大进行排序，每次尽量早地执行任务。当碰到一个任务超时，尝试从之前选择的任务中挑一个用时长的取消掉，从而使得当前任务不会超时。 3. 模板 struct task { int need, ddl; task(int need, int ddl) : need(need), ddl(ddl) {} bool operator &lt; (const task&amp; rhs) const { return ddl &lt; rhs.ddl; } }; ...... sort(vec.begin(), vec.end()); priority_queue&lt;int&gt; que; int cur = 0; // 当前时间点 for(const task&amp; t : vec) { // 总体上还是优先考虑ddl早的任务 if(cur + t.need &lt;= t.ddl) { // 不超时 cur += t.need; que.push(t.need); } else if(!que.empty() &amp;&amp; que.top() &gt; t.need) { // 反正都会有一个任务不能完成，不如留下用时短的任务（当前任务） cur += t.need - que.top(); // 即用这个ddl更晚的但用时更短的task替换一个ddl早一些但是用时长的task que.pop(); // 由于当前任务的ddl更晚，用时也更短，因此替换后必然不会超时 que.push(t.need); } } cout &lt;&lt; que.size() &lt;&lt; endl; ...... 4. 例题 Uva 1153 * * * FinFin Fin ","link":"https://river861.github.io/post/tan-xin-suan-fa-qu-jian-wen-ti-gui-na/"},{"title":"Snake!","content":"一个好玩的贪吃蛇小游戏，改进自 sfSnake，C++程序设计PJ。 一、项目简单介绍 升级版贪吃蛇小游戏。好玩就对了~ 改进前的贪食蛇源代码来自 jhpy1024 的仓库 sfSnake。 二、编译环境说明 Windows 10 需要第三方库SFML支持：把 sfml2.5.zip 文件解压缩到 C:\\sfml2.5 目录下，然后把 C:\\smlf2.5\\lib 目录添加到路径变量 path 中 点击 Src/main.exe 即可运行 三、新增功能的介绍 1. 鼠标控制 说明 按照项目要求，实现了贪吃蛇的鼠标控制。 此外，还通过自定义的Button类实现了按键效果，从而实现了界面的鼠标控制，至此游戏完全不依赖于键盘输入了。 效果 2. 水果设计 说明 按照项目要求，实现了5种不同颜色、得分、出现概率的水果。 此外，为了提高可玩性，将5种“水果”分别设计为了草莓、蓝莓、猕猴桃、蘑菇、石头，分别对应于红色、蓝色、绿色、棕色、黑色。 另外，为了提高游戏效率，界面中的水果数目由1个变成5个。 效果 3. 贪吃蛇设计 说明 按照项目要求，实现了精灵版本的贪吃蛇，蛇头用图片，蛇身用圆形叠加矩形绘制。 此外，为了满足不同玩家的喜好，设计了4种不同样式的蛇供玩家在设置界面进行选择。设置界面将在后面说明。 效果 4. 整体界面修改 说明 按照项目要求，实现了背景和网格的白、黑、褐三种颜色的修改。简单起见，这里若背景和网格的颜色相同，则视为关闭显示网格。 效果 5. 设置界面与背景音乐 说明 上述的蛇外形选择、背景和网格颜色选择均在设置界面中进行设置。 此外，还新增了对背景音乐的变更设置，包括原音乐，一共放入Cute、Pretty、Silent、Default四种不同风格的背景音乐供玩家选择。音乐是游戏的灵魂！ 效果 由上至下，分别是对蛇外形、背景、网格、音乐的修改。通过每一项的左右箭头进行切换选择。点击okay后修改才正式生效，点击cancel取消修改。 四、资源管理策略的介绍 1. 实现了统一的资源管理类 为了防止资源的反复加载，同时为了方便资源的维护和扩展，项目中将所有的纹理(Texture)、字体、声音缓存、背景音乐都统一放在了Recource类里集中管理。同时通过单例模式来实现Resource类，使得所有相同的资源只存在一份，从而节省内存空间，实现程序的经济有效。具体代码参见 Resource.h 和 Resource.cpp。 2. 用静态量存放经常用到的映射数据 在程序的运行中，会出现大量类对象的构造和析构，为了节省这些对象的构造开销，代码中将许多经常用到的大数据类型用static修饰，从而提升效率。典型的例子是许多存放数据映射的map或vector类型的变量，比如：水果类型到水果分数、纹理名到纹理的映射等等。 五、其他重大改变或优化的列举 1. bug修复 将鼠标定位的数值进行随窗口大小的缩放处理，从而修复了窗口放大后鼠标定位错误的bug； 水果产生用到的随机生成器改为了通过构造函数传种的方式，以避免反复接种，从而修复了水果不随机的bug； 蛇判断出冲突后及时跳出判断的循环结构，以修复由于蛇头与两个相邻结点同时冲突而导致的死亡音效触发两次的bug； 为每一个蛇结点、水果等对象设置变换中心，从而修复了左转和右转的角度差异bug； 将原版本的Warning报错解决； 2. 设计优化 最终得分的计算减去了初始长度，即最低分将是0分； 蛇头与蛇身冲突的判断方式改为了蛇头圆心是否在蛇身结点包围盒内的判定方式，变得更加合理了； 蛇的增长方式改为了新结点与尾结点重合的方式，变得更加合理了； 对水果坐标的随机数范围进行了微调，从而避免水果产生在边界的可能； 通过设置音乐循环节的时刻位置实现了新增音乐的无缝衔接循环； 为蛇结点、水果对象设置旋转角度，其中蛇结点随着蛇爬行角度进行旋转，水果则以随机旋转角度出现； 各种样式美化； 3. 代码优化 通过继承的方式简化了许多代码，如蛇身结点类直接继承CircleShape类，蛇头类直接继承Sprite类，而不是像原版本一样包装了一层“空壳”类，然后实现了许多冗余的管道方法； 网格也通过单例模式实现，保证网格对象的唯一性； 将代码中的许多传值改为了传引用，整型改为了浮点型； 六、项目总结 由于项目内容很有趣所以做得很投入，并且老师的项目要求里也激发了我的许多灵感。当然还有许多更多的灵感没有完全实现，如水果数量的设置、网格间距的设置等等，但由于其它课程压力的原因就暂时做到这样了。值得一提的是，由于C++面向对象的特性，写出来的代码具有很强的可扩展性，如设置界面的每一行设置都是通过一个Setting类实现的，因此若要新增上述没有实现的设置也是比较容易的，再加上统一资源管理的Resource类，代码的可维护性就变得更强了。通过这个项目，我对面向对象的设计方式变得更加的熟悉了。 七、参考资料 改进前的贪食蛇源代码 SFML 库 * * * FinFin Fin Github源码 求⭐️~ ","link":"https://river861.github.io/post/snake/"},{"title":"Student Elearning App","content":"复旦elearning系统的安卓app版，网络创新实验 PJ。 一、项目名称 ​ Student Elearning App 二、项目介绍 1. 项目功能、用途与设计思想 本项目为学校elearning系统的手机App版，使掌上浏览elearning成为了可能。在实现elearning大部分原有功能的基础上，本项目还针对elearning现有的缺陷做出有针对性地改进，实现对elearning功能的筛选、发扬和再创造。 在用途方面，就是让学生们能十分便捷地浏览elearning上的课件、作业等信息，另一方面，还可以通过日历功能进行待办的记录等，具体的功能与效果将在后面叙述。 本项目的设计思想为用户至上。即尽可能地提升用户的使用体验，在界面上做到尽可能的美观，在功能上做到尽可能的人性化。 2. 总体设计与框图 ​ 框图中客户端为用户的手机客户端，服务端为服务器端。 在客户端，Login模块负责用户的登陆界面，它包含的信息管理模块用于在用户手机上储存用户的用户名、密码；主模块即用户登录成功后进入的主界面，它包含Dashboard、Calendar、Home三个功能区，分别用于用户的课程管理、代办管理、个人信息管理。 其中，Dashboard功能区由若干个Course模块组成，每个Course模块代表用户所选的一门课程。在每个Course模块中，用户可以分别浏览公告、作业、人员、文件信息，这些分别由相应的模块实现，还可以通过Color模块为课程卡片换色。Home功能区除了复用的Files模块和Color模块外，还包含一个All-to-do模块，主要是用于对用户所有待办事项的集中显示。Calendar功能区由于功能之间联系紧密，因此没有子模块。 在服务端，按处理方式主要分两类请求。若是对TOKEN的请求，则利用爬虫的手段，通过用户的用户名和密码获取用户TOKEN，然后将其返回给客户端。在这之后的所有客户端请求都将附带TOKEN。对于这些其它请求，服务端将根据请求的内容构造相应的新请求，然后将之发送给Elearning-API文档所提供的相应接口获取用户数据，然后将数据清理、整理后发送回客户端。 3. 功能的效果展示 1） 登录 若之前已登录过，则用户名和密码将会被自动填充；每当进行数据请求时界面都会有loading动画。 2）Dashboard功能区 查看公告（Announcements） 可以在公告列表中查看该课程的公告，长公告支持滚动，同时支持图片渲染。这里是通过HTML模块实现的。 查看文件（Files） 如果是文件夹则可以继续打开，如果是文件则可以点击进行在线浏览，各类型文件用图标区分。在线浏览的功能在模拟器中无法运行，在真机上则可以，如下图： 在线浏览时可以放大、滚动。 查看作业（Homework） 可以在作业列表中查看该课程的作业，列表项中绿色图标表示已完成，未完成将是红色。点击进入可以查看该项作业的详细要求，这里也是通过HTML模块渲染实现的。 查看人员（Members） 在人员列表中可以查看该课程的人员信息，包括老师、助教和学生的头像、姓名、学号信息。 修改课程卡片颜色 点击右上角的颜色板按键，可以为该课程换色，除了选择颜色，还可以调节亮度。如图换成了深粉色。 3）Calendar功能区 上下滑动切换周视图和月视图；左右滑动则是进入上一周/月和进入下一周/月。 一句话任务的新增、删除、查询 日历右上角3个按键分别为：跳到今日，新增任务，切换周月视图 每个任务项右边的2个按键分别为：设为已完成，删除任务 每日任务的完成情况用颜色标记 绿色：表示过去某一天的任务全部完成 红色：表示过去某一天还有任务没有完成 蓝色：表示将来某一天有计划 4）Home功能区 个人界面的右上角3个按键分别为：退出登录，清空文件缓存，修改个人颜色 个人代办事项的集中显示 包括未完成的作业，以及在日历中进行的计划，都会在这里集中显示。 个人文件夹 这里复用的和课程文件一样的Files模块，可以在这里找到自己提交的课程作业文件。 4. 项目部署方法 部署前的说明： a. 保持网络连接，若是模拟器要注意设置好网络，确保网络能连接到服务端（特别是对于android自带的模拟器，可以使用 emulator @[模拟器设备名] -dns-server 8.8.8.8,114.114.114.114 指令来使用Google提供的DNS地址启动模拟器） b. 第一次登陆会有点慢，因为需要爬虫获取TOKEN，请耐心等待 1）方法一：使用远端服务器 这种方法将使用我已经在阿里云服务器上搭建的服务端。（2020.10到期） 如果认为不够安全，则可以在自己的服务器上将后端代码进行部署，然后修改源码中的 com.example.elearning.ElearningApi 中开头的 MyBackend 字符串并重新build出apk来安装运行。 将 elearning.apk 直接安装在真机或模拟器上即可登录运行。 2）方法二：使用本地服务端 使用python3运行 ElearningBackend\\MyBackend.py 来在本机启动服务端； 使用 ipconfig 找到本机的 IP 地址； 检查网络：在要运行 app 的设备（真机或模拟器）上访问 http://[本机IP地址]:5555/hello，若能访问成功，说明本地服务端可用，则可以直接进行下一步；若访问失败，请检查真机或模拟器的网络设置； 修改源码中的 com.example.elearning.ElearningApi 中开头的 MyBackend 字符串为 http://[本机IP地址]:5555，它表示服务端的 url； 重新 run 源代码即可启动 app 并登录运行（这里要注意 gradle 版本等问题）。 三、项目难点与解决技术 1. 登录比较麻烦 难点描述：学校elearning的所有api都需要用TOKEN作为请求的凭证，而获取TOKEN的api又需要用学校elearning系统的 Develop Key 作为请求的凭证。即没有权限的问题。 解决方法： 通过爬虫手段获取TOKEN信息。本项目直接使用的是 Selenium 自动化工具来爬取用户的TOKEN。这种方法优点是简单直接，缺点是有点慢。 解决爬取慢的问题。我在手机客户端实现了信息管理模块，不仅用来存储用户名和密码，还将用户第一次登录所获取的TOKEN也存储在了手机客户端中（具体为存储在 SharedPreferences 中），由于爬虫获取的是无限期的TOKEN，因此理论上一部手机安装完这个app后就只需要爬虫一次，之后的请求就直接使用本地已经存储的TOKEN即可。 技术总结：Selenium、android.content.SharedPreferences 2. 在线浏览如何实现 难点描述：android原生的web浏览器是没有办法打开复杂的文档的，比如elearning中常见的ppt、pdf类型的文件。 解决方法： 使用第三方的文件在线浏览技术，这里选择的是 腾讯TBS服务。腾讯TBS服务简单来说就是使用一种基于x5 内核的web浏览器来实现文件的在线浏览，目前可以支持多达46种文件的打开，像在微信、QQ等中打开文件都是使用的这种技术。缺点是由于模拟器中不支持x5内核，因此在模拟器中无法使用该功能。 解决模拟器无法使用的问题。即进行真机调试。由于我没有安卓手机，因此这里需要请有安卓手机的同学帮忙远程调试。 技术总结：腾讯TBS服务。接入教程参考官网 https://x5.tencent.com/tbs/guide/sdkInit.html 3. 需要实现的模块太多了 难点描述：由于app的功能繁多，项目工程量实在巨大。具体见前面的设计框图。 解决方法： 尽可能复用模块。在设计时，我将大部分界面设计为相似的列表结构，比如Course模块中的公告列表、文件列表、作业列表、人员列表以及Home模块中的待办列表，最终复用了同一个 ListView，只是每种列表项的布局和点击效果不同罢了。而要实现一个能装入不同类型Item的ListView，就需要设计一个可复用的自定义 BaseAdapter， Adapter是一种用来帮助填充数据的中间桥梁。 多使用第三方库。 为简化网络请求代码的复杂性，使用了开源的网络框架okhttp3 为简化json数据解析的复杂性，使用了第三方库fastjson 为简化图片的加载和缓冲的复杂性，使用了第三方库 glide 技术总结： 1） 可复用的自定义BaseAdapter。参考教程：https://www.runoob.com/w3cnote/android-tutorial-customer-baseadapter.html。最终的实现位于 com.example.elearning.util.SuperAdapter 2）好用的网络请求框架 okhttp3。导入包：com.squareup.okhttp3:okhttp:4.4.0 3）好用的json解析第三方库 fastjson。导入包：com.alibaba:fastjson:1.1.55.android 4）好用的图片处理第三方库 glide。导入包：com.github.bumptech.glide:glide:3.7.0 4. 界面美化太难了 难点描述：安卓原生开发的界面美化实在困难，很难达到像网页那样的界面质量。 解决方法： 尽可能挖掘可以美化的地方。例如我在课程卡片上增加了阴影效果，点击时增加了涟漪效果等，并且还重新自定义了toast的样式，这些是原生android可以实现的技术。 排版时设计尽可能规整。排版时大部分使用的是 LinearLayout 和 RelativeLayout，也因此支持横屏。 多使用第三方库。如 Loading 界面、Calendar 界面、Color 选择器，都使用了相应第三方库。 技术总结： 1）涟漪效果。最终实现的类位于 com.example.elearning.util.MyButton 2）好看的 Loading 界面。导入包：com.zyao89:zloading:1.2.0 3）好看的 Calendar 界面。导入包：com.haibin:calendarview:3.6.6 4）好看的 Color 选择器。导入包：com.github.QuadFlask:colorpicker:0.0.15 四、项目总结 选择一个有趣的项目内容很重要。若不是觉得有趣，我一定是做不完这个项目的。 多利用第三方库很重要。若不是借用了许多好用或好看的第三方库，我一定是做不到这样的效果的。并且学习的这些第三方库若以后还做app的话一定还能用上的。 一些遗憾。可惜这个app只能用在安卓手机上，并且我也不是用的安卓手机...不过感觉如果能给周围的同学带来便利，就已经很满足了！ * * * FinFin Fin Github源码 求⭐️~ ","link":"https://river861.github.io/post/student-elearning-app/"},{"title":"TODO Helper 时间管理助手","content":"一个可以将自然语言转化为待办事项列表的时间管理助手，自然语言处理PJ。 0 选题动机与项目介绍 时间，作为自然语言中的一个重要成分，应该引起我们的充分关注。然而，jieba分词等大部分分词工具并不能对中文时间的描述进行很好的区分，因此，这就需要通过神经网络来实现对自然语言中时间成分的提取。常见的基于时间提取的自然语言处理项目主要应用于对新闻文本中的时间提取，而在本项目中，我将时间提取应用于更实用的与时间管理相关的应用软件设计中。 时间管理助手，简单来说即是对未来事件的时间备忘，在许多智能手机和电脑中都有这样的软件。比较成功的时间管理软件的例子为语音助手Siri。用户可以直接通过语音告诉Siri之后的时间安排，并设置闹钟提醒。然而，并不是在所有场合都适合语音输入，因而在本项目中，我实现的是用户通过自然文本的输入来告知之后的时间安排，然后程序自动解析时间并在日历上进行事件标注。当然，语音输入的方式可以作为未来的工作开展。 1 项目整体框架 用户通过交互界面输入自然文本形式的时间安排叙述后，后端基于神经网络的时间提取器会将文本中的时间成分抽取出来，剩下的部分默认为任务成分。时间成分和任务成分成对出现。之后分别基于正则表达式和句法分析将时间成分和任务成分转化为规范化的表示。多对规范化的时间-任务对将构成任务时间列表。之后根据任务时间列表在交互界面的日历上打上相应记号和说明。用户可以勾选已完成的任务，任务时间列表维护器将动态更新日历上的任务显示。 其中，时间提取为本项目的重点，而任务解析、时间解析为本项目的难点。 2 项目实现流程 2.1 语料获取与数据分析 2.1.0 语料来源 本项目的数据来源为网上一份已经人工进行了时间标注的新闻语料（链接见参考文献[3]）。语料的标注采用的是BIO标记，B-TIME表示时间短语开头，I-TIME表示时间短语中间，O表示不是时间短语，示例如下： 凌 B-TIME 晨 I-TIME 时 I-TIME 分 I-TIME , O 战 O 斗 O 打 O 响 O 了 O 。 O 考虑到人们对于时间表达的相似性，因此将这个语料用于本项目是合适的。语料共有2001段新闻语句，总计114290个字。其中有2888段时间语句。如果训练效果不佳，将会考虑自行扩充语料并进行人工标注。但从结果看，这个语料数量已经能得到很好的时间提取效果了。 2.1.1 数据清洗 将中文数字转化为阿拉伯数字 将“零”到“三十一” 转化为0到31表示 年份的中文数字表示为逐位表示的，因此与年份有关的中文数字为零到九；月份的中文数字表示包含一到十二；周号的中文表示包含一到七；日号的中文表示包含一到三十一。 一些特殊考虑 “〇”和“两”这两个特殊数字表示不能遗漏；“(周|星期|礼拜)(日|天|末)”要转化为“(周|星期|礼拜)7” 标点符号转化为半角表示 这一点主要是针对冒号表示的时间时刻。比如将“8：00”转化为“8:00” 2.1.2 对时间描述方式的分析 通过观察数据集以及结合自身语言经验，我对日常生活中常见的时间表达进行了粗略归纳，并利用简单的正则表达式对数据集进行了粗分类，统计结果如下： 其中一个时间表达可能对应图中的多个表达形式。我们可以看到以准确的“某年某月某日”或“某月某日”的时间表达占据了大多数，之后常见的表达还有“今天”“明天”“后天”等表达和几点钟或几时的表达。这些表达在我们日常的时间规划中都是经常用到的。 标签未覆盖到（unmatch）的时间描述举例如下： 南北朝 122个工作日 前几天 1甲子 连续几年 南宋之初 我们可以看到，这些时间基本不在本项目需要讨论的范围内，这说明这里归纳的时间表达是比较全面的了。后面基于正则表达式的时间解析器就是以这些表达为基础设计的。 2.1.3 时间描述的复杂程度分析 实际上，上面的每一种表达方式对应于时间表达的一个“粒度”。当一个时间与上面越多种表达式相匹配，它就包含了越多的层次，我们就可以认为这个时间描述得越复杂： 我们可以看到，绝大部分时间描述使用了3层或更少更简单的表达，只有少部分时间描述得很复杂。最复杂的几种时间描述举例如下： 时间成分 层数 匹配的表达式 今日至周7(11日)的早上6时至晚上11时59分期间 7 'XX日/号'、'XX点/时'、'XX分'、'早晨'、'晚上'、'周X' '[今明后]XX' 2008年5月12日下午2时28分04秒 6 'XXXX年'、'XX月'、 'XX日/号'、'XX点/时'、'XX分'、'下午' 昨晚(8月9日)10点半左右 6 'XX月'、'XX日/号'、'XX点/时'、'X点半'、'晚上'、'[今明后]XX' 8月6日凌晨3点50分左右 5 'XX月'、'XX日/号'、'XX点/时'、'XX分'、'凌晨' 4月3日下午16点21分 5 'XX月'、'XX日/号'、'XX点/时'、'XX分'、'下午' 北京时间2019年8月10日下午15:20 5 'XXXX年'、'XX月'、'XX日/号'、'下午'、'XX:XX' 8月10日下午3时30分 5 'XX月'、'XX日/号'、'XX点/时'、'XX分'、'下午' 我们可以看到第一个例子为“时间段”的描述，时间段的描述能大幅提高时间描述的复杂度。我们之后的时间解析器将以解析出上述复杂的时间描述作为检验指标。 2.1.4 时间描述的类别分析 我将给予确切的年月日和时间的时间描述作为accurate类，如2020年1月1号；将模糊的时间描述作为fuzzy类，如早上、夜晚；将相对时间作为relative类，如明天、下个月。绘制饼状图如上所示。可以看到，准确描述的时间占了大多数，其他两类描述相对较少，但是依然不能忽略。 2.1.5 时间词起始位置的分布 可以明显地看到，绝大部分的时间词出现在句子的开头；而不在开头出现的时间词也大部分会在句子前三分之一位置出现；只有很少的时间词会出现在句子的后半段。 结合起始位置和长度的时间词分布图如下： 可以看出时间词的长度平均大约占句子长度的0.1~0.2左右。 2.1.6 时间词前后词的词性分析 时间词前一个词的词性分布 在进行统计前，我事先给每个句子的头部和尾部加上了head和tail的标签。可以看到，时间词前一个词以head标签为主。这与前面分析的时间词主要分布在句子开头的结论是相符合的。之后时间词的前一个词的最可能词性分别为动词、介词、名词和标点符号等。 时间词后一个词的词性分布 可以看到，时间词后最多的词性为动词。这是符合我们的语言习惯的，即“XX时候做XX”，而这恰好是本项目时间管理助手的期望输入形式。之后最多的词性分别为名词、地名、标点、介词等。其中地名即属于名词，标点为无效信息，因此我们将重点考虑时间词后的动词、名词、介词。这三类词性将作为后面进行基于句法分析的任务解析的重点。它们正好对应于我们期望从时间词后提取出的表示任务成分的动宾短语和介宾短语。 2.2 时间提取 2.2.0 为什么选择基于神经网络？ 通过上述对时间词的各种分析，我们知道，基于相对完善的正则表达式的匹配也可以匹配到九成左右的时间语句，那么为什么还要利用神经网络呢？ 这是因为，正则表达式只是对时间短语内部的表达形式的匹配，而不能表示出时间短语在句子中的位置信息以及与其他语句成分的关系。而从前面的分析我们可以知道，时间词在位置以及和前后词之间的关系中具有很重要的特征，这些特征是正则表达式所不能表达的，因此我们需要用神经网络来学习这些特征。 当一个时间词不在正则表达式的匹配范围内时，这个词一定不会被标注；而当一个时间词没有在语料库中出现过时，神经网络仍然有可能给这个词做上正确的标注，因为神经网络不仅学习到的是时间的表达，更重要的是能学到时间成分的上下文。这就是使用神经网络来进行时间提取的优势所在。 2.2.1 模型介绍 在本项目中，我选择的使用的模型为目前自然语言处理命名实体识别任务中比较主流的Bert + BiLSTM + CRF模型。本项目中的时间提取实质上就是一种简单的命名实体识别任务。 CRF模型 CRF（条件随机场）模型通过构造一组特征函数集(f1,f2,...)(f_1, f_2, ...)(f1​,f2​,...)来表示当前标注的“评分”，每个特征函数都会被赋予一个权重λi\\lambda_iλi​，综合所有特征函数得到的综合“评分”再进行softmaxsoftmaxsoftmax处理就能算出当前序列标注的正确概率。训练过程即为训练出最佳特征函数集和最佳权重的过程。预测过程即为选取正确概率最大的标注序列。具体而言： 特征函数的形式为 f(s,Wi,Li,Li−1)f(s, W_i, L_i, L_{i-1}) f(s,Wi​,Li​,Li−1​) 其中，sss为要标注的句子，WiW_iWi​为句子中的第iii个词或字符，LiL_iLi​表示第iii个词要标注的词性，Li−1L_{i-1}Li−1​表示它的前一个词要标注的词性。特征函数可以理解为是第 i−1i-1i−1个词在特征函数的作用下对第iii个词的影响，影响的正负结合权重将最终影响该标注的正确概率。 由特征函数集得到综合评分 score(L∣s)=∑j=1m∑i=1nλjfj(s,Wi,Li,Li−1)score(L|s)=\\sum^m_{j=1}\\sum^n_{i=1}\\lambda_jf_j(s, W_i, L_i, L_{i-1}) score(L∣s)=j=1∑m​i=1∑n​λj​fj​(s,Wi​,Li​,Li−1​) 其中，score(L∣s)score(L|s)score(L∣s)表示对句子sss进行用标注序列LLL进行标注的评分。内层求和为综合句子中每个单词标注的评分的过程；外层求和为结合权重λj\\lambda_jλj​综合每个特征函数评分的过程。 对综合评分进行softmaxsoftmaxsoftmax处理得到该标注的正确概率 P(L∣s)=softmax(score(L∣s))=escore(L∣s)∑L′escore(L′∣s)P(L|s)=softmax(score(L|s))=\\frac{e^{score(L|s)}}{\\sum_{L^{&#x27;}}e^{score(L^{&#x27;}|s)}} P(L∣s)=softmax(score(L∣s))=∑L′​escore(L′∣s)escore(L∣s)​ HMM（隐马尔可夫模型）是CRF的一个特例。相比于HMM，CRF能定义丰富的特征函数，并且权重也是没有限制的，因此CRF模型能提取出更丰富的特征。 BiLSTM模型 （本部分图片与知识来自参考文献 [1]） BiLSTM由前向LSTM和后向LSTM组合而成，因此我们需要先了解LSTM模型是什么。LSTM是RNN模型的一种。RNN（循环神经网络）是一类用于处理序列数据的神经网络模型，但由于它存在梯度消失的问题，无法处理长时间间隔的数据依赖。而LSTM则通过巧妙的门结构（遗忘门、记忆门、输出门）在一定程度上解决了梯度消失的问题，实现了“长期记忆”。 上图中，我们称绿色的大矩形框为一个单元；黄色矩形表示需要学习的神经网络层；粉色圆形表示运算操作；黑色箭头表示向量的传输，其中黑色箭头的合并表示向量的拼接，分开表示向量的复制。 LSTM的核心在于它在各个单元中维护并传递了一个细胞状态CtC_tCt​（如图所示横向黑箭头）。每当细胞状态CtC_tCt​经过一个单元时，它会依次受到单元中遗忘门、记忆门的影响而改变，然后还会通过输出门产生当前节点的输出向量hth_tht​。 遗忘门 遗忘门读取上一单元的输出ht−1h_{t-1}ht−1​和本单元的输入向量xtx_txt​，通过一个包含sigmoidsigmoidsigmoid函数的神经网络层输出0~1的数值ftf_tft​，表示之前的内容要记住多少。然后与细胞状态CtC_tCt​相乘即实现了遗忘之前状态的效果。 记忆门 记忆门同样读取上一单元的输出ht−1h_{t-1}ht−1​和本单元的输入向量xtx_txt​，但它输入分为两条经过两个不同的神经网络层。其中一条与遗忘门类似，经过sigmoidsigmoidsigmoid函数产生0～1的数值iti_tit​表示哪些部分是这次要学习的。而另一条通过一个包含tanhtanhtanh函数的神经网络层产生更新候选值Ct~\\tilde{C_t}Ct​~​。二者相乘得到的就是当前单元要新记忆的内容，然后与细胞状态CtC_tCt​相加即实现了记忆的效果。 输出门 输出门和记忆门是十分类似的，不同的地方是，它将包含tanhtanhtanh函数的神经网络层用于从细胞状态中产生输出候选值。sigmoidsigmoidsigmoid函数同样产生0～1的数值oto_tot​，这次表示输出候选中哪些部分是要作为输出的。二者相乘即产生了当前单元的输出向量hth_tht​。 LSTM虽然能很好地做到长期记忆，但是它只能捕获从前面到来的信息，而无法获得后面到前面的信息。在自然语言处理中，后向的信息也是很重要的。因此就有了我们在本项目会用到的BiLSTM模型。BiLSTM顾名思义，它是由一个正向LSTM神经网络和一个反向的LSTM神经网络构成的。通过将两条方向相反的LSTM神经网络的各单元输出结合起来，就能够充分地利用到上下文的信息，产生更好的输出结果。 Bert模型 （本部分图片与知识来自参考文献 [2]） 语言模型的预训练可以显著的提高许多自然语言处理任务的效果，现有的将预训练的语言模型应用到下层任务的方法有两种：基于特征和基于微调。其中，基于特征的例子有ELMo模型，它通过BiLSTM进行预训练，并将预训练的表示作为附加特征；基于微调的例子有OpenAI GPT模型，它通过Transformer编码器作为语言模型进行预训练，下层的自然语言处理任务在其基础上进行微调即可。 但是上述两种方法都没有进行或没有完全进行同时的双向计算，这给预训练的效果带来了很大的局限性。特别是像本项目这样的标记类的任务中，从两个方向同时分析上下文是至关重要的。因此我们考虑使用的是结合了两者优点又规避了两者缺点的Bert模型。Bert模型改进了基于微调的方法，采用的是多层的双向Transformer编码器： Bert模型主要实现了两个任务，分别是输入表示和预训练： 输入表示 Bert的输入表示可以是单个文本或一对文本，对于每一个词或字符，它的输入表示是通过三部分Embedding求和构造而成的： 其中，Token EmbeddingsToken\\ EmbeddingsToken Embeddings表示的是词向量，在本项目中，我们的时间标记是基于字的，因此这里将得到字向量；Segment EmbeddingsSegment\\ EmbeddingsSegment Embeddings用于进行两个句子输入时的区分，与本项目无关；Position EmbeddingsPosition\\ EmbeddingsPosition Embeddings表示的是位置信息，这在标记任务中是很重要的。 预训练 Bert模型进行了两种巧妙的预训练任务，分别为遮蔽语言模型（Masked LM）和下一句预测： 1. Masked LM简单来说就是在训练过程中，Bert会随机遮蔽每个输入序列中15%的标签，让模型来预测这些被覆盖的标签。这样学习到的表示能很好的融合左右两侧的上下文。 2. 下一句预测是针对一些需要建立两个句子文本之间关系的任务的预处理，简单来说就是输入多句文本时，输入的第二个片段会有50%的概率从全部文本中随机挑选，以此来训练连续性预测的能力。 Bert - BiLSTM - CRF 我们已经分别介绍了CRF、BiLSTM、Bert，将它们组合起来也是很简单的，即给BiLSTM模型增加基于Bert的Embedding层，然后再在BiLSTM的最后加入一层CRF线性层。 Bert的强大的预训练效果就不说了，BiLSTM能结合前后上下文给每一个输入字计算出它所有可能的标记的正确概率，CRF能在这些概率的基础上，保证结果的有效性。具体而言，CRF基于前后标注的特征函数让它能学习到各个标签的相邻关系，从而能比较有效地解决标注无效的问题。比如在本项目中，“B-TIME O I-TIME”就是一个无效的时间标注，因为I-TIME标注不应该跟在O标注的后面。 2.2.2 训练相关参数与训练结果 字数 B-TIME I-TIME O 训练集 86145 2166 9602 74377 验证集 11199 281 1213 9705 测试集 16946 439 1852 14655 Bert模型使用的是Google开源的中文预训练模型chinese_L-12_H-768_A-12（链接见参考文献 [4]）： Layer-num Hidden-size Heads-num Parameters BERT-Base, Chinese 12 768 12 110M 其他参数： 输入维度sequence_length batch_size epochs 128 16 20 训练后通过测试集得到的模型评估结果如下： 2.2.3 三种不同模型的对比 精确度 召回率 F-度量值 BiLSTM 0.6938 0.7426 0.7174 BiLSTM-CRF 0.7035 0.7370 0.7198 Bert-BiLSTM-CRF 0.8584 0.9070 0.8820 可以看到Bert预处理模型显著地提高了训练的效果，预测精确度将近86%，召回率达到90%左右。相比没有Bert预处理的模型均提高了16%左右。 而使用BiLSTM和BiLSTM-CRF的训练效果相差不大，且都不是很好。 2.2.4 标注效果 我们用下面这个复杂的例句来分别检测一下三种模型的实际标注效果： 明天上午8:15去饭堂吃早餐，下午1:30上课，晚上写pj，周二之前做完pj，然后开始写实验报告，从12月5号到12月20号进行总复习，23号开始考试，3天后继续复习功课。 BiLSTM 标记结果： 对应抽取的时间成分为： 其中蓝色代表正确标记，黄色代表多余标记，红色代表遗漏标记。 BiLSTM-CRF 标记结果： 对应抽取的时间成分为： Bert-BiLSTM-CRF 标记结果： 对应抽取的时间成分为： 可以看到，单独的BiLSTM模型或BiLSTM-CRF模型虽然能大致找到时间成分的位置，但是标记的精细程度较差，不能准确的区分时间成分的边界。并且都有遗漏标记的情况。这就是这两个模型精确度和召回率较低的表现。 而Bert-BiLSTM-CRF模型在时间标记上做得相当好，不仅找全了所有的时间成分，并且每个成分都做到了精准标注。这样的结果是让人满意的。 为了避免偶然情况，我多测试了几个句子，结果如下： 可以看到训练出的Bert-BiLSTM-CRF能正确处理绝大部分句子的时间成分提取，但也依然有极个别时间无法完整获取，比如上面的“下下下下下下”。 这是由于数据集中没有包含像这样这么长的相对时间描述，并且这样的连续重复的字符干扰了神经网络对语义的分析。考虑到一般用户不太会使用这样的长相对时间描述进行任务安排，因此我认为这类型时间描述的漏判是可以容忍的。总体而言，利用Bert-BiLSTM-CRF模型提取时间成分的效果已经足够好了。 2.3 时间与任务的一一配对 在前面我们已经成功地利用神经网络从很长的自然文本中准确地标记出了时间成分，接下来我们就要利用这些标记将句子中的时间成分和任务成分分离、配对。 以上图的句子为例，根据标注序列，我们可以轻松地提取出句子中蓝框所示的时间成分，考虑到本项目处理的是任务安排类的自然语言文本，因此我们认为除了时间成分之外的部分即为任务成分。 接下来我们要考虑的就是时间和任务的配对问题。我们考虑以下几个命题： 时间和任务表达总是间隔分布的 如果我们将时间的表达放一起，任务的表达放一起，则语句变为： 明天和大后天学习、放假 这时表达中就会出现歧义：是明天和大后天分别进行学习和放假呢？还是明天和大后天每天都要学习+放假呢？由于在进行任务时间安排时，我们是没有语境的，因此我们没有办法通过分析语境来消除这一类的歧义。因此我们不考虑这类有歧义的表达，即我们认为时间和任务的表达总是间隔分布的。 时间和其对应的任务总是相邻的 这里的“相邻”指的是两个成分之间没有其他的时间成分。 这个结论是显然的，当我们做出“明天学习，大后天放假”的安排时，我们不会将“明天”关联到与其不相邻的“放假”上，因为它们中间存在“大后天”这一个时间成分，因此“放假”这一任务成分只可能从属于“大后天”，而不可能从属于在位置上离得更远的“明天”。 一组对应的时间和任务总是时间在前，任务在后的 我们在一开始进行的数据分析中提到了，时间成分绝大多数分布在一个句子的前半部分。另一方面，由于本项目考虑的仅为任务安排类的自然语言，说出任务在前、时间在后的表达是不符合语言习惯的： 学习明天，放假大后天 方便起见，我们不考虑这样奇怪的表达方式。 至此，我们就找到了将时间与任务成分一一配对的方法：每个时间成分从它紧接着往后的地方开始，一直到碰到下一个时间成分之前为止，将这样一段语句作为这个时间对应要安排的任务成分。 这时提取出的任务成分显然是不纯的，比如在这个例子中，明天的任务成分为“学习，”；另一方面，一个任务成分中可以包含多个任务，比如“明天看课本、写报告”，任务成分中包含了“看课本”“写报告”两个任务实体，我们需要将它们拆分开来。以上的问题就需要通过任务解析器来解决。 2.4 任务解析 2.4.0 为什么选择基于句法分析？ 我们在报告开头提到，像jieba分词等大部分分词工具并不能很好的处理时间词的划分，但它们在其他词性上（如动词、名词、介词等）的标注和划分还是做得很好的。在任务解析中，我们已经分离出了时间成分，因此在这里分词工具就能产生比较准确的词性标注效果。 有了词性标注的正确性保证，就能使用句法分析来构建任务成分的句法分析树，从而从树中解析出任务成分中的多个有效任务实体。 2.4.1 文法的设计与动态生成 文法的基本设计与优化策略 在前面数据分析中提到，我们重点关注任务成分中的动词、名词、介词，因此我们的文法也以这三种词性为中心构建。我们将使用VP、NP、PP、V、N、P这六种常见词性，同时，针对本项目的任务表示问题，我定义了以下4种新结构类型： 结构名 解释 VPS 由多个VP组成的结构，这也是我们期望的句法分析树的根节点 VP1 不包含介词结构的动词短语 VP2 包含介词结构的动词短语 VP1S 由多个VP1组成的结构 这里实际上是将VP分为了VP1和VP2两类，为的是分别处理有介词和无介词的情形。例如，在“在寝室写作业、吃饭和睡觉”这个结构中，“吃饭”和“睡觉”也是在“寝室”中进行的，因此我们不希望将它们与“写作业”分开；而如果没有介词结构的影响，我们则希望将它们分开。 而定义VP1S来区分VPS是为了简化树的结构，即不考虑一个结构中包含多个介词结构的情形。通过后面的文法定义就可以看出。 我们以下面这个任务成分为例，引入本项目文法的定义： 去教室上课，然后在寝室写作业、吃饭和睡觉 进行jieba分词后，抽取我们关注的动词、名词、介词如下： 去(V) 教室(N) 上课(V) 在(P) 寝室(N) 写(V) 作业(N) 吃饭(V) 睡觉(V) 为了能保证生成有效的句法分析树，本项目使用的是递归下降的分析算法。由于需要分析的任务成分一般较短，因此效率上的缺陷无需担忧。设计的文法如下： VPS -&gt; VP | VP VP | VP VP VP | VP VP VP VP | VP VP VP VP VP VP1S -&gt; VP1 VP1 VP1 VP1 VP1 | VP1 VP1 VP1 VP1 | VP1 VP1 VP1 | VP1 VP1 | VP1 VP -&gt; VP2 | VP1 VP2 -&gt; PP VP1S VP1 -&gt; V VP1 | V NP | V NP -&gt; Det N | N N | N PP -&gt; P NP P -&gt; '在' N -&gt; '教室' | '寝室' | '作业' V -&gt; '去' | '上课' | '写' | '吃饭' | '睡觉' VPS的分解即表示将任务成分分解为多个动词结构的任务实体，从少量到大量进行排序是为了让递归下降法首先找到能让介词结构包含多个动词成分的情况。比如，要找到（VP 在寝室写作业、吃饭、睡觉）而不是（VP 在寝室写作业）（VP 吃饭）（VP 睡觉）。 VP简单的分为VP1和VP2两种情形。 VP1 -&gt; V VP1考虑的是连续两个动词成分在语义上不可分割的情形，这在任务表达中比较常见。比如继续（V） 学习（V）应该被分析为（VP 继续学习）而不是（VP 继续）（VP 学习）；而VP -&gt; V NP | V考虑的就是常见的动宾短语和纯动词成分。 VP2 -&gt; PP VP1S表示带介词的动词结构由一个介宾短语和后面跟着的若干个动词成分构成，（VP2 在寝室写作业、吃饭、睡觉）就是典型的例子；这里将后面的动词成分限制为VP1就是不考虑后面的动词部分还存在介词的情形，这样的表达在任务成分中实际上也是不存在的，因为在寝室写作业，在桌子上吃饭、睡觉显然应该被分析为（VP2 在寝室写作业) （VP2 在桌子上吃饭、睡觉）两个成分；另外，这样考虑也能减少递归算法的递归次数，从而提高效率。 VP1S的分解是从大量到少量来排序的，这是为了将VP2结构中的动词成分尽可能的并列存放，因为它们显然是并列关系。 NP -&gt; N N考虑了两个连续名词构成一个名词的情况，这种情况也比较常见。比如，牛肉（N）火锅（N）应该被当做一个完整的名词结构（NP 牛肉火锅）。 以上对文法中结构的内容和排序上的细致规定，实际上都是对递归下降法的优化策略。通过这些优化策略，递归下降方法就能首先找到我们期望的句法分析结构，因此当找到第一个句法分析树后，就可以直接停止算法，从而提高分析效率。 例句通过以上文法生成的句法分析树如下： 可以看到我们设计的文法很好地分析出了句子的结构。唯一比较令人在意的是“去教室上课”这个短语被分为了“去教室”和“上课”两个不同的动作，在这里实际上是动词结构的划分细致程度超过了我们的预期，不过对于任务的表达影响不大，因此我认为是可以接受的。 动态生成方法 对于不同的任务成分，我们显然需要对文法内容进行相应的修改，因此这需要我们动态地生成文法。动态生成的部分实际上只有两部分： P、N、V三种词性的文法。这里就需要我们在进行句法分析前，首先对任务成分进行分词和词性标注，然后将相应的词性指向具体的词。 VPS、VP1S的分解数量上限。显然VPS和VP1S的分解数量不可能超过任务成分中动词的数目，因此这就需要我们在进行词性标注的同时统计动词的数目，从而确定分解数量的上限，以便生成具体文法。 2.4.2 解析效果 得到句法分析树后，就可以从树中第二层的VP节点解析出相应的任务实体。一个VP节点即代表一个任务实体。 第一个输入即为例句，后面两个输入对应的句法分析树依次如下： “找东西吃”和例句中的“去教室上课”一样，被分成了“找”和“吃”两个动作，这对任务的表达影响不大。 2.5 时间解析 2.5.0 为什么选择基于正则表达式？ 我们前面提到，正则表达式无法提取出时间成分与上下文之间的关系，因此我们选择使用神经网络来进行时间成分的提取。而现在时间成分已经提取出来了，已经不在需要考虑上下文的联系了，因此这时运用正则表达式就能得到很好的效果。另一方面，由于我们解析的文本范围缩小到了时间，因此编写正则表达式时不需要考虑非时间文本的干扰，这样一来正则表达式的编写将比较简单。另外，人们公认的时间表达方式总是有限的，因此完善的正则表达式总能匹配到绝大部分的时间表达。 2.5.1 时间解析的目标和规定 时间解析的目标为：将用自然语言表达的时间成分转化为标准时间。比如： 2019年12月1日下午3点一刻 2019/12/01 15:15 明天早上到晚上8点 2019/12/02 09:00 ~ 2019/12/02 20:00 在本项目中，考虑到我们要做的是时间管理助手，因此我们规定 最小的时间处理粒度为分钟。因为秒级的任务意义不大。 只考虑未来的时间。因为过去的时间根本没有安排任务的必要。 用户输入的时间成分不会出现矛盾冲突。 有了以上三条规定约束，用正则表达式解析时间能方便不少。 2.5.2 时间解析总框架 首先未解析的时间成分先进入节日节气转换器，将自然语言中的节日、节气表达转化为确切的时间 然后进入时间段判断器判断是否为时间段的表达，若是时间段则需要对时间段的首尾时间都进行解析 之后获取系统当前时间作为基准时间，然后分别进入三种正则表达式解析器依次从时间文本中解析出确切时间、模糊时间、相对时间 每当解析出一个时间层次，就覆盖基准时间中相应的时间层次。比如若基准时间为2019/12/01 23:00，当解析出日数为“3日”时，则覆盖基准时间的日数层次，变为2019/12/03 23:00，其它层次同理。 相对时间也是根据基准时间进行计算的。比如解析出“明天”，则覆盖基准时间，变为2019/12/02 23:00。 最后更新完成后的基准时间即为时间文本所要表达的规范化时间。 简而言之，就是通过维护一个初始值为系统当前时间的“状态时间”TTT 来计算出最终得到的时间，该时间就是时间成分所要表达的规范化时间。 正则表达式解析完毕后进入隐含义处理器，根据得到的解析结果判断是否存在隐含义表达，若有则对解析结果进行相应更正 最后进入变化检测器 若得到的规范化时间与初始的系统基准时间完全一样，说明并没有从时间文本中解析出有效时间，此时即为解析失败，需要进入容错机制模块与用户进行交互。（容错机制并不是自然语言处理的部分，因此还未实现，将作为未来工作） 若得到的时间与基准时间不同，说明有从时间文本中提取到有效时间，此时从时间解析器中输出规范化的时间并显示到日历中。 2.5.3 关于缺省处理机制和继承机制 从上面的时间解析器框架中可以知道，本项目中时间解析是通过维护“状态时间”TTT 进行的，根据解析的结果对 TTT 进行相应的覆盖更新。通过这样的方式解析时间实际上是为了实现时间表达的缺省处理机制和继承机制。 缺省处理机制 当用户给出时间安排时，会以当前时间作为“上下文”，这个上下文缺省表达了一些信息。比如： 26号考自然语言处理 实际上缺省表达了年份、月份，即完整语义为“2019年12月26号”考自然语言处理。 但对于时、分，我们不考虑缺省处理。因为当用户没有提及时、分时，是因为不需要具体安排到小时或分钟，而不是一种缺省表达。 继承机制 继承机制有点类似缺省机制，但它是发生在前后时间描述的一种缺省。比如： 12月26号早上9:55到11:35考自然语言处理 这里时间段的尾时间会继承首时间的表达。具体而言，这里的尾时间会继承首时间中的“12月26日早上”，即尾时间的完整语义为“2019年12月26号早上11:35”。 10月1号放假，7天后开学 在这个例子中，“7天后”继承了上一时间描述的上下文，即是“10月1号的7天后”，而不是“当前时间的7天后”。 上述的两种情况，通过框架中维护的状态时间 TTT 都得到了解决。这样看来，这个状态时间 TTT 类似于LSTM神经网络中的细胞状态 CtC_tCt​，它们都起着联系上下文的作用。 2.5.4 节日、节气处理器 节日的转换 节日的转换比较简单，通过一个节日表直接进行替换即可。举例如下： &quot;元旦&quot;: &quot;01-01&quot; &quot;春节&quot;: &quot;01-01&quot; &quot;元宵节&quot;: &quot;01-15&quot; 节气的转换 节气的转换需要计算。24个节气中，每个节气的月份是固定的，关键是要计算该节气在今年是几号。 日号计算公式： day=[YD+C]−Lday = [YD + C] - L day=[YD+C]−L 其中，Y=年份的后2位Y=年份的后2位Y=年份的后2位、D=0.2422D=0.2422D=0.2422、L=闰年数L=闰年数L=闰年数、CCC取决于节气和年份。其中还有部分年份需要特殊考虑，这里不做过多介绍。 2.5.5 正则表达式解析器 （正则表达式的书写部分参考了参考文献 [5]） 对时间段的解析 正则表达式 匹配示例 (.+)[至到~](.+) 从12月2号到5号 若时间成分中存在“至”“到”“~”字符，则该时间成分为时间段。由于数据清洗阶段已经将符号转化为了半角，因此不需要考虑“～”字符了。 对确切时间的解析 提取汉字表达的确切时间 正则表达式 匹配示例 备注 [0-9]{4}(?=年) 2019年 提取几年 (10|11|12|[1-9])(?=月) 12月 提取几月 (周|星期|礼拜)([1-7]) 周1 提取周几 ([0-3][0-9]|[1-9])(?=(日|号)) 2日 提取几号 ([0-2]?[0-9])(?=(点|时)) 2点 提取几时 ([0-5]?[0-9](?=分(?!钟))) 18分 提取几分 (?&lt;=[点时])1刻(?!钟) 2点1刻 1刻 解析为 15分 (?&lt;=[点时])半 2点半 半 解析为 30分 (?&lt;=[点时])3刻(?!钟) 2点3刻 3刻 解析为 45分 提取XX:XX表达的确切时间 正则表达式 匹配示例 表示的时段 (晚上|晚|今晚|夜间|夜里|下午|午后)([0-2]?[0-9]): ([0-5]?[0-9]) 晚11:30 午后 ([0-2]?[0-9]): ([0-5]?[0-9])(PM|pm|p.m) 2:30pm 午后 ([0-2]?[0-9]): ([0-5]?[0-9]) 2:30 午前 其中前两行为处理“午后XX:XX”的情况，在这种情形下，需要将小于12的时数增加12，变为24小时制； 在前两行都未匹配上的情形下，剩下的能匹配上第三行的即为“早上XX:XX”的情况，这种情形不需要改变数值。 提取简易表达的确切时间 正则表达式 匹配示例 备注 ([0-9]{2,4})([-./])(10|11|12|[1-9])([-./])([0-3][0-9]|[1-9]) 2019-12-2 年月日 (10|11|12|[1-9])([-./])([0-3][0-9]|[1-9]) 12/2 月日 第一行匹配的是“2019-12-2”“2019.12.2”“2019/12/2”这样的简易表达； 第二行匹配的是“12-2”“12.2”“12/2”这样的简易表达。由于当前处理的仅为时间成分，因此不需要考虑“12.2”与小数12.2的歧义。这就是先用神经网络提取时间成分带来的便利。 对模糊时间的解析 先以匹配到凌晨时段的模糊时间表示为例 当匹配到凌晨时，分两种情况处理： 确切时间解析器中没有解析到“几时” 这时需要缺省赋值，将几时的时间赋值为0。这是必要的，因为在规范化的时间表示中，只有通过“X时”来才能表示出“凌晨”这一信息，这就是模糊时间表达的作用。类似的，后面的“早晨”“上午”“下午”等都会有相应的缺省赋值。 确切时间解析器中解析了“几时” 这时不需要缺省赋值，但需要进行规范化的判断。当时数为12~23时，我们需要将时数减12。因为当用户提到“凌晨13时”时，指的实际上是“1时”。 各个模糊时段的时间处理 时段 正则表达式 缺省赋值 时间调整 凌晨 (凌晨|黎明) 0时 时数为12~23时，将时数减12 早晨 (早上|早|今早|早间|早晨|清晨) 6时 时数为12~23时，将时数减12 上午 (上午|am|AM|a.m) 9时 时数为12~23时，将时数减12 中午 (中午|午间|白天) 12时 时数为0~4时，将时数加12 下午 (下午|午后|pm|PM|p.m) 15时 时数为0~11时，将时数加12 晚上 (晚上|晚|今晚|夜间|夜里) 21时 时数为0~12时，将时数加12 晚上的时间调整中，当时数变为24时时，要再变为0时，因为规范化时间中没有24时。 对相对时间的解析 XXX时间之后 正则表达式 匹配示例 粒度 \\d+(?=多?年[以之过]?后) 1年之后 年 \\d+(?=多?个?月[以之过]?后) 1个月之后 月 \\d+(?=多?个?(周|星期|礼拜)[以之过]?后) 1个礼拜后 周 \\d+(?=多?天[以之过]?后) 1天后 天 \\d+(?=多?个?多?(小时|钟|钟头|时辰)[以之过]?后) 1个小时后 时 半(?=个?多?(小时|钟|钟头|时辰)[以之过]?后) 半个钟后 时 \\d+(?=多?分钟[以之过]?后) 1分钟后 分 半(?=分钟[以之过]?后) 半分钟后 分 \\d+(?=刻钟[以之过]?后) 1刻钟后 分 以上为从大到小各个粒度时间的“XXX时间之后”的相对时间的表达。利用正则表达式考虑了“以后”“之后”“过后”三种表达，并忽略掉“多”“个”等语言习惯词。其中“时”“分”的层面要考虑“半”和“刻钟”的表达。 明X、后X、下个XX 正则表达式 匹配示例 粒度 明年 明年 年 后年 后年 年 下+个?月 下下下个月 月 (下+个?(周|星期|礼拜))([1-7]?) 下下下下个周五 周 明天?(?!年) 明 天 (?&lt;!大)后天 后天 天 大+后天 大大大大大后天 天 以上为从大到小各个粒度时间的“明X、后X、下个XX”的相对时间的表达。同样利用正则表达式忽略掉“个”等语言习惯词。比较有趣的是，这里通过解析“下”字或者“大”字的个数来推算需要将时间往后增加多少个月、多少个周或多少天，虽然前面提到过，神经网络并不能识别出“下”字或者“大”字过多的时间表达。 2.5.6 时间隐含义处理器 跨年带来的隐含义 当用户指定了一个过去的月份的时间时，实际上是指明年的月份。比如： 在2019年12月时，用户做出“1月放假”的安排时，指的是2020年的1月放假。 跨月带来的隐含义 当用户指定了一个当月过去的日期时，实际上是指下个月的日期。比如： 在2019年11月25日时，用户做出“1号写报告”的安排时，指的是12月1号写报告。 跨周带来的隐含义 当用户指定了一个当周过去的日期时，实际上是指下周的日期。比如： 在周五时，用户做出“周一上课”的安排时，指的是下周一上课。 跨日带来的隐含义 当用户指定了一个当天过去的时间段时，实际上是指明天的时间段。比如： 在晚上，用户做出“早上吃早餐”的安排时，指的是明天早上吃早餐。 上述的这四个隐含义在我们的生活中是很普遍的，但是我们时间解析器的基于维护状态时间 TTT 的算法正好无法处理这样的隐含义，因此才需要单独设置本模块来专门检测隐含义并对状态时间 TTT 作出相应更改。 检测方法是显然的，当解析出的状态时间 TTT 要早于系统当前时间时，就说明存在没有被处理的隐含义。 这时按照时间粒度从大到小逐个进行判断，当判断出为跨年带来的隐含义时，就把状态时间TTT的年数加1，其他隐含义的处理方式类似。 2.5.7 时间变化检测器 当检测到状态时间 TTT 和系统当前时间完全一致时，说明时间解析器没有解析出任何时间， 此时为解析失败； 当检测到状态时间 TTT 和系统基准时间存在不同，而时、分是相同时，说明用户没有提供时、分这样细粒度的时间安排，这时我们将不输出时、分；而当相同的部分为年、月、日时，我们则依然需要将年、月、日输出，因为这是缺省机制带来的信息，需要保留。 2.5.8 解析效果 2.6 项目界面设计 本项目的界面设计通过PyQt5实现，主要分为三个模块：人机交互模块、日历模块、任务列表模块 人机交互模块 用户可以像发送聊天消息一样发送任务安排文本，时间管理助手接收到文本后进行时间解析、任务解析，然后同样以聊天消息的方式将任务安排列表发送给用户，供用户查看解析结果是否正确。除了发送回复消息，时间管理助手还会将任务安排更新到日历模块和任务列表模块上。 日历模块 当出现新的任务时间安排时，日历上相应日期上的数字会变蓝，并出现下划线，表示当天有待办任务。点击日历上的日期，任务列表模块会显示出当天有哪些任务。 任务列表模块 显示日历所选中的日期的当天任务安排。当用户安排了某项任务的时间具体到时、分时，任务列表上会显示出具体的时、分时间。每条任务前有一个勾选框，当用户完成了该项任务时，可以通过勾选对应任务来表示任务的完成。完成的任务会从任务列表中消失。 具体的界面展示在下面给出。 3 项目总展示 非UI形式输出举例 UI形式输出展示 启动时后台开始加载神经网络模型，需要一定时间 用户从输入框中输入任务安排语句 程序解析语句并展示提取的任务时间信息、更新日历 用户可以连续输入多段任务安排，任务安排将在日历上累加；用户点击日历上的相应日期可以查看当前的待办任务 用户可勾选已完成的任务，已完成的任务将在列表中消失，然后交互界面将产生任务已完成的信息 4 未来工作 增加容错机制。对于正则表达式无法解析的时间成分，通过人机交互模块对用户进行询问。 增加数据库存储。实现任务时间安排的长时存储。 增加任务提醒机制。定时向用户提醒将要到期的任务。 增加语音输入功能。尝试为项目增加语音输入接口，从而升级为语音助手。 5 项目感想与总结 在本项目的实施过程中，我不仅运用了神经网络的方法，也运用了一些非神经网络的方法（正则表达式、句法分析），在各方面都学习到了许多。首先在神经网络方面我了解了很多流行的模型的具体原理，比如bert模型，对一些常见模型也有了更加熟悉的掌握，比如LSTM模型；在正则表达式方面，我能够写出许多比较复杂的表达式了，并且也能够思考出写正则表达式时需要考虑的种种细节，而句法分析方面，实际上是在期末前上课学习到后，发现可以运用到本项目中，于是才在后来添加上的方法。 在项目开始之前，原本觉得这个任务应该算是比较简单的，但是开始做了才发现有许多细节和难点需要考虑，于是就尝试不同的方法一个步骤一个步骤的去实现、解决，所以就逐渐形成了整个项目最后这样一个比较复杂的实现框架。从最终效果来看，还是挺好的。由于时间关系，许多与自然语言处理无关的部分还没有全部完善，比如上述未来工作的前三点，至于升级成语音助手的未来工作，在将来有时间时一定要尝试一下，因为实现之后感觉这个项目就更酷了。项目做得比较复杂，所以报告也写得比较啰嗦，挺抱歉的，辛苦老师阅读了。 6 运行方法与代码文件说明 运行环境：ubuntu 18.04 python3 运行指令 非UI方式启动： python3 Main.py UI方式启动： python3 App.py 文件列表 文件或文件夹名 简要说明 /Css UI渲染需要用到的html文件与图片 /Data 数据集与数据分析结果 /Model 神经网络模型 config.ini 配置文件，描述数据集路径与神经网络模型路径 App.py UI界面的设计代码 Main.py 主代码，分离时间、任务成分，调用各部件 Dictionary.py 数据清洗与时间预处理相关的映射字典 DataAnalyzing.py 数据分析相关的代码 TextPreprocessing.py 时间预处理相关代码 Predict.py 调用神经网络实现时间标注的相关代码 ThingsDividing.py 通过句法分析实现任务解析的相关代码 TimeParsing.py 通过正则表达式实现时间解析的相关代码 Train.py Bert-BiLSTM-CRF模型训练代码 Evaluate.py 模型评估代码 由于训练好的神经网络模型较大（400M左右），因此将其上传至了百度云盘 链接 密码: cll8 7 参考文献 [1] Christopher Olah.Understanding LSTM Networks[EB/OL]. https://colah.github.io/posts/2015-08-Understanding-LSTMs/ [2] Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova. 2019. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. arXiv:1810.04805v2. [3] Project webpage. https://github.com/percent4/Chinese_Time_Recogniztion/tree/master/data [4] Project webpage. https://github.com/google-research/bert [5] Project webpage. https://github.com/wbq813/TimeRec * * * FinFin Fin Github源码 求⭐️~ ","link":"https://river861.github.io/post/todo-helper-shi-jian-guan-li-zhu-shou/"},{"title":"WeTalk 简易聊天室","content":"顾名思义，一个简单的多人聊天室程序，计算机网络PJ。 一、项目基本聊天功能展示 运行环境：Ubuntu 18.04、Python 3.6、PyQt5 运行指令： 服务端启动：python server.py 客户端启动：python WeTalk.py 输入进入聊天室所用的昵称然后回车进入 第一个进入聊天室的用户将会被提示成为群主(Group Leader)。 主界面主要分为四部分：上方工具栏，包含该聊天室的各种功能；中部消息框，用于显示用户发送的即时消息；右方用户栏，用于显示当前加入的所有用户的昵称；下方输入框，用于本用户输入并发送消息。 在输入框中输入信息开始愉快的聊天！ 支持多人聊天。聊天消息会在消息框中渲染出气泡效果。支持中英文。 二、项目架构介绍 1. 服务端 1 + 2n 线程 主线程 监听连接请求，每收到一个客户端连接则分配一个Server类对象服务之。每个Server类对象会启动两个线程，一个receiver线程和一个sender线程，分别负责信息的接收和信息的发送。 while True: conn, addr = s.accept() print(f'new connection: addr={addr}') _ = Server(conn, addr) receiver线程 接收所连接的那个用户的所有请求。由于是端到端的连接，因此这里每个receiver只会接收到单个用户的请求信息，其他用户的请求信息会由它们专属的server对象的receiver线程接收和处理。 接收到消息后，首先根据消息的“头部”进行分类，具体的分类将在之后给出。大体分为两类： 群发请求 receiver接收到群发信息后，对服务端本地的全局数据缓冲池进行更新。利用缓冲池的全局性来让其他用户的server能探测到该用户做出的改变。根据消息具体所属类型的不同，会更新服务端不同的数据缓冲池或做出其它操作。缓冲池类型将在介绍具体功能时分别给出。 单发请求 receiver接收到单发信息后，对该server对象自己所维护的局部变量进行更新。对象内部变量的局部性让其它server探测不到该单发信息，从而实现该用户请求的隐蔽性。比如该用户下载文件的请求即为单发请求，sender只会将文件发给发出了请求的用户，而不是群发。 def update_buf(self, text): '''更新全局的数据缓冲池 ''' global msg_buf, msg_num, msg_lock, logIO_buf, logIO_num, logIO_lock ............ mark = text[:mark_len] text = text[mark_len:] ............ receiver会将收到的字符串信息传入上述函数，该函数首先从字符串中截取头部mark，之后将通过mark的不同对不同的全局缓冲池或局部变量进行更新。 sender线程 群发信息 需要群发给所有用户的信息，即为全局缓冲池中发生改变的信息。sender将这些改变发送给它所服务的客户端，这样一来n个sender线程的总体效果就是将全局缓冲池的变化“群发”给了n个不同的客户端。通过receiver改变全局变量，再通过sender将全局变量的改变群发出去，这就是该简易聊天室的基础原理。 while True: try: with logIO_lock: # 用户IO信息的群发，服务端并不需要知道有哪些用户，只需要转发用户进出的信息 while self.__next_logIO &lt; logIO_num: self.__send_UTF8(USER + logIO_buf[self.__next_logIO] + END) self.__next_logIO += 1 with msg_lock: # 群发消息的群发 while self.__next_msg &lt; msg_num: self.__send_UTF8(MSG + msg_buf[self.__next_msg] + END) self.__next_msg += 1 ....... 我们以用户IO消息为例。logIO表示用户login和logout的信息。其中logIO_buf、logIO_num、logIO_lock为全局变量，分别表示logIO信息的存储缓冲池、logIO信息的当前接收数量、logIO_buf对应的互斥锁。self.__next_logIO为该对象所维护的局部变量，表示该对象所负责的客户端已经接收的logIO数量。当self.__next_logIO&lt;logIO_num时，表示该客户端上的信息比服务端的旧，需要更新，于是就会发送需要发送的下一条新的logIO，直到客户端的信息数量和服务端一致。互斥锁的目的是防止sender线程和receiver线程对logIO_buf的访问冲突。 以服务端的全局缓冲池作为标准，更新各个客户端的缓冲池，是本项目群发的具体实现方式。 单发信息 单发消息较为简单，只需要通过检查局部变量是否发生了改变，若发生了改变，则发送给客户端即可。由于该局部变量只为该server所有，因此完全不会影响到其它server信息的发送。 2. 客户端 1 + 2 线程 主线程 GUI界面的响应线程，负责响应用户对程序界面的操作，并根据操作的具体内容进行相关函数的执行。本项目的GUI界面通过PyQt5 + html渲染实现。 receiver线程 与服务端receiver线程类似，该线程接收所有发送给该客户端的信息，并根据信息类型更改客户端本地的全局缓冲池或全局变量。这里使用全局变量是为了能让GUI模块探测到信息的变化，从而刷新界面。由于客户端不需要考虑对其它客户的影响，因此比较简单，全部改变通过维护本地全局变量来体现即可。 def update_buf(self, text): # 转存数据到本地全局变量就好了 '''更新客户端本地数据缓冲池 ''' global msg_buf, msg_num, msg_lock, logIO_buf, logIO_num, logIO_lock ............ mark = text[:mark_len] text = text[mark_len:] ............ receiver根据收到的信息头部mark来判断需要进行的更新操作，然后更新到全局变量中即可。 refresher线程 该线程专门用来探测客户端本地全局变量是否改变，若改变，则刷新相应的界面组件。实现方式是QTimer()，即定时探测。 # 起refresher线程 self.timer = QTimer() self.timer.timeout.connect(self.__refresh) self.timer.start(20) 本项目设置为每20毫秒进行一次刷新，即调用self.__refresh()函数 下面同样以logIO信息的刷新来简单说明一下刷新的实现方法： def __refresh(self): ''' refresh线程（由Qtimer维护） ''' global logIO_buf, logIO_num, logIO_lock ........ try: with logIO_lock: while self.__next_logIO &lt; logIO_num: opera = logIO_buf[self.__next_logIO] if opera[0] == '+': self.main_widget.userlist_widget.add(opera[1:]) elif opera[0] == '-': self.main_widget.userlist_widget.delete(opera[1:]) self.__next_logIO += 1 .......... 和服务端运用的是类似的方法。GUI自己维护一个用来表示上一次刷新到的信息的位置self.__next_logIO，然后将其与全局变量logIO_num进行比较，由此判断是否需要刷新用户列表。若需要，则调用用户列表组件userlist_widget的相关函数进行用户的增减，从而实现界面的更新。 顺便一提，无论是客户端全局还是服务端全局实际上都只储存了用户进出的信息，真正的用户列表实际上只储存在了userlist_widget组件中。 3. 通过加密算法实现安全传输 Diffie-Hellman 密钥交换 客户端： # 大素数p 原根g 秘钥a 公开秘钥A p = 1945555039024054273 g = 5 a = None A = None # 共享秘钥K 加密时要用到的初始化向量IV K = None IV = None 客户端初始持有一个大素数及其原根。一般来讲，大素数要求达到100位以上才能保证安全性，这里仅做模拟，以一个18位的素数为例。5为该素数的一个原根。 # 建立连接 conn = socket.socket() conn.connect((self.host, self.port)) # 开始交换秘钥 a = random.randint(0, p - 1) A = pow(g, a, p) # 计算公开秘钥A # 发送 g, p, A给服务端 conn.sendall(bytes(KEY + str(g) + DIV + str(p) + DIV + str(A) + END, encoding='utf-8')) 在客户端刚刚与服务端建立连接之后、启动接收线程和界面之前，进行密钥交换流程。 首先客户端产生随机数a(a&lt;p)a(a &lt; p)a(a&lt;p)，然后计算出客户端的公开秘钥A=ga mod pA=g^a\\ mod\\ pA=ga mod p ，计算完成后将g、p、A发送给服务端。 服务端 # 公开秘钥B 共享秘钥K 初始化向量IV self.__B = None self.__K = None self.__IV = None 服务端为每一个客户端都专门创建了相关的参数用于存储加密相关的秘钥和参数。 def __recv_key(self): recv_text = '' while True: recv_text += str(self.__conn.recv(4096), encoding='utf-8') index = recv_text.find(END) if index != -1: break start = recv_text.find(KEY) text = recv_text[start + mark_len: index] gpA = text.split(DIV, 2) g, p, A = int(gpA[0]), int(gpA[1]), int(gpA[2]) b = random.randint(0, p - 1) self.__B = pow(g, b, p) # 计算公开秘钥B self.__K = pow(A, b, p) # 计算出共享秘钥K self.__IV = str(self.__K)[-16:] self.__K = str(self.__K)[:16] 收到客户端发送的g、p、A后，服务端计算其针对于该用户的公开秘钥B=gb mod pB=g^b\\ mod\\ pB=gb mod p 和共享秘钥$K=A^b\\ mod\\ p $，计算完成后，服务端再将其计算出的公开秘钥B单发给客户端。 客户端收到后也能计算出共享秘钥K=Ba mod pK=B^a\\ mod\\ pK=Ba mod p。至此，客户端与服务端的密钥交换过程结束，它们拥有相同的共享秘钥K。之后的传输将用该共享秘钥K，采用AES算法进行加密。 由于AES算法要求向量IV和秘钥K都为16位串，因此这里分别截取后16位和前16位作为IV和K。 当且仅当客户端和服务端都得到了共享秘钥K后，客户端才开始初始化界面，然后发送Login消息。在此之前都会被阻塞。 使用AES加密传输内容 # 加密函数 def encrypt(text, K, IV): text = add_to_16(text) cryptos = AES.new(K.encode('utf-8'), AES.MODE_CBC, IV.encode('utf-8')) cipher_text = cryptos.encrypt(text) # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串 return b2a_hex(cipher_text) 加密采用的是AES中的CBC模式，其中还通过补零转16进制字符串的方法来防止传输出错。 # 解密后，去掉补足的空格用strip() 去掉 def decrypt(text, K, IV): cryptos = AES.new(K.encode('utf-8'), AES.MODE_CBC, IV.encode('utf-8')) plain_text = cryptos.decrypt(a2b_hex(text)) return plain_text.rstrip('\\0'.encode('utf-8')) 解密过程同理，要将多余的空格去除。这里解密我选择直接返回bytes序列，这是为了方面之后文件的传输。 效果 成功的实现了加密传输，之后的传输都会进行这样的加密。 4. 字符串标志位 通过设置必要的标志位来区分不同的信息类型。标志位又分为截断标志位和分类标志位。 截断标志位有2个： END = '__END___' DIV = '__DIV___' END用来标志一条传输信息的结尾位置，用来预防出现截断发送或合并发送的情形，具体之后会讲。 DIV用来分隔一条传输信息中的两个不同部分，例如在一条群发消息中，用户名和消息内容就需要用DIV分隔开，因为它们必须储存在同一条信息中配对传输。 分类标志位有很多个： MSG = '__MSG___' # 消息 USER = '__USER__' # 用户登录登出信息 LOGIN = '__LOGI__' # 新登录信息 LOGOUT= '__LOGO__' # 新登出信息 INIT = '__INIT__' # 初始化信息 HIS = '__HIS___' # 历史记录 ROLL = '__ROLL__' # 撤回消息信息 NAME = '__NAME__' # 重名信息 GRANT= '__GRANT_' # 任免信息 KICK = '__KICK__' # 踢人信息 UPLOAD= '__UPL___' # 上传信息 FNAME = '__FNAME_' # 新文件信息 DOWNLOAD='__DOWNL_' # 下载信息 FILE = '__FILE__' # 文件信息 KEY = '__KEY___' # 公开秘钥信息 FACE = '__FACE__' # 表情信息 mark_len = 8 分类标志位会加在发送信息的头部（即为前面提到的mark），用于区分该信息的类型。 例如一个叫River的用户发送一条Hello的消息，则该消息的传输形式如下： __MSG___River__DIV___Hello__END___ 其他标志位的具体含义将在下面介绍具体功能时相应给出。 注意到本项目中所有的标志位都规定为了8位，这样是为了方便字符串处理。 5. 三种不同的传输函数包装方式 def send_UTF8(text): # 负责发送utf-8可编码类的消息 global conn, K, IV try: conn.sendall(MyCrypto.encrypt(text, K, IV)) # 加密发送 except Exception as err: print(f'[send ERROR] {err}') def sendFile(filename, filebytes): # 负责发送文件 global conn, K, IV try: conn.sendall(MyCrypto.encrypt(UPLOAD + filename + DIV + str(len(filebytes)) + END, K, IV)) # 先发文件名和大小 conn.sendall(filebytes) # 然后发送文件bytes序列 return True except Exception as err: print(f'[sendFile ERROR] {err}') return False def recv_bytes(): # 负责接收加密的所有消息 global conn, K, IV try: text = conn.recv(4096) print(f'Recving Cipher: {text}') return MyCrypto.decrypt(text, K, IV) # 接收后解密 except Exception as err: print(f'[recv_file ERROR] {err}') 为了方便使用，本项目中将SOCKET中的函数自行进行了包装。发送函数将文件的发送单独的分离出来，因为文件的发送不能采用utf-8编码，且文件的发送序列较长。接收函数统一包装为接收bytes序列的形式，这样方便后续处理。加密和解密过程也包装在这三个函数中了。 文件的发送这里采用的是先发送一个包含了文件名和文件长度的短消息后，在单独进行文件的发送。短消息的格式为： __UPL___fileName__DIV___fileLength__END___ 发送的长度将保证接收方完整地接收文件。 注意到这里还通过try-except捕获收发过程中可能出现的错误。 三、特殊功能介绍 1. 快速退出 效果展示 出于人性化考虑，当点击窗口右上角的关闭键退出群聊时，会弹出是否退出的询问框。当需要快速退出时，点击工具栏第一个QuickExit按键即可直接退出。后面将提到的群主踢人功能就是通过强制触发被踢用户的QuickExit功能实现的。 实现方法 app.exec_() if nickname is not None: print('LOGOUT.') # 我走了 send_UTF8(LOGOUT + nickname + END) conn.close() 点击按钮后，窗口关闭，应用退出，然后会执行上面语句。发送相应的LOGOUT字符串，然后关闭连接。 __LOGO__River__END___ 服务端接收到上面字符串后，receiver线程提取出用户名River然后加入logIO_buf中，然后return，即结束了receiver线程。 if not self.__receiver.isAlive(): if(len(threading.enumerate()) == 2): # 当所有用户都退出时，清空缓存池和缓存文件 self.__cleanBuf() self.__conn.close() return sender线程将logIO_buf中更新的内容群发出去，告诉其它用户River退出这一信息后，会执行上述代码。当发现receiver线程死掉了后，首先检查服务端一共还剩下多少个线程，若只剩下2个，说明自己是最后一个非主线程，则清空所有缓冲池，然后也结束自己，同时关闭conn连接。 通过上述交互，就实现了用户的干净退出。清除缓存池是因为，当自己是最后一个非主线程时，说明自己是最后一个退出的用户，该用户退出后聊天室将为空，即表示当次聊天结束。下一个进来的人不应该访问得到上一批人群聊的信息。这保障了聊天信息的隐蔽性。 2. 查看历史消息 效果展示 点击工具栏的History按键会弹出在加入聊天室之前，之前的人的聊了啥，即展示历史消息。历史消息中被撤回的消息会被替换。 实现方法 # 请求历史记录 send_UTF8(HIS + END) self.history_widget = HistoryWidget() self.history_ok = False 实际上历史记录的这个窗口是在用户登录后就创建的。在用户登录后，马上发送请求历史记录的信息，然后构建历史记录窗口。History按键只是简单地让历史记录窗口显示出来而已。 __HIS_____END___ 这是一个单发请求。当服务端receiver接收到该请求后，将局部变量self.require_history的值置为True。然后sender会探测到该局部变量的变化，将历史记录单独发送给该客户： with msg_lock: if self.require_history is True: seq = str(msg_buf[:self.__next_msg]) self.__send_UTF8(HIS + seq + END) self.require_history = False msg_buf[:self.__next_msg]截取了该用户登录前的msg_buf直接转化为字符串传输。而从self.__next_msg开始的之后的信息，该用户则会通过服务端的群发接收到，即会显示在当前对话消息框中。这样的设计确保了信息不会遗漏。 然后客户端接收服务端发来的历史记录： elif mark == HIS: global history_buf, history_lock if text == '[]': global no_history no_history = True return with history_lock: history_buf = eval(text) print(text) 判断出HIS头部后，简单的改变全局变量no_history和history_buf的值即可。之后refresh()线程就会根据更新渲染历史消息框的内容。这里维护了一个no_history全局变量用来处理没有历史记录的情形。此时会弹出告知无历史消息提示，而不是历史消息框。 3. 消息撤回 效果展示 撤回前： 撤回后： 点击工具栏第三个Rollback按键实现消息的撤回。如图所示，撤回将在别人的客户端和自己的客户端撤回该用户最后一条发送的消息。同时会将服务端msg_buf中的相应消息替换走，即从历史记录中也掩盖掉该条消息。 实现方法 def rollBack(self): '''发送撤回请求 ''' send_UTF8(ROLL + nickname + END) Rollback按键直接触发上述函数，发送相关字符串形式的请求： __ROLL__River__END___ 服务端receiver接收到ROLL请求后，会更新roll_buf、roll_num，它们表示需要撤回消息的用户队列 elif mark == ROLL: global roll_buf, roll_lock, roll_num with roll_lock: roll_buf.append(text) roll_num += 1 with msg_lock: for i in range(len(msg_buf) - 1, -1, -1): if msg_buf[i].split(DIV, 1)[0] == text: # 覆盖该用户的最后一条信息，若删除的话会有下标麻烦 msg_buf[i] = 'NOTE' + DIV + '[==This Message Has Been Withdrawed.==]' break self.__debugInfo('RollBack -&gt; ' + text) 同时将服务端本地的msg_buf中撤回的消息替换掉。这里通过替换的方式而不是删除的方式是为了避免处理下标而带来的麻烦。 with roll_lock: while self.__next_roll &lt; roll_num: self.__send_UTF8(ROLL + roll_buf[self.__next_roll] + END) self.__next_roll += 1 然后sender通过上述代码利用老办法将roll_buf中更新的内容群发到客户端，然后客户端将撤回请求接收到本地全局缓冲池roll_buf后，等待refresher更新即可。 讲到这里，我们可以发现群发的操作其实几乎是一样的，无非是针对不同的消息头部、不同的全局缓冲池罢了。因此之后的群发操作若不是有特殊操作，我将不再赘述。 4. 表情/图片发送 效果展示 实现方法 客户端从本地选择要上传的图片后，将图片序列发送至服务端，采用的适合发送文件一样的先发送一个包含用户名和图片大小的短信息，在发送图片序列，保证图片发送的完整性： __FACE__River__DIV___255350__END___ def sendFace(filebytes): global conn, K, IV, nickname try: # 先发用户名和图片大小 conn.sendall(MyCrypto.encrypt(FACE + nickname + DIV + str(len(filebytes)) + END, K, IV)) conn.sendall(filebytes) return True except Exception as err: print(f'[sendFace ERROR] {err}') return False 服务端接收到图片后，先保存到服务端本地的文件夹中，并且给图片赋予uuid生成的随机图片名，然后按照群发消息一样的套路，更新全局的face_buf、face_num。face_buf中存储的为待群发的图片，face_num表示服务端总共收到的图片数量。然后由sender检测并依次发送图片： with face_lock: while self.__next_face &lt; face_num: temp = face_buf[self.__next_face] face_name = temp.split(DIV, 1)[1] with open('./face_buf/' + face_name + '.jpg', 'rb') as f: filebytes = f.read() self.__send_UTF8(FACE + temp + DIV + str(len(filebytes)) + END) self.__conn.sendall(filebytes) self.__next_face += 1 图片发送到客户端也是一样的形式，即先发送短信息再发送图片。客户端收到群发而来的图片字节序列后，将其转为base64编码然后通过html渲染到界面上： while(bytes_received &lt; bytes_total): # 按照长度接收图片 data = conn.recv(bytes_total - bytes_received) bytes_received += len(data) facebytes += data s = base64.b64encode(facebytes).decode() with face_lock: face_buf.append(user_name + DIV + s) face_num += 1 转换成base64后，就直接将图片作为html代码用渲染消息一样的方式渲染到每一个客户端的界面上即可。 &lt;img src=&quot;data:image/jpeg;base64, .....base64序列.....&quot; width=&quot;200&quot; alt=&quot;图像加载失败...&quot;&gt; 上述这种直接渲染图片的方法无需将图片缓存到客户端，是一种比较常见、便捷的图片渲染方法。 5. 群主特权与轮转制 效果展示 第一个进入群聊的人会获得群主资格： 群主具有踢人权限： 群主退出后，将由下一个最早进入的人继承群主权限： 实现方法 # sender ....... if groupLeader is None: with logIO_lock: groupLeader = self.__getFirstMember() if self.__nickname == groupLeader and self.become_leader is False: self.__send_UTF8(GRANT + END) self.become_leader = True ....... 上述代码为服务端sender线程主循环中的一部分代码。该代码探测当前是否有群主，若没有，则通过logIO_buf找到第一个进入聊天室且还没有退出的人，将它任命为groupLeader，然后将任免信息单发给被任命的客户端： __GRANT___END___ 客户端的receiver线程收到任免信息后，将全局变量getLeaderPower设为True： elif mark == GRANT: global getLeaderPower getLeaderPower = True 这个为True的getLeaderPower将使能界面上的踢人功能。 群主在踢人窗口中输入要踢的用户的名字，然后发送踢人请求给客户端： __KICK__Bob__END___ 服务端收到KICK请求后，执行以下代码： elif mark == KICK: # 强制退出 with logIO_lock: if not self.__isInUserList(text): # 若踢的人不在列表中，则什么事都不会发生 return logIO_buf.append('-' + text) logIO_num += 1 with kick_lock: kick_buf.append(text) self.__debugInfo('User- -&gt; ' + text) 上述代码首先创建被踢人的Logout信息加入logio_buf中，用于群发出去，告诉所有用户这个人退出了；然后将被踢人的名字加入全局的kick_buf中。 with kick_lock: if self.__nickname in kick_buf: kick_buf.remove(self.__nickname) self.__send_UTF8(KICK + END) return 服务端的sender然后不断扫描kick_buf，当发现它所服务的客户是被踢的对象之一时，则发送KICK给客户端用户强制关闭客户端；同时自己使用return来结束线程。当sender结束后，receiver也会随即探测到并结束，然后关闭连接，从而干净退出。群主其实还可以自己踢自己。 注意到这里的KICK信号虽然为单发信号，但还是维护了一个全局的kick_buf来实现。实际上通过局部变量也是可以实现的。这里只是两种方法二选一而已。 __KICK____END___ 客户端收到上述的被踢指令，按照老办法，通过全局变量让refresher探测到，refresher探测到后，通过qApp.quit()强制退出。 if isKicked is True: QMessageBox.critical(self, 'Announce', f'You have been kicked out by the Group Leader.') qApp.quit() 6. 文件传输 效果展示 上传： 上传后其他人可以找到并下载那个文件： 实现方法 def upLoad(self): filename, _ = QFileDialog.getOpenFileName(self, &quot;选取文件&quot;, self.__cwd, # 起始路径 &quot;All Files (*);;Text Files (*.txt)&quot;) # 设置文件扩展名过滤,用双分号间隔 if filename == &quot;&quot;: print(&quot;取消选择&quot;) return with open(filename, 'rb') as f: # 将文件打开，读取字节流 filebytes = f.read() if sendFile(os.path.basename(filename), filebytes): # 忽略等待 QMessageBox.information(self, 'Success', f'Upload successfully.') else: QMessageBox.critical(self, 'error', f'Upload fail.') 用户选择完要上传的文件后，客户端即能获取到要上传的文件路径。从文件路径中获取文件名filename，然后以'rb'模式打开文件获取文件字节流filebytes。 将文件名和文件长度先发送到服务端，服务端接收后就进入接收文件状态。 __UPL___filename__DIV___bytes_total__END___ filebytes = b'' bytes_received = 0 while(bytes_received &lt; bytes_total): # 按照长度接收文件 data = self.__conn.recv(bytes_total - bytes_received) bytes_received += len(data) filebytes += data 接收文件时采用上述结构，逐段接收直至接收总长达到文件长度，从而保证接收的完整性。前面的图片发送具体实现也是如此。 服务端接收到上述文件后，根据文件名将文件保存在服务端本地的files_buf文件夹中，然后在全局的filename_buf中增添新上传的文件名。 with open('./files_buf/' + filename, 'wb') as f: f.write(filebytes) with file_lock: filename_buf.append(filename) filename_num += 1 然后服务端sender根据全局的filename_buf、filename_num，利用相同的套路，将新上传的文件信息群发给所有用户。用户接收到新文件信息后也是用相同的套路储存在客户端本地全局缓冲池filename_buf中，之后refresher探测到新增的文件名，将其显示在下载界面上的可下拉选择器中供用户选择。 至此，服务端已经存储了上传的文件，所有客户端也获得了最新的已上传文件名列表。所以客户端就可以根据文件名列表选择想要的文件发送下载请求了： __DOWNL_filenameChosen__END___ 服务端receiver线程接收到上述请求后，首先分离出文件名，将其加入到局部列表变量self.require_files中。然后当sender线程探测到该局部变量列表不为空时，会逐个根据列表中的文件名将对应的文件从files_buf文件夹中打开，读取其字节流，然后以上传时同样的形式（先发长度后发文件）单发给请求的客户端。 客户端接收到上述文件后，结合之前选择的下载路径download_dir，将文件保存到本地即可。 四、细节处理 1. 保证接收消息的完整性和独立性 在进行代码调试的过程中，发现了socket API在接收过程中会出现以下两种情形：分段传输接收和合并接收 针对分段接收 分段传输主要出现在传输很长的字符序列的情形，比如传输文件的情形。 在接收函数conn.recv(n)中，n表示每次接收的最大字节数量。由于我们不可能将n设得无限大，因此当传输大文件时总会出现一次接收不完的情形。这是就需要通过循环接收的方式，将每次接收的片段累加起来，直到收到序列的结束标志END 针对合并接收 当两个短的传输序列在很接近的时刻到达时，conn.recv(n)会将它们合并接收为一个字符串。 这种情况将导致合并信息中的后一条会被当做前一条的内容，从而产生信息错误和信息遗失。针对这个问题，我们在每次接收到字符序列时，需要遍历找出所有的结束标志END，从而从每一次的接收序列中分离处所有的独立传输信息。 代码实现 def recv_proc(self): '''【接收工作线程】 接收服务端群发的更新数据，以此更新本地数据 ''' # 首先进行密钥交换 self.__recv_key() END_bytes = bytes(END, encoding='utf-8') recvBytes = b'' while True: recvBytes += recv_bytes() try: index = recvBytes.find(END_bytes) if index == -1: # 针对不完整情况 continue while index != -1: # 针对合并情况 self.update_buf(recvBytes[:index]) recvBytes = recvBytes[index + mark_len:] index = recvBytes.find(END_bytes) recvBytes = b'' except Exception as err: print(f'[update_buf ERROR] {err}') 上面为客户端receiver线程的函数实现，服务端的receiver类似。 当一次接收的序列recvBytes找不到结束标志END时，我们则通过continue等待下一次的接收序列，然后进行累加，直到找到结束标志为止。至此收到的序列至少包含一个独立的传输信息。 将上述序列通过循环不断搜索END标志然后切割分段，分出来的每一个段都是一个独立的传输信息。之后将每条独立信息输入self.update_buf()函数中进行相应的全局变量更新即可。 2. 用户允许中途加入 由于用户加入群聊有先后之分，之前加入的人可能会先进行聊天对话，而后加入的人就看不到前面的人的对话，于是就引入了之前提到的历史记录功能，供后加入的用户浏览前面用户的聊天内容；同样，后加入的人需要获取当前聊天室都已经有哪些人存在以及之前都传输了哪些文件。因此，在一个用户login时，服务端会对该用户单发之前的历史记录、当前的用户列表以及上传文件名列表。这样一来用户登录时就能接收到这些信息，然后更新历史记录框、用户列表和文件列表。 __INIT__userlist__DIV___filelist__END___ 这条信息传输的是当前用户列表和文件名列表 __HIS___msglist__END___ 这条信息传输的是历史记录 理论上这三个列表是可以一起传输的，但考虑到历史记录可能较多，因此将其分开来传输处理了。 3. 重名处理 处理重名问题理论上有两种办法：一是在用户登录时输入用户名时，就进行检测；二是在用户登录后已经进入聊天室后，对重名进行强制更改，然后告知用户。 考虑到检测用户名必须在连接建立之后才能实现，而在用户名输入界面就进行连接是不划算的（因为可能会反复登录退出），因此本项目中用的是第二种方法。 if name in user_list: self.__nickname = self.name_change = name + '#' return name + '#' # 若有重复用户名，则当前要增加的用户名变为 ...# self.__nickname = name # 记录本连接的用户名 服务端是按照上述代码来处理重名的，即简单的在新加入的重复用户名后加'#'。例如第一个进入的用户名为River，则之后以River命名的用户将会被重新赋予River#、River##....的新昵称。赋予新名称后，服务端会单发提示信息给相应的客户： __NAME__newname__END___ 客户端收到上述提示后就会弹出提示框告知用户。考虑到这是一个简易的灵活式聊天室，这样的设计是合理的。 4. 群聊结束后清空缓存 当所有人都退出聊天室后，说明本次聊天已经全部结束，此时将服务端的所有消息记录、用户记录、文件缓存、表情包缓存全部清空是更加合理的，因为下一个连接的用户应该被认为是发起了一个全新的群聊。 前面讲快速退出功能时已经提到过，服务端是通过获取剩余的线程数来判断本次群聊是否已经结束。当判断出群聊结束后，就开始执行清空缓存的函数： def __cleanBuf(self): '''清空缓存池 ''' global msg_buf, logIO_buf, roll_buf, kick_buf, filename_buf global groupLeader, msg_num, logIO_num, roll_num, filename_num shutil.rmtree('./files_buf') os.mkdir('./files_buf') shutil.rmtree('./face_buf') os.mkdir('./face_buf') msg_buf = [] logIO_buf = [] roll_buf = [] kick_buf = [] filename_buf = [] groupLeader = None msg_num = 0 logIO_num = 0 roll_num = 0 filename_num = 0 print('NOTE: Clean ALL bufs done.') 清空操作非常简单，即清空所有的全局缓存变量以及服务端本地的文件缓存文件夹、表情包缓存文件夹即可。 5. 利用html进行消息框渲染 这可以说是我自认为的本项目中最得意的亮点了。单纯用PyQt5是难以实现消息框中聊天气泡效果的，因此需要借助静态html和css渲染来实现。而静态的html如何实现动态的聊天消息变化呢？在本项目中，这是通过在每个客户端中维护一个全局的html长代码串，当收到新消息或需要撤回旧消息时，就相应地更改这个html代码串，然后将更新完后的html重新加载到界面上即可。 五、项目总结 这是一个简易但又包含众多实用功能的聊天室，是通过严密的传输规定和接收逻辑来实现的，轻量而高效。由于代码的逻辑性较强，群发传输和单发传输存在着一定的固定方法，因此代码的维护和功能的增加都较为方便。若有时间，我将会继续为其加入其它实用的功能，如私聊等。 * * * FinFin Fin Github源码 求⭐️~ ","link":"https://river861.github.io/post/wetalk-jian-yi-liao-tian-shi/"},{"title":"基于框架和规则的Pokémon识别专家系统","content":"一个通过专家系统来实现的“宝可梦图鉴”，人工智能 PJ。 概要： 动物识别专家系统是一种典型的专家系统，它是通过用户描述一种动物的多个特征，然后由专家系统推测出该动物的种类。而本项目依据的是同样的思路，但是将对象转向了一类虚拟的物种——宝可梦(Pokémon)。通过用户描述一种宝可梦的多个特征，本专家系统将推测出具体的宝可梦种类。在实现方面，本项目是基于框架的专家系统，同时运用了基于规则的专家系统中的不确定性管理方法，还运用了决策树模型的ID3算法优化了用户交互体验。利用框架的特性，本项目实现了知识库的动态生成；利用问题的缺省结构设计，本项目实现了问题集的动态生成；利用确性因子和ID3算法，本项目实现了问题的动态选择。同时，本专家系统还包含了解释设备以及特征库的扩展接口。 关键词： 基于框架的专家系统；不确定性管理；ID3算法；动态生成；动态选择；宝可梦 Abstract: The animal recognition expert system is a typical expert system. It speculates the type of an animal with features of the animal provided by the user. Based on the same idea, this project turned the research object to Pokémon, a virtual species. It speculates the type of a Pokémon with features provided by the user. In terms of implementation, this project is a frame-based expert system, using the uncertainty management of the rule-based expert system, as well as the ID3 algorithm of the decision tree model to optimize the user interaction experience. With the characteristics of the frame-based expert system, this project realized the dynamic generation of the knowledge base. With incomplete problem structures, this project realized the dynamic generation of the problem set. With the certainty factor and ID3 algorithm, this project realized the dynamic selection of the problems from the problem set. In addition, this expert system also includes an explanation facility and an extended interface of the feature database. Key words: frame-based expert system; uncertainty management; ID3 algorithm; dynamic generation; dynamic selection; Pokémon 0 项目研究现状与背景 图0.1 图片来自参考文献[1] ​ 本项目的灵感来源于动物识别系统。 在当前，随着深度学习的不断发展，动物识别已经可以通过图像识别的技术得到较好的实现。而在早期，动物识别主要通过基于产生式规则的专家系统实现，但受到动物物种丰富度的影响，规则知识库大小的限制和问题种数的限制，动物识别专家系统并不能很好地得到发展和应用。 ​图0.2 图0.3 精灵宝可梦(Pokémon)，又称口袋妖怪、宠物小精灵（方便起见，后文统一称为宝可梦或pokemon），是由任天堂游戏创造、在日本动画中出现的虚拟生物，在一部分人群中很受欢迎。而宝可梦图鉴，则是一种用来记录、识别宝可梦信息的设备。如图0.2、0.3所示，宝可梦图鉴通过摄像头扫描宝可梦，该设备即可识别出该宝可梦的具体信息和数据。这十分类似于现实中的基于神经网络的图像识别技术。 本项目实现的专家系统即是以宝可梦图鉴为原型设计的。但不是使用摄像头和图像识别技术来提取特征，本项目是一个基于问答来收集特征的专家系统。系统向用户提出问题，然后根据用户的回答来推测和识别用户所描述的宝可梦类型。相比于真实生活中的动物，宝可梦具有物种种类少、不同物种之间特征差异明显等特征，因此非常适合通过针对小范围领域的专家系统来实现。另外，针对传统的动物识别专家系统规则知识库大小和问题种数上的受限问题，本项目考虑通过规则知识库和问题的动态生成来提升专家系统性能。 1 架构设计 本项目中的知识库、问题集是由外部的pokemon特征数据库自动生成的，具体在之后会讲。开发人员（专家或知识工程师）可以通过开发人员界面修改pokemon特征数据库。由于知识库、问题集是由特征数据库生成的，因此开发人员的修改实际上将更新知识库中的规则、更新问题集。 系统首先从问题集中挑选最有效的问题，然后通过用户界面的显示设备向用户进行特征询问，用户回答询问并通过用户界面的输入设备输入答案。用户的回答将作为事实储存在事实库中。推理引擎随后根据事实库中的事实，在知识库中寻找匹配的规则前项，然后执行相应规则的后项，执行的规则后项会更新每一种宝可梦成为答案的确信度，然后推理引擎继续从问题集中动态挑选问题并向用户进行新一轮的询问。 在执行了若干轮问答后，推理引擎取得了足够的特征后，会将确信度最大的pokemon作为答案交给用户界面的解释设备。解释设备将答案和推理轨迹在显示设备上显示出来以此使得用户可见。 本项目将问答轮数上限设置为了10，也就是系统将在小于等于10轮的问答内给出答案。注意在本系统中，每一轮的问答提出的问题均为是非判断题，而不是需要用户进行详细回答的问题，因此10轮的问答上限是合理的。用户基本上在半分钟左右可以完成一次pokemon识别。 用户可以对结果进行评判，当推测结果被否认后，解释设备可以将下一个确信度最大的pokemon及其推理轨迹显示出来，用户继续进行评判，以此类推，直至用户确认答案或候选pokemon被全部否认。 本专家系统最终通过python 3.6 以及通过 PyQt5 进行界面设计来实现。 2 具体实现 2.1 特征数据库建立 数据来源 在本项目中，我将作为宝可梦领域的专家建立pokemon特征数据库，从而生成知识库。数据方面参考了宝可梦百科（参考文献[3]）。最终一共添加了73只宝可梦的特征数据到数据库中。数据库中分为子类表和父类表两个表，子类表存储宝可梦中每一物种的特征，父类表存储宝可梦的每一类群的特征。 子类表 图2.1.1 杰尼龟 图2.1.2 皮卡丘 子类表存储了以上属性。super_class属性指明了该宝可梦的父类名称。这是为之后框架的继承做准备。 当一个属性的值为NULL时，代表该宝可梦没有这一项特征或这一项特征将从父类继承。比如第一个宝可梦杰尼龟（如图2.1.1），它没有耳朵，并且它的父类龟类也没有耳朵这一特征，因此最终它将没有耳朵颜色这一特征。 当一个属性拥有多个值时，我们将它们用空格隔开存放，并规定将占比越大的值排在越前面。比如皮卡丘（如图2.1.2）的耳朵大部分为黄色，小部分为黑色，因此我们排列为“黄色 黑色”；又比如皮卡丘大部分栖息在森林中，小部分栖息在城市中，因为我们将栖息地属性的值排列为“森林 城市”。这样排列是为之后的不确定性管理做准备。 父类表 父类表存放了宝可梦父类的特征信息。比如蛇类一般没有四肢也没有翅膀，所以蛇类的手脚个数和翅膀个数属性都是0，并且蛇类宝可梦一般具有 “像一条蛇”的特征，因此细节属性上存放了这一特征描述。具体的继承相关的规则我们将在框架设计时细讲。 2.2 问题设计 设计目标 对于问题的设计，我们希望设计出的问题能够具有以下特点： 高区分性。即问题的回答能够尽可能好地区分出不同的宝可梦。 易答性。即用户能有轻松地作出清晰或模糊的回答，比如是、不是、好像是、好像不是等等。这样的目的是为了提高用户体验。 设计方案 最终根据设计目标和数据库中已有的特征类型，我设计出了以下7类问题： 我们可以看到，上述设计的问题不仅具有高区分性，并且用户能够仅仅通过简单的是非判断来进行轻松的回答。 问题的样式使用了缺省的结构设计。 问题实例的动态生成 通过问题的缺省结构来设计问题，是为了实现问题的动态生成。 val_box = { 'color': set(), 'eye_color': set(), 'ear_color': set(), 'limb_num': set(), 'wing_num': set(), 'habitat': set(), 'detail': set(), } question_box = { 'color': '它的身体是不是有{val}的部分？', 'eye_color': '它的眼睛是{val}的吗？', 'ear_color': '它的耳朵是{val}的吗？', 'limb_num': '它一共有{val}只手和脚吗？', 'wing_num': '它是不是有{val}只翅膀？', 'habitat': '它是不是生活在{val}附近？', 'detail': '它是不是{val}？', } 问题的动态生成，具体而言，即系统通过维护了一个问题样式集question_box和一个特征值集val_box来动态生成问题实例集合。当系统启动时，会加载特征数据库中所有宝可梦的特征，然后将特征值收集在val_box中，之后由question_box和val_box进行对应组合来生成问题实例集合。 一方面，缺省的问题结构极大地增加了问题的多样性，每一个具体的特征都将对应于一个具体的问题；另一方面，事实上缺省的问题结构对于知识库的扩充是必要的：当专家或知识工程师新增或修改pokemon特征数据库时，为了通过新特征来区分出新的宝可梦，系统将需要依照问题的样式生成相应的新的问题实例。 目前，在数据库中已有的73只宝可梦中，各种类型的特征值数量如下： 因此问题实例个数总共为133个。 2.3 框架设计 2.3.1 为什么选择基于框架的专家系统设计？ 基于框架的专家系统允许宝可梦特征的缺省输入。比如当输入皮卡丘的特征到系统中时，并不需要提供皮卡丘的手脚个数和翅膀个数，因为这两个特征可以由其父类直接继承而来；另外，当修改某一父类的特征时，就能将所有子类的缺省特征一并修改，这样十分便于数据的修改。 基于框架的专家系统的精髓在于它可以实现缺省推理。在宝可梦识别的任务中，系统需要通过用户提供的有限的特征来确定宝可梦的种类，这就需要借助专家系统的缺省推理能力。比如，当用户提供了“整体呈黄色”和“有像锯齿状闪电的尾巴”这两个特征，并且系统发现除了皮卡丘外再没有第二个宝可梦同时具有这两个特征时，系统就应该直接给出皮卡丘这一答案。而不再需要用户继续提供眼睛颜色、耳朵颜色等其他特征了，因为这些特征已经被系统缺省推理出来了。 2.3.2 定义类及其属性 上图所示为本项目中定义的框架局部图。首先宝可梦类会泛化为蛇类、虫类、鸟类、犬类、鼠类等多个类别，然后这里的每种类别又会继续泛化为各种不同种的宝可梦。这里以鼠类为例，鼠类宝可梦泛化为了皮卡丘、电飞鼠等具体的鼠类宝可梦。然后每一种宝可梦就会产生相应的实例。 子类可以继承父类的特征，比如上图中皮卡丘继承了鼠类的4个手脚和0个翅膀的特征；子类又可以覆盖父类的特征，形成自己独特的特征，比如电飞鼠的翅膀数为2，覆盖了父类的0个翅膀的特征。 宝可梦的每一个特征都被作为槽值添加到了相应的类框架中。除此之外，框架中还增添了一个叫确信度的槽值。这个槽值维护了当前该宝可梦为最终答案的确信度。当推理引擎根据规则进行推理时，会改变每一种宝可梦的确信度，最终确信度最高的宝可梦会作为答案输出。确信度初始值为0。 利用python的面向对象程序设计可以很方便的实现上述框架： class Pokemon: def __init__(self, name, url, height, weight, intro): '''框架的所有槽值 ''' self.cf = 0.0 # 确信度 self.name = name self.height = height self.weight = weight self.slot = { 'color': dict(), 'eye_color': dict(), 'ear_color': dict(), 'limb_num': dict(), 'wing_num': dict(), 'habitat': dict(), 'detail': dict(), } ...... 实现分两步，先从前面提到的pokemon特征数据库中读取父类表的信息，将父类信息导入到相应的上述子类宝可梦类中；然后再读取数据库中子类表的信息，直接导入相应的宝可梦类中。这样就能实现子类对父类的继承和覆盖。 2.3.3 定义守护程序 为了提高专家系统的识别效率，本系统设置了一个守护程序来排除不可能的宝可梦。被排除的宝可梦将不会参与之后的判断。我将该守护程序附加在了每种宝可梦的确信度槽上。当每一轮问答结束时，系统会对候选列表中的所有宝可梦的确信度进行更新。当每个宝可梦的确信度改变时，会触发这个守护程序，守护程序将判断该宝可梦是否已经可以排除，若可以，则将其从候选列表中删除。 def update_cf(self, key, val, cf) : # 更新cf值 ...... if self.cf &lt; 0.5: self.false_cnt += 1 def is_out(self) : if self.false_cnt &gt; 2 : return True return False 上述守护程序的意思是，当一个宝可梦在3轮的问答中确信度在0.5以下，则将其标记为is_out，即从候选中排除。 2.4 规则设计 表2.4.1 数据源于课本第3章 2.4.1 为什么选择基于确信因子的规则设计？ 确信因子技术是常用的代替贝叶斯推理的方法。由于在宝可梦识别的过程中，由一种特征推出一个宝可梦的概率是困难的，或者说是没有数学依据的，因此我们考虑使用确信因子来推理宝可梦的种类。在本专家系统中，将由我作为宝可梦领域的专家，根据自己的知识来确定规则和确信因子。 本项目中确信因子的具体数值主要是通过自己的判断结合教材的不确定性术语表（表2.4.1）来确定的。 2.4.2 不确定性规则的动态生成 前面我们提到过，本项目中的知识库是由pokemon特征数据库动态生成的，这实际上是因为，宝可梦的特征隐式地表达了宝可梦的识别规则。本系统将分别从框架中导出正向规则、反向规则以及缺失规则。 下面以杰尼龟为例介绍这三种规则是如何导出的。下面框架展示出的为杰尼龟框架中用于产生规则的那一部分槽值，我们前面设计的问题正是与这些槽值有关的问题： 由框架直接导出正向规则 Rule 1: IF 整体颜色 is 蓝色 Rule 2: IF 整体颜色 is 蓝色 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.4} THEN 答案 is 杰尼龟 {0.7} Rule 3: IF 整体颜色 is 黄色 Rule 4: IF 整体颜色 is 黄色 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.3} THEN 答案 is 杰尼龟 {0.6} Rule 5: IF 整体颜色 is 褐色 Rule 6: IF 整体颜色 is 褐色 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.2} THEN 答案 is 杰尼龟 {0.5} Rule 7: IF 眼睛颜色 is 紫色 Rule 8: IF 眼睛颜色 is 紫色 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.4} THEN 答案 is 杰尼龟 {0.7} Rule 9: IF 眼睛颜色 is 黑色 Rule 10: IF 眼睛颜色 is 黑色 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.3} THEN 答案 is 杰尼龟 {0.6} Rule 11: IF 手脚个数 is 4 Rule 12: IF 手脚个数 is 4 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.4} THEN 答案 is 杰尼龟 {0.7} Rule 13: IF 翅膀个数 is 0 Rule 14: IF 翅膀个数 is 0 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.4} THEN 答案 is 杰尼龟 {0.7} Rule 15: IF 栖息地 is 湖泊 Rule 16: IF 栖息地 is 湖泊 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.4} THEN 答案 is 杰尼龟 {0.7} Rule 17: IF 栖息地 is 海边 Rule 18: IF 栖息地 is 海边 AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {0.3} THEN 答案 is 杰尼龟 {0.6} Rule 19: IF 细节 is 有着波浪形的尾巴 THEN 答案 is 杰尼龟 {0.9} 正向规则是显然的，但是我们还是需要对确信度的赋值进行如下细致、合理的考虑： 为用户肯定与否定情况给予不同的确信度增益或惩罚 ​ 当用户对上述符合杰尼龟特征的前项给予肯定（用户输入确信度 cfuser&gt;=0cf_{user}&gt;=0cfuser​&gt;=0）时，答案为杰尼龟的确信度就应该较少地增加（这里设为0.2~0.4）；当用户对上述符合杰尼龟特征的前项给予否定（用户输入确信度 cfuser&lt;0cf_{user}&lt;0cfuser​&lt;0）时，答案为杰尼龟的确信度就应该较多地减少（这里设为0.5~0.7）。这是容易理解的，比如，当用户肯定颜色是蓝色时，因为可能还有其他宝可梦也是蓝色的，因此依然不能非常确定为杰尼龟；当用户否定颜色是蓝色时，因为杰尼龟就是蓝色的，因此答案是杰尼龟的可能性就大大降低了。 为同一特征的不同特征值基于不同的确信度增益或惩罚 ​ 我们前面提到过，在数据库中，当一个特征拥有多个值时，我们规定了要将这多个值按照占比大小排序。 ​ 对于占比大的特征值的“命中”，我给予了较多确信度增益或惩罚（这里为0.4、0.7）；对于占比小的特征我则给予相对较少的确信度增益或惩罚（这里为0.2或0.3、0.5或0.6）。比如，杰尼龟大部分栖息在湖泊，而小部分是栖息在海边的，当用户肯定栖息地为湖泊的事实时，我们应该给予更多的确信度增益0.4或0.7；而相比之下，当用户肯定栖息地为海边的事实时，我们应该给予相对少一点的确信度增益0.3或0.6。对于其它特征以及否定的情形与此类似。 对于“细节”特征，给予尽量重的确信度增益或惩罚 ​ 对于细节特征，我直接给予了0.9的确信度增益或惩罚。因为细节特征几乎是一个宝可梦定义性的特征。比如“有着波浪形的尾巴”的宝可梦几乎能直接确定是杰尼龟了；而当用户否定了这一特征时，就几乎能排除杰尼龟了。 由框架缺省推理出反向规则 Rule 20: IF (整体颜色 is 黑色 Rule 21: IF (整体颜色 is 黑色 OR 整体颜色 is 白色 OR 整体颜色 is 白色 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 0.7} THEN 答案 is 杰尼龟 {- 0.3} Rule 22: IF (眼睛颜色 is 黄色 Rule 23: IF (眼睛颜色 is 黄色 OR 眼睛颜色 is 红色 OR 眼睛颜色 is 红色 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 0.7} THEN 答案 is 杰尼龟 {- 0.3} Rule 24: IF (手脚个数 is 0 Rule 25: IF (手脚个数 is 0 OR 手脚个数 is 2 OR 手脚个数 is 2 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 0.7} THEN 答案 is 杰尼龟 {- 0.3} Rule 26: IF (翅膀个数 is 2 Rule 27: IF (翅膀个数 is 2 OR 翅膀个数 is 4 OR 翅膀个数 is 4 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 0.7} THEN 答案 is 杰尼龟 {- 0.3} Rule 28: IF (栖息地 is 森林 Rule 29: IF (栖息地 is 森林 OR 栖息地 is 城市 OR 栖息地 is 城市 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 0.7} THEN 答案 is 杰尼龟 {- 0.3} Rule 30: IF (细节 is 有像锯齿状闪电的尾巴 Rule 31: IF (细节 is 有像锯齿状闪电的尾巴 OR 细节 is 尾巴上有火焰在燃烧 OR 细节 is 尾巴上有火焰在燃烧 ......) ......) AND cf_user &gt;= 0 AND cf_user &lt; 0 THEN 答案 is 杰尼龟 {- 1.0} THEN 答案 is 杰尼龟 {0.0} 反向规则是容易遗漏的。并且我们依然需要对确信度的赋值进行如下细致、合理的考虑： 为用户肯定与否定情况给予不同的确信度增益或惩罚 ​ - 当用户对上述不符合杰尼龟特征的前项给予肯定（用户输入确信度 cfuser&gt;=0cf_{user}&gt;=0cfuser​&gt;=0）时，答案为杰尼龟的确信度就应该较多地减少（这里设为-0.7）；当用户对上述不符合杰尼龟特征的前项给予否定（用户输入确信度 cfuser&lt;0cf_{user}&lt;0cfuser​&lt;0）时，答案为杰尼龟的确信度就应该较少地增加（这里设为-0.3）。这也是容易理解的，比如，当用户肯定颜色是白色时，因为杰尼龟根本不是白色的，因此答案是杰尼龟的可能性就大大降低了；当用户否定颜色是白色时，虽然杰尼龟的确不是白色的，但是有许多其他宝可梦也不是白色的，因此答案依然不能十分确定为杰尼龟。 对于“细节”特征，分别给予最重或最轻的确信度增益或惩罚 ​ - 这里与正向规则有所不同。我对用户肯定的、不符合杰尼龟的细节特征给予了-1.0的确信度惩罚；而对用户否定的、不符合杰尼龟的细节特征给予了0，即不增益也不惩罚。这是合理的，比如“尾巴上有火焰在燃烧”的宝可梦几乎能直接排除杰尼龟了；而当用户否定了这一特征时，由于绝大部分宝可梦都不具有“尾巴上有火焰在燃烧”的细节特征，因此这一轮问答基本可以认为是无效问答。 由框架导出缺失规则 Rule 32: IF 耳朵颜色 is 黑色 OR 耳朵颜色 is 黄色 ...... THEN 答案 is 杰尼龟 {0.0} ​ 由于我们前面提到，杰尼龟没有耳朵，即它的耳朵颜色值为NULL，我将这种情况的确信度增益和惩罚设置为0，即不增益也不惩罚。因为这样的问题是无意义的。当用户针对一只没有耳朵的宝可梦回答与“耳朵颜色”相关的问题时，用户回答是也不对，回答不是也不对，因此我们需要将这种问题的回答直接无视掉。 ​ 以上我一共由杰尼龟的框架中推导出了32条规则。在本项目中，专家系统将自动对所有的宝可梦框架都进行类似的规则导出。如果按一个框架平均推出30条规则来计算，本系统一共隐式地包含了30*73=2190条规则。可以看出，在本系统中，知识库的丰富度是比较可观的了。 ​ 逐条设计和输入2190条规则是不容易的，而通过框架的缺省特性就可以简单快速地生成这么多条规则，这就是本系统中规则动态生成方法的优越之处。同时，“动态”生成还体现在专家和知识工程师只需要通过修改或增添pokemon特征库就可以实现对知识库中大量规则的修改和增添。 2.4.3 确信度的更新 每一轮的问答都会更新所有宝可梦的确信度。实际上确信度的更新是通过旧确信度和新确信度的合并来实现的。 旧确信度 cfcfcf 是指在进行本轮问答之前宝可梦框架中的确信度槽值； 新确信度 cfnewcf_{new}cfnew​ 是指 本轮问答后得到的事实 经过上述不确定性规则计算得出的该宝可梦的新确信度。 cfnew=cfuser⋅cfrulecf_{new}=cf_{user}\\cdot cf_{rule} cfnew​=cfuser​⋅cfrule​ 例如，对于以下规则： Rule 1: IF 整体颜色 is 黄色 THEN 答案 is 皮卡丘 {0.4} 若用户给出的对于整体颜色为黄色的确信度 cfusercf_{user}cfuser​ 为0.6，则皮卡丘的新确信度cfnew=0.6×0.4=0.24cf_{new}=0.6\\times 0.4=0.24cfnew​=0.6×0.4=0.24 确信度的合并运用的是教材中确信因子的合并公式： cf=merge(cf,cfnew)cf = merge(cf, cf_{new}) cf=merge(cf,cfnew​) merge(cf1,cf2)={cf1+cf2(1−cf1), cf1&gt;0 and cf2&gt;0cf1+cf2(1+cf1), cf1&lt;0 and cf2&lt;0cf1+cf21−min(∣cf1∣,∣cf2∣), elsemerge(cf1, cf2)= \\begin{cases} cf1 + cf2(1-cf1), \\ \\ \\ \\ \\ \\ \\ \\ \\ cf1&gt;0\\ and\\ cf2&gt;0 \\\\ cf1 + cf2(1+cf1), \\ \\ \\ \\ \\ \\ \\ \\ \\ cf1&lt;0\\ and\\ cf2&lt;0 \\\\ \\frac{cf1+cf2}{1-min(|cf1|, |cf2|)},\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ else \\end{cases} merge(cf1,cf2)=⎩⎪⎨⎪⎧​cf1+cf2(1−cf1), cf1&gt;0 and cf2&gt;0cf1+cf2(1+cf1), cf1&lt;0 and cf2&lt;01−min(∣cf1∣,∣cf2∣)cf1+cf2​, else​ 例如，若皮卡丘的旧确信度 cfcfcf 为0.5，则最终确信度更新为 cf=0.5+0.24(1−0.5)=0.65cf = 0.5+0.24(1-0.5)=0.65cf=0.5+0.24(1−0.5)=0.65，确信度得到了提升。 2.4.4 其它规则 其它规则指的是最终确定答案时要使用的一些确定性的规则，具体如下： 询问结束规则 ​ 当候选宝可梦数量≤1或者问答的轮数≥10时，停止询问。 def enough(self, turn_num): '''结束条件 ''' return len(self.pokemons) &lt;= 1 or turn_num &gt;= 10 ​ 我们前面提到过，附加在确信度槽值上的守护程序每轮都会进行检查，并将那些不可能的宝可梦从候选列表中删除，因此当候选列表只剩下一个候选宝可梦时，我们实际上已经得到答案了。另一方面，当问答轮数已经超过了10轮，我们则可以认为特征事实已经收集充分了，接下来将选取确信度最大的作为答案。 最终决策规则 和 候补规则 ​ 当询问停止后，选取确信度最大的宝可梦作为答案输出；若答案被用户否认，则选取下一个最大的宝可梦作为答案输出，以此类推，直至所有候选宝可梦均被否认。 def get_ans_list(self): '''获取结果列表 按可能性从大到小排列 每个结果包含四元组(cf, name, 身高, 体重, 简介) ''' ans, cf = None, 0 cf_list = list() for poke in self.pokemons.values(): cf_list.append((poke.cf, poke.name, poke.url, poke.height, poke.weight, poke.intro)) if poke.cf &gt; cf: ans = poke cf = poke.cf return sorted(cf_list, key=lambda x:x[0], reverse=True) ​ 在python实现中，当询问停止后，直接获取剩余的整个候选列表，并将其按确信度从大到小排列，将最大的作为答案输出。若答案被用户否定，则在列表中删除该宝可梦，选择下一个确信度最大的宝可梦输出。这样实际上是为本专家系统提供了一个容错性，这样的容错机制在一定程度上也能提高用户体验。 2.5 通过决策树ID3算法实现问题动态选择 前面提到，本系统中已经动态生成的问题实例个数共有133个，我们不可能让用户按顺序回答完全部的问题，因此我们需要从中挑选出最有效的问题来进行询问。而由于宝可梦的确信度在每一轮问答后都会发生改变，因此最有效的问题在不同的轮数中是会变化的，因此我们需要找到一种方法来动态找出每一轮的当前最有效问题。而如何定义什么是“最有效”的问题呢？这里我们将信息熵作为评判标准，运用的是决策树ID3算法的思想。 2.5.1 为什么选择ID3算法？ ID3算法是一种用来生成决策树的贪心算法。它通过计算一个集合中每种属性的信息增益，然后选取信息增益最大的属性作为划分标准来划分集合。以此类推，最终将集合划分成一个能完美分类元素的决策树。我们可以看到，ID3算法最大化了信息增益，而我们在选择进行询问的问题时，正是希望能选择最大化信息增益的问题进行询问，以此加快宝可梦的筛选。因此用ID3算法来实现对下一个询问问题的动态选择是非常合适的。ID3算法公式如下： 设S为一个集合，它根据一个目标属性的值分为n个子集，则S的信息熵为： E(S)=−∑i=1npilog2piE(S)=-\\sum^{n}_{i=1}p_ilog_2p_i E(S)=−i=1∑n​pi​log2​pi​ 其中，pip_ipi​为第i个子集对应的目标属性值的概率。 信息熵越小表示在集合S中该目标属性的值的分布越纯，即越稳定。 设一个非目标属性A将S划分为了m个子集，则S的信息熵变为： EA(S)=∑j=1m∣Sj∣∣S∣E(Sj)E_A(S)=\\sum^{m}_{j=1}\\frac{|S_j|}{|S|}E(S_j) EA​(S)=j=1∑m​∣S∣∣Sj​∣​E(Sj​) 这里实际上就是通过计算加权平均值来求得信息熵期望。 信息增益是划分前集合的不纯程度和划分后集合的不纯程度的差值，即信息熵之差： Gain(S,A)=E(S)−EA(S)Gain(S, A)=E(S)-E_A(S) Gain(S,A)=E(S)−EA​(S) 我们的目标即为找到一个非目标属性A来使得 Gain(S,A)Gain(S, A)Gain(S,A) 最大，从而使得根据属性A划分后的集合分布尽可能的纯，也就是尽可能的稳定。 2.5.2 ID3算法在本项目的应用 问题分析 我们的目标是从133个问题中选取一个使得候选宝可梦集合信息增益最大的问题，并将其作为下一个询问的问题。在每轮问答中，信息增益定义为 接收用户的回答之前 候选宝可梦集合的信息熵 与 接收回答后集合的信息熵 之差。由于对于每一个问题，回答前集合的信息熵都是相同的，因此我们只需要最小化回答之后集合的信息熵即可。 当一个问题提出后，用户的回答将分为两类：肯定和否定。当用户做出肯定或否定的回答后，每个候选宝可梦的确信度将发生不同方向的改变，总体信息熵也因此会发生不同的改变。因此我们要分别考虑肯定、否定两种回答情况，来计算信息熵的期望。 由于计算候选宝可梦集合的信息熵需要用到候选宝可梦集合中每个宝可梦成为答案的概率，因此我们需要将我们已有的宝可梦确信度分布转化为概率分布，即要将值从区间 [−1,1][-1, 1][−1,1] 映射到 [0,1][0, 1][0,1] 上。这里我想到的是利用 softmaxsoftmaxsoftmax 函数，将确信因子转化为概率： pi=ecfi∑j=1necfjp_i = \\frac{e^{cf_i}}{\\sum^{n}_{j=1}e^{cf_j}} pi​=∑j=1n​ecfj​ecfi​​ 其中，cficf_icfi​为第iii个宝可梦的确信度，pip_ipi​为第iii个宝可梦的概率，nnn为宝可梦总数。由此我们得出了当前每一种宝可梦成为答案的概率。 问题求解 对于问题qkq_kqk​，用户做出肯定和否定回答的概率均通过当前的候选宝可梦的概率分布来计算。这里实际上是假设用户总是做出客观真实的判断，因此所有符合问题 qkq_kqk​ 描述的宝可梦的概率之和即为用户做出肯定回答的概率，同理，所有不符合问题 qkq_kqk​ 描述的宝可梦的概率之和即为用户做出否定回答的概率： p_yes=∑i ∈ {pokemons benefit from qk}pip\\_yes=\\sum_{i\\ \\in\\ \\{pokemons\\ benefit \\ from\\ q_k\\}} p_i p_yes=i ∈ {pokemons benefit from qk​}∑​pi​ p_no=∑i ∉ {pokemons benefit from qk}pip\\_no=\\sum_{i\\ \\notin\\ \\{pokemons\\ benefit \\ from\\ q_k\\}} p_i p_no=i ∈/​ {pokemons benefit from qk​}∑​pi​ 用户做出肯定回答和否定回答后，候选宝可梦集合S的信息熵分别为： Eyes(S)=−∑i=1npiyeslog2piyesE_{yes}(S)=-\\sum^{n}_{i=1}p^{yes}_ilog_2p^{yes}_i Eyes​(S)=−i=1∑n​piyes​log2​piyes​ Eno(S)=−∑i=1npinolog2pinoE_{no}(S)=-\\sum^{n}_{i=1}p^{no}_ilog_2p^{no}_i Eno​(S)=−i=1∑n​pino​log2​pino​ 其中，piyesp^{yes}_ipiyes​表示接受用户对问题qkq_kqk​的肯定回答后，第iii个宝可梦的新概率，即由更新后的确信度计算而来的概率；pinop^{no}_ipino​同理为做出否定回答后的新概率。 最后可以求出进行问题qkq_kqk​的问答后，集合S的信息熵期望为： Eqk(S)=p_yes⋅Eyes(S)+p_no⋅Eno(S)E_{q_k}(S)=p\\_yes\\cdot E_{yes}(S) + p\\_no\\cdot E_{no}(S) Eqk​​(S)=p_yes⋅Eyes​(S)+p_no⋅Eno​(S) 对每个问题都进行上述信息熵期望的计算，选取最小化信息熵期望的问题作为下一个问题进行询问： next_question=argmin qk∈questions_pool Eqk(S)next\\_question = argmin_{\\ q_k\\in questions\\_pool}\\ E_{q_k}(S) next_question=argmin qk​∈questions_pool​ Eqk​​(S) 计算信息熵期望的代码实现 def __calculate_info(self, key, val): '''计算信息熵 ''' p_yes = 0.0 p_no = 0.0 info_yes = 0.0 info_no = 0.0 entr_yes = 0.0 entr_no = 0.0 for poke in self.pokemons.values(): if poke.have_key_val(key, val): p_yes += pow(math.e, poke.cf) # 用户给出Yes回答的概率 else: p_no += pow(math.e, poke.cf) # 用户给出No 回答的概率 for poke in self.pokemons.values(): new_p = poke.new_cf(key, val, cf=1.0) info_yes += pow(math.e, new_p) new_p = poke.new_cf(key, val, cf=-1.0) info_no += pow(math.e, new_p) for poke in self.pokemons.values(): new_p = poke.new_cf(key, val, cf=1.0) p = pow(math.e, new_p) / info_yes # 若用户给出Yes回答后，每个pokemon的概率 entr_yes -= p * math.log2(p) new_p = poke.new_cf(key, val, cf=-1.0) p = pow(math.e, new_p) / info_no # 若用户给出No 回答后，每个pokemon的概率 entr_no -= p * math.log2(p) return (entr_yes * p_yes + entr_no * p_no) / (p_yes + p_no + 1e-6) 3 模拟实验 ​ 为了得到充分多的模拟数据，我先将问答轮数上限调至15，然后通过模拟实验来记录各个宝可梦的确信度变化，从而绘制出各个宝可梦确信度的轨迹图。 我以识别下面这只宝可梦为例： 识别过程如下： 轮数 问题 用户输入确信度 小火龙确信度变化 小火马确信度变化 迷唇姐确信度变化 卡拉卡拉确信度变化 1 它一共有4只手和脚吗？ 0.98 +0.392 +0.392 +0.392 +0.392 2 它的眼睛是黑色的吗？ 0.64 +0.117 +0.117 +0.156 +0.156 3 它是不是生活在森林附近？ 0.16 -0.062 +0.023 -0.057 -0.0 4 它的身体是不是有黄色的部分？ -0.64 +0.106 +0.09 +0.098 +0.087 5 它是不是像一只虫？ -0.9 -0.0 -0.0 -0.0 -0.0 6 它的身体是不是有粉色的部分？ -0.9 +0.121 +0.102 +0.111 +0.099 7 它的身体是不是有褐色的部分？ -0.9 +0.088 +0.074 +0.081 +0.072 8 它的身体是不是有红色的部分？ 0.98 +0.07 +0.059 +0.064 -0.426 9 它是不是从头顶至尾巴以及四肢上长着燃烧着的火焰鬃毛？ -0.48 -0.0 -0.108 -0.0 -0.0 10 它是不是有金色长发？ -0.88 -0.0 -0.0 -0.59 - 11 它是不是尾巴上有火焰在燃烧？ 0.78 +0.118 -0.871 - - 12 它的身体是不是有橙色的部分？ -0.8 -0.064 +0.256 - - 13 它的身体是不是有土色的部分？ -0.8 +0.027 - - - 14 它的身体是不是有绿色的部分？ -0.8 +0.021 - - - 15 它的身体是不是有白色的部分？ -0.8 +0.016 - - - 识别结果最终为——小火龙。经过专家判定，这个识别结果是正确的。实际上上述的其余3只宝可梦为最后才被淘汰出局的3只宝可梦，通过分析它们的确信度变化轨迹，可以得出下面结论： 10轮是一个比较良好的问答轮数。在本例中，当问答轮数为10轮时，已经足以判断出答案，此时只剩下小火龙为唯一候选，其余宝可梦均被淘汰；通过大量对不同宝可梦的识别实验，最终发现10轮确实是一个能保证识别准确率的最佳轮数，大部分的识别任务能够在10轮以内就提早完成。若希望以降低准确率为代价提升识别速度，则可设置问答轮数为8轮左右，在本例中，8轮时系统能在识别错误2次以内找到正确答案。 系统具有良好的鲁棒性。观察小火龙的确信度变化轨迹，发现其在第2轮后确信度发生了下降，即在第3轮问答中，用户给出了一个错误判断。这个判断给予了小火龙一定的确信度惩罚，但在之后的问答中，这个惩罚很快就被填补上了。这个现象说明了本专家系统有较强的容错性和鲁棒性。 “细节”特征的判断大幅加快了识别进度。观察迷唇姐的确信度变化轨迹，在第10轮时，由于用户否定了“有金色长发”这一迷唇姐的细节特征，即标志性特征，这直接导致迷唇姐的确信度降低了0.59，并最终出局。其它出局的宝可梦类似。 ID3算法确实动态选择出了“最有效”的问题。可以看到在第8~11轮问答中，系统挑选的问题使得不正确的宝可梦依次被区分出来并最终出局（在第8轮以前让其余的69只宝可梦出局了），由此可以看出问题的动态选择是成功实现了的。 4 其它实现细节 知识扩展机制 本项目加入了知识扩展机制。专家或其他开发人员可以直接通过专家界面输入新增宝可梦的特征到pokemon特征数据库中。前面提过，由于特征数据库隐式地表达了知识库规则和问题集，因此这个专家接口实际上能间接拓展知识库和问题集。 用户的模糊化输入 在用户界面中，用户可以通过一个滑动条模糊地表达对问题的回答。数值从-1到1，直接对应于用户输入的确信度，即从“不是”到“是”，这实际上是受到了模糊逻辑的启发。这样提高了用户的使用体验，也提高了不确定性分析的准确性。 解释设备 当系统给出推测的宝可梦种类时，会将该宝可梦的确信度的变化过程显示出来，并且分别用红色和蓝色代表确信度增益和确信度惩罚，提高了用户体验。 容错机制 系统给出推测结果后，用户可以继续通过滑动条对结果进行肯定或否定。若结果被否定，则系统会按照确信度从大到小依次将候补结果展示出来，直到用户肯定或无候补宝可梦为止。 5 效果展示 预测皮卡丘 预测杰尼龟 开发人员界面 专家等开发人员可以轻松方便地在开发人员界面中输入新增宝可梦的特征信息，从而拓展专家系统的知识库。 6 总结 从效果上，我们可以看出本专家系统拥有较好的性能。这一方面得益于不确定性规则设计的严密性，另一方面得益于决策树ID3算法在问题选择上的有效性。而基于框架的设计方法则大幅优化了系统结构，框架的缺省推理特性是本项目知识库的生成基础。 从用户体验上，友好的交互界面，模糊化的输入，预测过程的显示以及容错机制都很好地提高了用户的使用体验，让用户得以轻松地与系统进行交互。 从扩展性上，知识拓展机制让专家可以通过界面方便的添加新的宝可梦到特征数据库中，这同时拓展了知识库。但需要注意的是，当宝可梦数量更多时，可能意味着需要更多的问答轮数，这就需要开发人员通过模拟实验来调整问答的轮数上限。 7 参考文献 [1]周文萱,胡龙桃,张敏,方宇涛,李欣钰.基于YOLO的小型动物识别系统设计[J].计算机时代,2019(03):22-25. [2]郭雷兵,李炜.动物识别专家系统的程序实现与运行分析[J].长沙电力学院学报(自然科学版),1999(01):29-31. [3]Mudkip.神奇宝贝百科[DB/OL].wiki.52poke.com,2006. [4]杜威铭,冉羽.决策树ID3算法研究[J].科技视界,2018(11):145-146+103. * * * FinFin Fin Github源码 求⭐️~ ","link":"https://river861.github.io/post/ji-yu-kuang-jia-he-gui-ze-de-pokemon-shi-bie-zhuan-jia-xi-tong/"}]}