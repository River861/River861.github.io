<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://river861.github.io</id>
    <title>River&apos;s Blog</title>
    <updated>2020-09-30T09:59:33.304Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://river861.github.io"/>
    <link rel="self" href="https://river861.github.io/atom.xml"/>
    <subtitle>Re: start</subtitle>
    <logo>https://river861.github.io/images/avatar.png</logo>
    <icon>https://river861.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, River&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[[图论] 最大匹配问题归纳]]></title>
        <id>https://river861.github.io/post/tu-lun-zui-da-pi-pei-wen-ti-gui-na/</id>
        <link href="https://river861.github.io/post/tu-lun-zui-da-pi-pei-wen-ti-gui-na/">
        </link>
        <updated>2020-09-26T11:47:05.000Z</updated>
        <summary type="html"><![CDATA[<p>包括匈牙利算法和Hopcroft_karp算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>包括匈牙利算法和Hopcroft_karp算法。</p>
<!-- more -->
<h3 id="一-定义">一、定义</h3>
<p>即在一个二分图中，找到最大的匹配对数。每个点只能最多和另外一个点配对。</p>
<h3 id="二-情景">二、情景</h3>
<p>为了方便理解，这里考虑一下最大匹配场景：</p>
<ul>
<li>有一列男生1..n，还有一列女生女生n + 1..n + m。即结点分开存；</li>
<li>愿意配对的男女会有边相连；</li>
<li>要求出男女配对的最大匹配数目。</li>
</ul>
<h3 id="三-解析">三、解析</h3>
<p>有两种方法可以解决最大匹配问题：匈牙利算法、Hopcroft_karp算法。</p>
<ul>
<li>
<p>匈牙利算法</p>
<ul>
<li>时间复杂度O(VE)</li>
<li>优点是代码简单，不超时时优先使用</li>
</ul>
</li>
<li>
<p>Hopcroft_karp算法</p>
<ul>
<li>时间复杂度O(sqrt(V)*E)</li>
<li>优先时更快，缺点是代码复杂，类似最大流</li>
<li>其实该算法就是将匈牙利算法中的find部分通过bfs分段，一点点来找匹配而已。</li>
</ul>
</li>
</ul>
<h3 id="四-匈牙利算法-模板">四、匈牙利算法 模板</h3>
<pre><code>bool find(int u){
	for(int v : G[u]){
		if(vis[v]) continue; 
		vis[v] = 1;
		if(belong[v] == 0 || find(belong[v])){
		// 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 
			belong[v] = u, belong[u] = v;
			return 1;
		}
	}
	return 0;
} 

int maxMatch(){
	int res = 0;
	for(int i = 1; i &lt;= n; i ++){  // 男生逐个去邀请追女生
		memset(vis, 0, sizeof(vis)); // vis用于标记对象点是否判断过, 每次都要清零
		if(find(i)) res ++;  // 找到一个心仪的女生了
	}
	return res;
} 
</code></pre>
<h3 id="五-hopcroft_karp算法-模板">五、Hopcroft_karp算法 模板</h3>
<pre><code>/*
类似最大流算法 数组解释：
dist[i]: 层数标记
belong[i]: i 的对象
*/
bool bfs(){
	queue&lt;int&gt; queue;
	memset(dist, -1, sizeof(dist));
	fin_dist = INF; // dist为当前终点的层数标记
	for(int u = 1; u &lt;= n; u ++) if(!belong[u]) que.push(u), dist[u] = 0; // 若干起点
	while(!que.empty()){
		int u = que.front();
		que.pop();
		if(dist[u] &gt; fin_dist) break; // 到增广路终点层数的点都标记好了就跳出, 后面不再标记
		for(int v : G[u]){
			if(dist[v] == -1){  // 未被标记 
				dist[v] = dist[u] + 1;
				if(!belong[v]) fin_dist = dist[v]; // 找到增广路, 确定增广路终点层数
				else dist[belong[v]] = dist[v] + 1, que.push(belong[v]); // 继续bfs 
			}
		} 
	} 
	return dist != INF;
}

bool find(int u){
    if(dist[u] &gt; fin_dist) return 0；
    for(int v : G[u]){
		if(vis[v] || dist[v] != dist[u] + 1) continue;
		//  询问过 ||  不是上下层关系    则跳过
		vis[v]  = 1;
		if(belong[v] == 0 || find(belong[v])){
            // 若对象名花无主 或 对象能重新找到npy, 则 可以匹配该对象 
			belong[v] = u, belong[u] = v;
			return 1;
		} 
    }
    return 0;
} 

int Hopcroft_karp(){
	int res = 0;
	while(bfs()){ // 搜索有无增广路 
		memset(vis, 0, sizeof(vis));
		for(int i = 1; i &lt;= n; i ++)
			if(!belong[i] &amp;&amp; find(i)) res ++; 
			// 若没有女朋友 &amp;&amp; 能找到 
	}
	return res; 
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论][经典] 常见的图论方法归纳]]></title>
        <id>https://river861.github.io/post/tu-lun-jing-dian-chang-jian-de-tu-lun-fang-fa-gui-na/</id>
        <link href="https://river861.github.io/post/tu-lun-jing-dian-chang-jian-de-tu-lun-fang-fa-gui-na/">
        </link>
        <updated>2020-09-24T09:52:55.000Z</updated>
        <summary type="html"><![CDATA[<p>比如dfs、bfs、并查集、链式前向星、判断二分图等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>比如dfs、bfs、并查集、链式前向星、判断二分图等。</p>
<!-- more -->
<h3 id="一-dfs">一、dfs</h3>
<h4 id="1-定义">1. 定义</h4>
<p>dfs，即深度优先搜索。顾名思义，即尽可能递归到达最深处，然后再回溯，以此类推，直到遍历完整个图。</p>
<h4 id="2-解析">2. 解析</h4>
<ul>
<li>
<p>通过递归实现。<br>
主要用于解决找迷宫路径等问题。<br>
dfs代码比bfs简单。</p>
</li>
<li>
<p><strong>要领：</strong><br>
用vis数组维护是否走过，记得清零；<br>
dfs中continue的条件分三类：<strong>出界、已走过、不是所求</strong>。不要遗漏了。</p>
</li>
</ul>
<h4 id="3-模板">3. 模板</h4>
<pre><code>const int Fx[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};  // 方向
string a[maxn];  // 记录地图
bool vis[maxn][maxm];  // vis数组记录是否走过
 
void dfs(int x, int y) {
    vis[x][y] = 1;
    for(int k = 0; k &lt; 8; k ++) {
        int nx = x + Fx[k][0], ny = y + Fx[k][1];
        if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '*') continue;  // 出界、已走过、不是所求
        dfs(nx, ny);  // 递归
    }
}
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/8e03fa67e5f5427dace3bdcf7adad4cc">Uva 572</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-bfs">二、bfs</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>bfs，即广度优先搜索。顾名思义，即先走完这一层，再走下一层，以此类推，直到遍历完整个图。</p>
<h4 id="2-解析-2">2. 解析</h4>
<ul>
<li>
<p>通过队列实现。<br>
主要用于解决简单（权值为1）的最短路问题。</p>
</li>
<li>
<p><strong>要领：</strong><br>
bfs问题要先想清楚**“状态点”<strong>如何定义，然后维护相应维度的</strong>vis、a数组（地图）<strong>。<br>
如果需要打印路径需要用</strong>p数组**进行父节点的存储。</p>
</li>
<li>
<p>debug时不要太着急，可以将打印信息写的详细一点，这样才能有利于更快地发现问题！<br>
注意区分Dijkstra模板：bfs用的是普通队列，vis数组的更新位置在push后。</p>
</li>
</ul>
<h4 id="3-变式">3. 变式</h4>
<ul>
<li>
<p>双向bfs<br>
先通过逆向bfs求出距离d[maxn]，然后再进行正向的“bfs”，这样就能实现一些比较复杂的最短路径问题。</p>
</li>
<li>
<p>复杂状态的表示<br>
有时后一些状态点具有很多维度（比如八数码），或取值范围很大（超过1e8），这时没有办法通过vis数组来存储，因为会爆空间。<br>
这时可以考虑这些方法来保存vis状态：set、<strong>哈希法（推荐）</strong>、康托展开。</p>
</li>
</ul>
<h4 id="4-模板">4. 模板</h4>
<pre><code>const int Fx[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};  // 方向
struct node {  // 队列中的结点
    int x, y, dist;
    node(int x, int y, int dist) : x(x), y(y), dist(dist) {}
};
int a[maxn][maxm], vis[maxn][maxm], ans;
 
void bfs(int x0, int y0) {
    queue&lt;node&gt; que;
    que.push(node(x0, y0, 0)), vis[x0][y0] = 1;  // 入队后紧接着更新vis
    while(!que.empty()) {
        node u = que.front();
        que.pop();
        if(u.x == n - 1 &amp;&amp; u.y == m - 1) {  // 退出条件（可选）
            ans = u.dist;
            break;
        }
        for(int i = 0; i &lt; 4; i ++) {
            int nx = u.x + Fx[i][0], ny = u.y + Fx[i][1];
            if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || a[nx][ny] == '#') continue;
            que.push(node(nx, ny, u.dist + 1)), vis[nx][ny] = 1;  // 入队后紧接着更新vis
        }
    }
}
</code></pre>
<h4 id="5-例题">5. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/5aeea79a2a14464b9cc101e8d376442e">Uva 1600</a><br>
<a href="https://blog.nowcoder.net/n/7c15d9766ba3450bbea4a55fd554dfc5">Uva 1599</a><br>
<a href="https://blog.nowcoder.net/n/6a23a0608d0c43b6a7422c32beeaffd6">Uva 10085</a><br>
<a href="https://blog.nowcoder.net/n/d4265122a1454285b73e6b1f1ddeb9b4">Uva 816</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="三-并查集">三、并查集</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>将若干点进行加边联通，每个连通块形成一个代表元Fa[i]（i为连通块中的任意一点）。</p>
<h4 id="2-解析-3">2. 解析</h4>
<p>并查集通常用于解决与连通相关的图论问题。<br>
优化方法有：路径压缩、启发式连接。一般为了方便，只是用路径压缩就足够了。</p>
<h4 id="3-变式-2">3. 变式</h4>
<p>在一些比较复杂的题目中，除了要维护父子关系，要需要维护其它的关系，这个时候需要 <strong>使用额外的辅助数组</strong>。</p>
<h4 id="4-模板-2">4. 模板</h4>
<ul>
<li>普通并查集</li>
</ul>
<pre><code>int n, Fa[maxn];  // 并查集要使用的Fa数组
 
int find(int x) {
    return Fa[x] == x ? x : Fa[x] = find(Fa[x]);  // 路径压缩
}
 
int main() {
    ......
    for(int i = 1; i &lt;= n; i ++) Fa[i] = i;  // Fa初始化
    ......
    for(const auto&amp; e : E) {  // 逐条加边
        int u = find(e.u), v = find(e.v);
        if(u == v) continue;  // 若连通
        Fa[u] = v;   // 若不连通则将其连通
        ......
    }
    .....
}
</code></pre>
<ul>
<li>复杂并查集</li>
</ul>
<pre><code>int Fa[maxn], dist[maxn];  // 辅助数组：到father的距离（非路径压缩的距离）

int find(int x) {
    if(Fa[x] == x) return x;
    int fx = Fa[x];
    Fa[x] = find(fx);
    dist[x] += dist[fx];  // 在回溯过程中更新，需要用到原father即fx
    return Fa[x];
}
</code></pre>
<h4 id="5-例题-2">5. 例题</h4>
<p><a href="https://www.river.ac.cn/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/">最小生成树专题</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="四-链式前向星">四、链式前向星</h3>
<h4 id="1-定义-4">1. 定义</h4>
<p>一种比vector快且省空间的存图方法。</p>
<h4 id="2-解析-4">2. 解析</h4>
<p><strong>链式向前星</strong> 就是一种用一个链表来存放每个结点的所有出边的结构，新的边从链表头插入，用于加快读图。<br>
链表头数组：head[maxn]，head[u]指向一条包含了u的所有邻接边的链表<br>
存所有边：E[maxm]<br>
边序号：cnt</p>
<h4 id="3-模板-2">3. 模板</h4>
<pre><code>struct edge {
    int to, w, next;
    edge() {}
    edge(int to, int w, int next) : to(to), w(w), next(next) {}
} E[maxm];  // 用链式向前星来存图
int cnt, head[maxn];  // head[u]指向一条包含了u的所有邻接边的链表
 
void addEdge(int u, int v, int w) {
    E[cnt] = edge(v, w, head[u]);  // 从链表的头部插入
    head[u] = cnt ++;  // 更改头指针
}
 
int main() {
    ......
    fill(head, head + n + 1, -1);  // 初始化链表头，-1表示链表尾部
    cnt = 1;  // cnt表示当前加入的边序号
    while(m --) {
        ......
        addEdge(u, v, w);
        ......
    }
    ......
    for(int i = head[u]; ~i; i = E[i].next) {  // 遍历u的所有出边的方法
        int v = E[i].to, w = E[i].w;
        ......
    }
}
</code></pre>
<h4 id="4-例题-2">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/4ab5d9ec4f3945829d259dc8c23dc5fa">Poj 3159</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="五-判断二分图">五、判断二分图</h3>
<h4 id="1-定义-5">1. 定义</h4>
<p>判断一个图是否为二分图。</p>
<h4 id="2-解析-5">2. 解析</h4>
<ul>
<li>通过 <strong>染色法</strong> 实现。<br>
用 1 和 -1 两种颜色给图的点染色，用col[maxn]来存放点的颜色, 0 表示还没染色。</li>
<li><strong>若无法相间染色，则不是二分图，否则是</strong>。</li>
</ul>
<h4 id="3-模板-3">3. 模板</h4>
<pre><code>bool dye(int u, int color){
	col[u] = color; // 先染色
	for(int v : G[u]){
		if(!col[v] &amp;&amp; !dye(v, -color)) return 0; // 下一个点没染色 就染上不同色，染不上则失败
		else if(col[v] == color) return 0; // 若下一个点染了色且和当前点颜色相同， 则必不是二分图 
	} 
	return 1;
}

int main() {
    ......
    bool ok = 1;  // 是否是二分图
    for(int i = 1; ok &amp;&amp; i &lt;= n; i ++) {
	    if(!col[i] &amp;&amp; !dye(i, 1)) ok = 0;
    } 
    ......
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论] 复杂的图论问题归纳]]></title>
        <id>https://river861.github.io/post/tu-lun-fu-za-de-tu-lun-wen-ti-gui-na/</id>
        <link href="https://river861.github.io/post/tu-lun-fu-za-de-tu-lun-wen-ti-gui-na/">
        </link>
        <updated>2020-09-13T09:38:18.000Z</updated>
        <summary type="html"><![CDATA[<p>比如LCA问题、最大流问题等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>比如LCA问题、最大流问题等。</p>
<!-- more -->
<h3 id="一-求最近公共祖先结点lca">一、求最近公共祖先结点（LCA）</h3>
<h4 id="1-定义">1. 定义</h4>
<p>LCA（Lowest Common Ancestors），即最近公共祖先，是指在有根树中找出某两个结点u和v最近的公共祖先结点。</p>
<h4 id="2-解析">2. 解析</h4>
<p>这里只说一种我个人比较喜欢的在线算法：<strong>欧拉序 + RMQ</strong></p>
<ul>
<li>
<p>时间复杂度：预处理 O(n+nlgn)，查询只需要O(1)</p>
</li>
<li>
<p>原理：<br>
欧拉序 就是在dfs遍历一棵树时经过的结点序列（包括回溯时经过的结点），显然两个结点u、v的最近公共祖先就是 <strong>欧拉序中 区间[u, v] 中深度最小的结点</strong>。（其中u、v指的是u、v在欧拉序中的第一次出现，即递归过程中的记录）<br>
因此我们只需要通过一遍dfs得到欧拉序euler[2 * maxn]、对应的结点深度dep[2 * maxn]，以及每个结点在欧拉序中的位置 pos[maxn]，就可以通过RMQ在O(1)实现内找到欧拉序中 区间[pos[u], pos[v]] 中深度最小的结点位置。</p>
</li>
<li>
<p>需要维护的结构：</p>
<ul>
<li>euler[2 * maxn]：欧拉序</li>
<li>dep[2 * maxn]：欧拉序中结点对应的深度</li>
<li>pos[maxn]：每个结点在欧拉序中第一次出现的位置（对应于进入递归的时候）</li>
<li>cnt：欧拉序长度</li>
<li>dp[2 * maxn][log_2maxn = 25]：对欧拉序根据dep进行RMQ预处理，dp[i][j]表示区间[i，i+2^j)中深度最小的 <strong>结点下标</strong></li>
</ul>
</li>
<li>
<p>为了防止混乱，规定RMQ存储、询问的是区间中深度最浅的 <strong>结点下标值</strong>，并且也是通过 <strong>结点下标区间</strong> 进行询问。之后只需要利用euler数组即可映射到对应的点。另外，区间表示为 <strong>左闭右开</strong>。</p>
</li>
</ul>
<h4 id="3-模板">3. 模板</h4>
<pre><code>int n, m, s;
vector&lt;int&gt; G[maxn];
int cnt, euler[2 * maxn], dep[2 * maxn], pos[maxn];
int dp[2 * maxn][log_2maxn];

void dfs(int u, int fa, int d) {
    pos[u] = cnt, euler[cnt] = u, dep[cnt] = d, cnt ++;
    for(int v : G[u]) if(v != fa) {
        dfs(v, u, d + 1);
        euler[cnt] = u, dep[cnt] = d, cnt ++;
    }
}

void init_RMQ() {
    for(int i = 0; i &lt; cnt; i ++) dp[i][0] = i;  // 最短的区间
    for(int j = 1; (1 &lt;&lt; j) &lt;= cnt; j ++) {  // 注意先计算小区间，所以先从小到大遍历j
        for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt; cnt; i ++) {
            int idx1 = dp[i][j - 1], idx2 = dp[i + (1 &lt;&lt; (j-1))][j - 1];
            dp[i][j] = (dep[idx1] &lt; dep[idx2] ? idx1 : idx2);  // RMQ中存放的是深度最小结点的下标值
        }
    }
}

int min_RMQ(int l, int r) {
    int k = log2(r - l);
    int idx1 = dp[l][k], idx2 = dp[r - (1 &lt;&lt; k)][k];
    return dep[idx1] &lt; dep[idx2] ? idx1 : idx2;
}

int main() {
    ......
    dfs(s, -1, 0);  // 求欧拉序euler、dep、pos
    init_RMQ();  // RMQ预处理
    while(m --) {
        ...... 
        if(pos[u] &gt; pos[v]) swap(u, v);  // 询问u、v两个点的LCA，注意要保持欧拉序中u在v前面
        cout &lt;&lt; euler[min_RMQ(pos[u], pos[v] + 1)] &lt;&lt; endl;  // min_RMQ的输入、输出都是下标值，区间表示为左闭右开
    }
}
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://www.luogu.com.cn/problem/P3379">Luogu P3379</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-最大流问题dinic算法">二、最大流问题（Dinic算法）</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>设源点为1, 终点为N。用 G[u][v] 表示点u、v之间的容量大小，求这样一个网络图 G 中的最大流量大小ans。</p>
<h4 id="2-解析-2">2. 解析</h4>
<ul>
<li>Dinic算法 求最大流 <strong>用邻接矩阵G存图</strong>更方便</li>
<li>先进行<strong>bfs</strong>, 判断有无增广路的同时,标记每个点的层号</li>
<li>然后<strong>根据层号进行dfs</strong>, 找增广路, 更新流值, 可能有多条不相交的增广路</li>
<li>循环往复</li>
</ul>
<h4 id="3-模板-2">3. 模板</h4>
<pre><code>bool bfs(){
	memset(dist, -1, sizeof(dist)); // 每次重新标记dist, 因为增加了反向边, 图已经不同
	dist[1] = 0;
	que.push(1);
	while(!que.empty()){
		int u = que.front();
		que.pop();
		for(int v = 1; v &lt;= N; i ++){
			if(G[u][v] &amp;&amp; dist[v] == -1){ 
			//    连接  &amp;&amp; 未被标记 的点 
			dist[v] = dist[u] + 1;
			que.push(v); 
		}
	}
	if(dist[N] == -1) return 0;  // 若无法增广到终点，则表示没有增广路了
	return 1; 
} 

int find(int u, int low){ // low是源点到现在最窄的(剩余流量最小)的边的剩余流量 
	if(u == N) return low; // dfs出口
	for(int v = 1, a; v &lt;= N; i ++){
		if(G[u][v] &amp;&amp; dist[v] == dist[u] + 1 &amp;&amp; (a = find(v, min(low, G[u][v])))){
		//   连接的    &amp;&amp;  是上下层关系的      &amp;&amp; 能连通到汇点  min维护low
			G[u][v] -= a;
			G[v][u] += a; // 增加反向边 起容错作用
			return a; //只要发现一条增广路, 就返回增广的流量 
		}
	} 
	return 0; 
}

int main(){
	//....
	int ans = 0;
	while(bfs()){ // 利用bfs为每个点标记dis, 若标记不到汇点, 说明已经没有增广路 
		int temp;  // 每次增广的流量
		while(temp = find(1, INF)) ans += temp; // 根据dist进行dfs找增广路, 直到找不到为止 
	}
	cout &lt;&lt; ans &lt;&lt; endl;
} 
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[区间问题] 树状数组与线段树归纳]]></title>
        <id>https://river861.github.io/post/qu-jian-wen-ti-shu-zhuang-shu-zu-yu-xian-duan-shu-gui-na/</id>
        <link href="https://river861.github.io/post/qu-jian-wen-ti-shu-zhuang-shu-zu-yu-xian-duan-shu-gui-na/">
        </link>
        <updated>2020-09-13T09:35:29.000Z</updated>
        <summary type="html"><![CDATA[<p>用树状数组和线段树解决一些区间问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>用树状数组和线段树解决一些区间问题。</p>
<!-- more -->
<h3 id="一-树状数组">一、树状数组</h3>
<h4 id="1-定义">1. 定义</h4>
<p>用一个数组C[maxn]模拟树状结构，来表示原数组A[maxn]的区间信息。各操作的复杂度为O(lgn)。</p>
<h4 id="2-解析">2. 解析</h4>
<ul>
<li>lowbit(x) 指一个数x的二进制中，最靠右的1的权值大小。如lowbit(6)=2^1, lowbit(7)=2^0，lowbit(8)=8。</li>
<li>树状数组就是用一个C[maxn]数组来存放原数组A[maxn]的去区间信息。具体而言，C[x]存放了从A[(x-lowbit(x))...x]区间中各元素之和。 A[0]为0，不存放有效值。</li>
<li><strong>[单点更新 区间查询]</strong> 求A[1...x]的区间和就需要求出它所对应的那几个C[j]区间之和，这几个区间通过lowbit向下枚举即可得出；而更改一个值A[i]时就需要更改所有包含了A[i]的C[j]区间，同样可以通过lowit线上枚举来获得。</li>
</ul>
<h4 id="3-变式">3. 变式</h4>
<ul>
<li>
<p><strong>[区间更新 单点查询]</strong><br>
树状数组中存放 <strong>差分值</strong> D[i] = A[i] - A[i - 1]，这样区间更新只用更新区间两端，单点查值就是getSum。</p>
</li>
<li>
<p><strong>[区间更新 区间查询]</strong></p>
<ol>
<li>维护两个数组
<ul>
<li>sum1[maxn]存放差值 D[1]、D[2]、D[3]... 的树状数组；</li>
<li>sum2[maxn]存放 0 * D[1]、1 * D[2]、2 * D[3]... 的树状数组</li>
</ul>
</li>
<li>更新操作要同时更新 sum1[maxn]、sum2[maxn]</li>
<li>查询区间的和为：n * ∑D[i] - ∑[(i - 1) * D[i]] = n * sum1[i] - sum2[i]
<ul>
<li>证明如下：</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>A[1] + A[2] + ... + A[n]<br>
= (D[1]) + (D[1] + D[2]) + ... + (D[1] + D[2] + ... + D[n])<br>
= n * D[1] + (n - 1) * D[2] + ... + D[n]<br>
= n * (D[1] + D[2] + ... + D[n]) - (0 * D[1] + 1 * D[2] + ... + (n - 1) * D[n])</p>
</blockquote>
<h4 id="4-模板">4. 模板</h4>
<ul>
<li><strong>[单点更新 区间查询]</strong></li>
</ul>
<pre><code>int A[100010], C[100010]; // 原数组 和 树状数组 A[1...n]有效 

int lowbit(int x){
	return x &amp; -x;
} 

void add(int k, int v){ // 当 A[k] += v时 
	for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v; 
}

int getSum(int k){ // 求 A[1]+...+A[k]时 
	int res = 0;
	for(int i = k; i; i -= lowbit(i)) res += C[i];
	return res;
}
</code></pre>
<ul>
<li><strong>[区间更新 单点查询]</strong></li>
</ul>
<pre><code>int A[100010], C[100010];

int lowbit(int x){
	return x &amp; -x;
}

void add(int k, int v){  // 不变
	for(int i = k; i &lt;= n; i += lowbit(i)) C[i] += v;
}

int getSum(int k){  // 不变
	int res = 0;
	for(int i = k; i; i -= lowbit(i)) res += C[i];
	return res;
}

int main(){
	......
	for(int i = 1; i &lt;= n; i ++){  //从1开始放 
		cin &gt;&gt; A[i];
		add(i, A[i] - A[i - 1]);   // 树状数组放差值 
	}
	......
	add(x, k);  // 在[x, y]区间加上k, 即让这个区间向上突出 
	add(y + 1, -k);
	......
	int ans = getSum(q);  // 查询q位置的值
    ......
}
</code></pre>
<ul>
<li><strong>[区间更新 区间查询]</strong></li>
</ul>
<pre><code>int A[100010];
int sum1[100010]; // 存放了差值D[1]、D[2]、D[3]...的树状数组 
int sum2[100010]; // 存放了0*D[1]、1*D[2]、2*D[3]...的树状数组 

int lowbit(int x){
	return x &amp; -x;
}

void add(int k, int v){   // 加差值和sum2的同时还要加sum2
	for(int i = k; i &lt;= n; i += lowbit(i)) sum1[i] += v, sum2[i] += (k - 1) * v;
}

int getSum(int k){  //  区间和为 n*∑D[i] - ∑[(i-1)*D[i]] = n*sum1[i] - sum2[i]
	int res = 0;
	for(int i = k; i; i -= lowbit(i)) res += k * sum1[i] - sum2[i];
	return res;
}

int main(){
	for(int i = 1; i &lt;= n; i ++){  //从1开始放 
		cin &gt;&gt; A[i];
		add(i, A[i] - A[i - 1]);   // 树状数组放差值 
	}
	......
	add(x, k);  //在[x, y]区间加上k 
	add(y + 1, -k);
	......
	int ans = getSum(q) - getSum(p - 1);  //查询[p, q]位置的值
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-线段树">二、线段树</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>一种强大的能解决区间的修改、查询问题的方法。</p>
<h4 id="2-解析-2">2. 解析</h4>
<p>与树状数组相比，线段树代码量更大，但是适用范围更广。</p>
<ul>
<li>
<p>k为结点编号 根节点为1, 左孩子为 k<em>2, 右孩子为 k</em>2+1<br>
每个函数都包含参数k</p>
</li>
<li>
<p>除建树外共4种情形：单点查询 单点更新 区间查询 区间更新(要用到懒标记f)<br>
一个题目一般只会用到两种</p>
</li>
<li>
<p>线段树一般保持 <strong>左闭右闭</strong> 区间，这样代码会好写一点</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>无论是<strong>更新还是查询，都要down懒标记</strong></li>
<li>一些线段树的变形主要需要特别注意 状态归并 和 <strong>懒标记的更新</strong></li>
</ul>
</li>
</ul>
<h4 id="3-模板">3. 模板</h4>
<pre><code>#include &lt;iostream&gt;
using namespace std;
using ll = long long;
const int maxn = 5e5 + 5;
struct node {
    int l, r, f = 0;
    ll w;
    node() {}
    node(int l, int r, ll w) : l(l), r(r), w(w) {}
} Tree[4 * maxn];
int n, m;
ll a[maxn];

void down(int k) {
    int &amp; v = Tree[k].f;
    Tree[k * 2].w += v * (Tree[k * 2].r - Tree[k * 2].l + 1);
    Tree[k * 2].f += v;
    Tree[k * 2 + 1].w += v * (Tree[k * 2 + 1].r - Tree[k * 2 + 1].l + 1);
    Tree[k * 2 + 1].f += v;
    v = 0;
}

void build(int l, int r, int k) {  // 建树
    if(l == r) {
        Tree[k] = node(l, r, a[l]);
        return;
    }
    int mid = (l + r) / 2;
    build(l, mid, k * 2);
    build(mid + 1, r, k * 2 + 1);
    Tree[k] = node(l, r, Tree[k * 2].w + Tree[k * 2 + 1].w);
}

void update(int x, int v, int k) {  // 单点更新
    if(Tree[k].l == Tree[k].r) {
        Tree[k].w += v;
        return;
    }
    int mid = (Tree[k].l + Tree[k].r) / 2;
    if(x &lt;= mid) update(x, v, k * 2);
    else update(x, v, k * 2 + 1);
    Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w;
}

ll query(int l, int r, int k) {  // 区间查值
    if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) return Tree[k].w;
    if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！
    int mid = (Tree[k].l + Tree[k].r) / 2;
    ll res = 0;
    if(l &lt;= mid) res += query(l, r, k * 2);
    if(r &gt; mid) res += query(l, r, k * 2 + 1);
    return res;
}

void update(int l, int r, int v, int k) {  // 区间更新
    if(l &lt;= Tree[k].l &amp;&amp; r &gt;= Tree[k].r) {
        Tree[k].w += v * (Tree[k].r - Tree[k].l + 1);  // 注意是多个值更新
        Tree[k].f += v;  // 懒标记： 预记儿子们的变化
        return;
    }
    if(Tree[k].f) down(k);  // 懒标记下传
    int mid = (Tree[k].l + Tree[k].r) / 2;
    if(l &lt;= mid) update(l, r, v, k * 2);
    if(r &gt; mid) update(l, r, v, k * 2 + 1);
    Tree[k].w = Tree[k * 2].w + Tree[k * 2 + 1].w;
}

ll query(int x, int k) {  // 单点查值
    if(Tree[k].l == Tree[k].r) return Tree[k].w;
    if(Tree[k].f) down(k); // 查询时也要记得更新懒标记下移！！！
    int mid = (Tree[k].l + Tree[k].r) / 2;
    if(x &lt;= mid) return query(x, k * 2);
    else return query(x, k * 2 + 1);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    build(1, n, 1);
    while(m --) {
        int f, x, y, k;
        // 单点更新 + 区间查值
        // cin &gt;&gt; f;
        // if(f == 1) cin &gt;&gt; x &gt;&gt; y, update(x, y, 1);
        // else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl;

        // 区间更新 + 单点查值
        // cin &gt;&gt; f;
        // if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1);
        // else cin &gt;&gt; x, cout &lt;&lt; query(x, 1) &lt;&lt; endl;

        // 区间更新 + 区间查值
        cin &gt;&gt; f;
        if(f == 1) cin &gt;&gt; x &gt;&gt; y &gt;&gt; k, update(x, y, k, 1);
        else cin &gt;&gt; x &gt;&gt; y, cout &lt;&lt; query(x, y, 1) &lt;&lt; endl;
    }
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[动态规划][经典] 常见的动态规划问题归纳]]></title>
        <id>https://river861.github.io/post/dong-tai-gui-hua-jing-dian-chang-jian-de-dong-tai-gui-hua-wen-ti-gui-na/</id>
        <link href="https://river861.github.io/post/dong-tai-gui-hua-jing-dian-chang-jian-de-dong-tai-gui-hua-wen-ti-gui-na/">
        </link>
        <updated>2020-09-13T09:32:10.000Z</updated>
        <summary type="html"><![CDATA[<p>比如LIS问题</p>
]]></summary>
        <content type="html"><![CDATA[<p>比如LIS问题</p>
<!-- more -->
<h3 id="一-最长上升子序列lis">一、最长上升子序列（LIS）</h3>
<h4 id="1-定义">1. 定义</h4>
<p>给出一个序列a[1...n]，要求你求出其中最长的递增子序列的长度。</p>
<h4 id="2-简单的-on2-算法">2. 简单的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 算法</h4>
<ul>
<li>
<p><strong>原理</strong>：<br>
设 dp[i] 为把<strong>下标i作为最长上升子序列结尾位置</strong> 的最大长度，则 dp[i] = max(dp[1..i]+1)，所有dp[i]初始为1.</p>
</li>
<li>
<p><strong>模板</strong>：</p>
</li>
</ul>
<pre><code>int n, num[maxn], dp[maxn];  // num[maxn]存放了序列，dp[i]表示以a[i]为结尾的最长子序列长度

int main() {
    ......
    int ans = 0;
    for(int i = 1; i &lt;= n; i ++) {
        dp[i] = 1;
        for(int j = 1; j &lt; i; j ++) {
            if(num[i] &gt;= num[j]) dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(ans, dp[i]);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
<h4 id="3-最快的-onlgn-算法">3. 最快的 O(nlgn) 算法</h4>
<ul>
<li><strong>原理</strong>：<br>
以非严格递增子序列为例，主要思想是 <strong>贪心 + 二分</strong>。这种方法不需要dp数组，取而代之，使用的是一个low数组。</li>
</ul>
<ol>
<li>
<p><strong>维护一个 low数组 和 ans</strong><br>
<strong>low[i]表示到当前为止，长度为i的LIS结尾元素的最小值</strong>；<strong>ans为 当前最长LIS长度</strong><br>
对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长，因此该算法贪心地维护出每个长度最小的结尾元素，存放在low[i]中</p>
</li>
<li>
<p><strong>维护方法</strong><br>
对于每一个a[i]，如果a[i] &gt; low[ans]，就把 a[i]接到当前最长的LIS后面，即 low[++ ans] = a[i]；否则， 用 a[i] 更新 low数组 中第一个大于 a[i] 的元素 low[j] = a[i]</p>
</li>
<li>
<p><strong>举个例子</strong><br>
比如1 5 6 3 4，假设当前已经遍历到下标3，则low[] = {1, 5, 6}，下一个数字3将会把5更新为3，表示到目前为止（1 5 6 3），长度为2的结尾最小的上升子序列为 1 3 。更新后下一个4才会有可能成为长度为3的上升子序列的末尾（1 3 4），这就是贪心起到的作用（总是维护最小的结尾值）。</p>
</li>
</ol>
<ul>
<li><strong>模板</strong>：</li>
</ul>
<pre><code>int nums[maxn], low[maxn];  // num[maxn]存放了序列，low[i]表示长度为i的LIS结尾元素的最小值

// 贪心 + 二分 解法 O(nlogn) 
int main(){
	fill(low + 1, low + n + 1, INF);
	int ans = 0;  // low和ans搭配使用，ans就是当前维护到的最长长度
	for(int i = 1; i &lt;= n; i ++){
		if(ans == 0 || num[i] &gt;= low[ans]) low[++ ans] = nums[i];                            // 若为严格递增，改为 &gt;
		else{
			int j = upper_bound(low + 1, low + n + 1, nums[i]) - low;    // 若为严格递增，改为 lower_bound
			low[j] = nums[i];
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
} 
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p>Nowcoder 旅行青蛙</p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p><a href="https://www.cnblogs.com/mengxm-lincf/archive/2011/07/12/2104745.html">LIS-参考博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[动态规划] 数位dp方法归纳]]></title>
        <id>https://river861.github.io/post/dong-tai-gui-hua-shu-wei-dp-fang-fa-gui-na/</id>
        <link href="https://river861.github.io/post/dong-tai-gui-hua-shu-wei-dp-fang-fa-gui-na/">
        </link>
        <updated>2020-09-13T08:30:20.000Z</updated>
        <summary type="html"><![CDATA[<p>数位dp问题其实就是模板题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>数位dp问题其实就是模板题。</p>
<!-- more -->
<h3 id="一-定义">一、定义</h3>
<p>求出在给定<strong>区间</strong> [A,B] 内，符合条件 f(i) 的数i的<strong>个数</strong>。条件f(i)一般与数的大小无关，而<strong>与数的组成有关</strong>。由于数是按位dp，数的大小对复杂度的影响很小。</p>
<p>简单来说，就是解决一些与区间中的数字的计数问题，计数条件一般与数的组成有关。</p>
<h3 id="二-状态量">二、状态量</h3>
<p>一般采用记忆化搜索的方式来实现dp，dp的状态经常包括pos、pre、cnt、lead、limit这几项：</p>
<ul>
<li>pos：当前处理的是数位的第几项，一般从高往低走</li>
<li>pre：当前位的前几位的状态，由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定）</li>
<li>cnt：随着pos的前进需要维护的一些答案值/计数值</li>
<li>lead：当前位是否位前导0位</li>
<li>limit：当前位的最大值是否存在限制</li>
</ul>
<h3 id="三-记忆化搜索">三、记忆化搜索</h3>
<p>把dfs的答案值存放在dp[pos][pre][cnt][...]数组中，以避免重复计算。</p>
<ul>
<li>
<p>原理：从pos开始的低位dp答案会在高位值的枚举遍历中被反复调用。若从某个pos开始的dp它的前置状态pre和之前的某一次处理完全一样，则无需再重复计算，直接返回之前的答案值即可。因为所拥有的条件和上一次完全一样。</p>
</li>
<li>
<p>注意：当当前位为前导0或当前位受到限制时，没有必要将该值记录到dp数组。因为这些状态并不会被重复使用。</p>
</li>
</ul>
<h3 id="四-模板">四、模板</h3>
<p>以下模板大多数情况可套用，但部分细节还是需要结合具体题意进行考虑。</p>
<pre><code>ll a[20], dp[20][20]; // a是用来装数位最高值的数组，dp是memo数组

ll dfs(ll pos, ll pre, ll cnt, bool lead, bool limit) {
    if(pos == 0) return cnt;  // 已经遍历完一个数的情形
    if(!lead &amp;&amp; !limit &amp;&amp; dp[pos][pre][...] != -1) return dp[pos][pre][...];  // 记忆化搜索
    
    ll res = 0, maxv = limit ? a[pos] : 9;  // 计算当前位最大值
    for(ll i = 0; i &lt;= maxv; i ++) {
        // 若当前位是前导0
        if(i == 0 &amp;&amp; lead) res += dfs(pos - 1, ...., 1, limit &amp;&amp; i == maxv);
        // 若当前位是最高位
        else if(i &amp;&amp; lead) res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv);
        // 正常情况
        else res += dfs(pos - 1, ...., 0, limit &amp;&amp; i == maxv);
    }

    if(!lead &amp;&amp; !limit) dp[pos][cnt] = res;
    return res;  // 注意区分res和cnt，res是问题的答案，cnt是当前状态维护的小答案，res由最终的cnt累加而成
}

ll cal(ll num) {
    ll pos = 0;
    while(num) a[++ pos] = num % 10, num /= 10;  // 把数按位拆分（数位dp的前提）
    memset(dp, -1, sizeof(dp));  // memo数组初始化为-1
    return dfs(pos, 0, 1, 1);  // 从高位往低位dp
}

int main() {
    ......
    // 注意！！！l为0时一般要特别处理，因为数位dp的过程会将0一直当作前导0从而忽略了数值0这一个数，不过由于是计算差值所以大部分情况不影响
    cout &lt;&lt; cal(r, i) - cal(l - 1, i);  // 将区间计算转化为差值计算
    ......
}
</code></pre>
<h3 id="五-例题">五、例题</h3>
<p><a href="https://blog.nowcoder.net/n/616849ad0fc14a69b57af2e4e78191fc">Nowcoder 17867</a><br>
<a href="https://blog.nowcoder.net/n/4d0c2930acc84d6c97c2e356edaeb7cd">ZJOI 2010</a></p>
<blockquote>
<p>数位dp就是模板题！！！</p>
</blockquote>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p><a href="https://www.luogu.com.cn/blog/virus2017/shuweidp">参考博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[数学][经典] 常见的数学方法归纳]]></title>
        <id>https://river861.github.io/post/shu-xue-jing-dian-chang-jian-de-shu-xue-fang-fa-gui-na/</id>
        <link href="https://river861.github.io/post/shu-xue-jing-dian-chang-jian-de-shu-xue-fang-fa-gui-na/">
        </link>
        <updated>2020-09-10T08:03:39.000Z</updated>
        <summary type="html"><![CDATA[<p>一些数学算法题中常用的技巧，包括gcd、exgcd、快速幂、逆元、组合数等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一些数学算法题中常用的技巧，包括gcd、exgcd、快速幂、逆元、组合数等。</p>
<!-- more -->
<h3 id="基本说明">基本说明</h3>
<p>由于数学类方法经常性混合使用（比如组合数+快速幂），因此例题在最后统一给出。</p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="一-最大公约数和最小公倍数gcd">一、最大公约数和最小公倍数（gcd）</h3>
<h4 id="1-定义">1. 定义</h4>
<p>没啥好说，大家都懂。最大公约数 gcd(a,b) ，最小公倍数 lcm(a,b) 。</p>
<h4 id="2-解析">2. 解析</h4>
<p>求最大公约一般用辗转相除法，最小公倍数可以由最大公约数导出：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>⋅</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) \cdot lcm(a, b) = a \cdot b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p>同时注意为了防止a*b溢出，最终我们最小公倍数用下述公式求解：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>⋅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">lcm(a, b) = a / gcd(a, b) \cdot b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<h4 id="3-模板">3. 模板</h4>
<pre><code>ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-扩展欧几里得算法exgcd">二、扩展欧几里得算法（exgcd）</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>上面说的求最大公约数的方式实际上叫<strong>欧几里得算法</strong>，而这里要讲的是它的升级版，不仅可以计算出前面说的最小公约数，还可以求出相应的“不定方程解”.</p>
<h4 id="2-解析-2">2. 解析</h4>
<p>exgcd可以快速求出下面方程中的x、y、gcd(a,b)：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ax + by = gcd(a, b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>上面的公式为裴蜀定理，有很多有用的结论：</p>
<ul>
<li>上述式子一定有整数解，通过exgcd可以求出其中一组整数解</li>
<li>若要求出其它解，只需要 <strong>x+=b/gcd(a,b)，y-=a/gcd(a,b)</strong> 即可
<ul>
<li>注意不要漏了除以 gcd(a, b)</li>
<li>+、-可以互换，相当于从另一个方向找其它解</li>
</ul>
</li>
<li>对于ax+by=c，若c不是gcd(a, b)的倍数，则该方程无解</li>
<li>......</li>
</ul>
<h4 id="3-模板-2">3. 模板</h4>
<p>注意 在求解 ax+by=c 时<strong>要特判 a、b等于0 的情况</strong>。</p>
<pre><code>ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) {
    if(b == 0) {
        y = 0, x = 1;
        return a;
    }
    ll res = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return res;
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="三-快速幂算法">三、快速幂算法</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>一种用来快速求解指数很大的幂运算的算法。</p>
<h4 id="2-解析-3">2. 解析</h4>
<p>原理是将幂次减半，底数平方，并以此类推直到幂次为0。比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>10</mn></msup><mo>=</mo><msup><mn>9</mn><mn>5</mn></msup><mo>=</mo><mo>(</mo><msup><mn>9</mn><mn>4</mn></msup><mo>)</mo><mo>(</mo><msup><mn>9</mn><mn>1</mn></msup><mo>)</mo><mo>=</mo><mo>(</mo><mn>8</mn><msup><mn>1</mn><mn>2</mn></msup><mo>)</mo><mo>(</mo><msup><mn>9</mn><mn>1</mn></msup><mo>)</mo><mo>=</mo><mo>(</mo><mn>656</mn><msup><mn>1</mn><mn>1</mn></msup><mo>)</mo><mo>(</mo><msup><mn>9</mn><mn>1</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">3^{10}=9^5=(9^4)(9^1)=(81^2)(9^1)=(6561^1)(9^1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这样原式的答案就是6561*9了。</p>
<h4 id="3-模板-3">3. 模板</h4>
<ul>
<li>普通版，注意用long long：</li>
</ul>
<pre><code>LL fast_pow(LL a, LL b) {  // 快速幂算法
    LL res = 1;
    while(b) {
        if(b &amp; 1) res = res * a;  // 指数为奇时分一个出来
        b &gt;&gt;= 1;  // 指数减半
        a = a * a;  // 底数平方
    }
    return res;
}
</code></pre>
<ul>
<li>带mod版，注意用long long：</li>
</ul>
<pre><code>LL fast_pow_mod(LL a, LL b) {  // 快速幂算法 带mod版
    LL res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return res % mod;
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="四-除法求模逆元">四、除法求模（逆元）</h3>
<h4 id="1-定义-4">1. 定义</h4>
<p>我们都知道，对于加法、减法、乘法，求模运算都可以提前，即：</p>
<blockquote>
<p>(a + b) % p = (a % p + b % p) % p<br>
(a - b) % p = (a % p - b % p ) % p<br>
(a * b) % p = (a % p * b % p) % p<br>
而除法求模不行，因此对于除法求模我们需要使用一种专门的方法，即转化为乘法求模。</p>
</blockquote>
<h4 id="2-解析-4">2. 解析</h4>
<p>由费马小定理：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>b</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">b^{m - 1}  \equiv 1 (mod m) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>转化一下则有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>b</mi></mfrac><mo>≡</mo><msup><mi>b</mi><mrow><mi>m</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{b} \equiv b^{m-2} (mod m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>也就是说，对于除以b取模可以转化为乘以b^(m-2)取模！ 这样就成功将除法取模转化为了乘法取模。但要注意b、m必须互质。好消息是，这里的m一般就是题目给出的mod值，一般题目给出的都是一个很大的质数。</p>
<p>因此我们一般称b^(m-2)为b的 <strong>逆元</strong> ，除以b取模相当于乘以b的逆元取模。<br>
而对于b^(m-2)的求法，参见前文的 <strong>快速幂算法</strong> 即可。</p>
<h4 id="3-模板-4">3. 模板</h4>
<p>以求组合数的模为例，里面要用到除法（除数为阶乘）求模：</p>
<pre><code>int C(int n, int m) {  // n! / (n-m)! / m! =&gt; n! * [(n-m)!]^(mod-2) * [m!]^(mod-2)
    return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod;
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="四-指数求模">四、指数求模</h3>
<h4 id="1-定义-5">1. 定义</h4>
<p>指数比较大的情况一般用快速幂可以解决，然而....</p>
<p>有时用快速幂还是会超时....这个时候也需要将指数模一模.</p>
<h4 id="2-解析-5">2. 解析</h4>
<p>由费马小定理：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>b</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mtext> </mtext><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">b^{m-1} \equiv 1\ (mod\ m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>将k组上式乘到下面这个式子中</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>B</mi></msup><mo>≡</mo><mi>a</mi><mi>n</mi><mi>s</mi><mtext> </mtext><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a^{B} \equiv ans\ (mod\ m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>B</mi><mo>+</mo><mi>k</mi><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></msup><mo>≡</mo><mi>a</mi><mi>n</mi><mi>s</mi><mtext> </mtext><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a^{B+k(m-1)} \equiv ans\ (mod\ m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>上面两个式子说明，可以对指数 模(m-1)，答案不会变化。</p>
<h4 id="3-结论">3. 结论</h4>
<p><strong>在计算指数运算时，要是指数太大，可以 模(m-1)，答案不会变化</strong>。m为题目指定的mod。</p>
<hr>
<h3 id="五-组合数cn-m">五、组合数（C(n, m)）</h3>
<h4 id="1-定义-6">1. 定义</h4>
<p>在一些题目中需要用到组合数，甚至通过组合数直接输出结果，因此有必要学习一下组合数的计算方式。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>)</mo><mo>!</mo><mi>m</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C(n, m) = \frac{n!}{(n - m)! m!}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span><span class="mord mathdefault">m</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h4 id="2-解析-6">2. 解析</h4>
<p>两种方法</p>
<ul>
<li><strong>方法一</strong>：通过动态规划预处理出C[maxn][maxn]数组，预处理用时O(n^2)，查询用时O(1)<br>
一般只要预处理不会超时、空间不会爆 就优先用这个！！</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>C</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>C</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n, m) = C(n - 1, m - 1) + C(n - 1, m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li><strong>方法二</strong>：仅预处理出阶乘数fac[maxn]和阶乘数的逆元inv_fac[maxn]，预处理时间O(n*lg(mod))，查询用时稍微慢一点的O(1)<br>
若方法一预处理超时了 或 内存爆了 就用这个。</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>c</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>⋅</mo><mi>i</mi><mi>n</mi><mi>v</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>a</mi><mi>c</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>)</mo><mo>⋅</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>⋅</mo><mi>i</mi><mi>n</mi><mi>v</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>a</mi><mi>c</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>⋅</mo><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">C(n, m) = fac[n]\cdot inv\_fac(n - m) \cdot mod \cdot inv\_fac(m) \cdot mod
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span></span></p>
<h4 id="3-模板-5">3. 模板</h4>
<ul>
<li><strong>方法一</strong>：</li>
</ul>
<pre><code>void init(ll n) {
    C[0][0] = 1;
    for(ll i = 1; i &lt;= n; i ++) {
        for(ll j = 0; j &lt;= i; j ++) {
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
}
</code></pre>
<ul>
<li><strong>方法二</strong>：</li>
</ul>
<pre><code>
LL fast_pow_mod(LL a, LL b) {  // 快速幂
    LL res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return res % mod;
}
 
void init(int n) {  // 预处理
    fac[0] = inv_fac[0] = 1;
    for(int i = 1; i &lt;= n; i ++) {
        fac[i] = fac[i - 1] * i % mod;
        inv_fac[i] = fast_pow_mod(fac[i], mod - 2);
    }
}
 
int C(int n, int m) {  // 计算组合数
    return fac[n] * inv_fac[n - m] % mod * inv_fac[m] % mod;
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="last-例题">Last. 例题</h3>
<p><a href="https://blog.nowcoder.net/n/44393c613d934015bd7c7a54888535a0">Nowcoder 数列统计</a><br>
<a href="https://ac.nowcoder.com/acm/contest/7539/F">Nowcoder 子序列</a><br>
<a href="https://ac.nowcoder.com/acm/contest/7329/D">Nowcoder 火柴排队</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论] 最短路问题归纳]]></title>
        <id>https://river861.github.io/post/tu-lun-zui-duan-lu-wen-ti-gui-na/</id>
        <link href="https://river861.github.io/post/tu-lun-zui-duan-lu-wen-ti-gui-na/">
        </link>
        <updated>2020-09-04T07:59:17.000Z</updated>
        <summary type="html"><![CDATA[<p>包括Dijkstra算法、Spfa算法、Floyd算法以及它们的变形。</p>
]]></summary>
        <content type="html"><![CDATA[<p>包括Dijkstra算法、Spfa算法、Floyd算法以及它们的变形。</p>
<!-- more -->
<h3 id="基本原则">基本原则</h3>
<ul>
<li>
<p>首先看题目n的数量级，当 <strong>n&lt;1000</strong> 时，可以使用 [Floyd算法] 快速秒杀几乎所有题型</p>
</li>
<li>
<p>否则 若题目中所有边全为正权，则使用 [Dijkstra算法]</p>
</li>
<li>
<p>否则 当出现负权时，使用 [spfa算法]</p>
</li>
<li>
<p>注意一些隐蔽的最短路问题，比如题目会换一种问法。详见最短路的各种变形题。</p>
</li>
</ul>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="一-正权单源最短路-dijkstra算法">一、正权单源最短路 —— Dijkstra算法</h3>
<h4 id="1-定义">1. 定义</h4>
<p>计算正权图上的单源最短路，即从单个源点出发到所有结点的最短路。包含无向图或有向图。</p>
<h4 id="2-解析">2. 解析</h4>
<p>使用Dijkstra算法。时间复杂度O(mlgn)，一般够用。</p>
<h4 id="3-模板">3. 模板</h4>
<pre><code>struct node {  // node结构是存放在优先队列中的结构
    int u, d;
    node(int u, int d) : u(u), d(d) {}
    bool operator &lt; (const node&amp; rhs) const {
        return d &gt; rhs.d;  // 由于默认为最大堆, 而我们希望最小的先出列
    }
};
struct edge {  //edge结构仅用于存图
    int to, w;
    edge(int to, int w) : to(to), w(w) {}
};
vector&lt;edge&gt; G[maxn];
int n, m, vis[maxn], d[maxn];
 
void Dij(int s) {
    fill(d, d + n + 1, INF), d[s] = 0;  // 初始化d数组
    fill(vis, vis + n + 1, 0);
    priority_queue&lt;node&gt; que;
    que.push(node(s, 0));
    while(!que.empty()) {
        int u = que.top().u;
        que.pop();
        if(vis[u]) continue;  // vis就写在这两行，是为了忽略掉松弛前的结点（因为并没有从队列中删除，只是压入了d更小的状态而已），
        vis[u] = 1;           // 因此放在这里进行判断，这是和bfs不同的
        for(const edge&amp; e : G[u]) {
            if(d[e.to] &gt; d[u] + e.w) {  // 松弛操作
                d[e.to] = d[u] + e.w;
                que.push(node(e.to, d[e.to]));  // 压入了松弛后的结点，然而并没有删除原结点，因此要依靠上面的vis
            }
        }
    }
}
 
int main() {
    ......
    Dij(1);
    ......
}
</code></pre>
<p>注意Dijkstra的模板和bfs有点像，但是还是不一样的：</p>
<ul>
<li>一个用优先队列，一个用普通队列</li>
<li>使用vis数组的原因不同</li>
</ul>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/6b480880426c40aa85364d69565b621e">Poj 2397</a><br>
Poj 1847<br>
Poj 1502</p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-带负权的单源最短路-spfa算法">二、带负权的单源最短路 —— spfa算法</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>计算带负权的图上的单源最短路，由于可能存在负环，因此Dijkstra算法不可用。</p>
<h4 id="2-解析-2">2. 解析</h4>
<p>这时可以使用spfa算法。最坏时间复杂度O(nm)。</p>
<ul>
<li>
<p>带负权的最短路径问题，可以使用Bellman-Ford或它的优化版本，即spfa算法。spafa算法能解决带负权的单源最短路问题，同时判断是否存在负环。最坏时间复杂度为O(nm)。比Dijkstra慢，因此对于正权的单源最短路我们使用Dijkstra，而对于带负权的就只能使用spfa算法了。</p>
</li>
<li>
<p><strong>spfa算法的原理</strong>：先从Bellman-Ford算法的原理开始，Bellman-Ford算法通过将每条边松弛n-1次来求出每个点的最终d[maxn]，即松弛到不能再松弛了。而如果第n次还存在边可以继续松弛，说明存在负环。而spfa通过让已经松弛得不能再松弛的边不再入队来实现减少冗余的松弛操作，用队列来存储每一轮迭代后还需要继续松弛的边，就是这样一个优化。</p>
</li>
</ul>
<p>spfa的模板与Dijkstra有点像，需要注意区分。</p>
<h4 id="3-模板-2">3. 模板</h4>
<pre><code>struct edge {  // 用于存图的edge结构
    int to, w;
    edge(int to, int w) : to(to), w(w) {}
};
vector&lt;edge&gt; G[maxn];
int n, inq[maxn], cnt[maxn], d[maxn];
 
bool spfa(int s) {
    fill(d, d + n + 1, INF); d[s] = 0;
    fill(inq, inq + n + 1, 0);  // inq用于标记每个点是否在队列中
    fill(cnt, cnt + n + 1, 0);  // cnt用于统计每个点的入队次数
    queue&lt;int&gt; que;  // 只需要使用普通队列
    que.push(s), inq[s] = 1, ++ cnt[s];
    while(!que.empty()) {
        int u = que.front(); que.pop();
        inq[u] = 0;  // 可以重复入队
        for(const edge&amp; e : G[u]) {
            if(d[e.to] &gt; d[u] + e.w) {  // 松弛操作
                d[e.to] = d[u] + e.w;
                que.push(e.to), inq[e.to] = 1;
                if(++ cnt[e.to] &gt; n) return 1;  // 入队超过n次说明有负环
            }
        }
    }
    return 0;
}
 
int main() {
    ......
    spfa(1);
    ......
}
</code></pre>
<ul>
<li>要注意区分Dijkstra模板和spafa模板：
<ul>
<li>Dijkstra使用优先队列，spfa使用普通队列</li>
<li>Dijkstra使用vis数组排出重复点；spfa使用inq记录是否在队列中，用cnt记录入队次数，允许重复入队</li>
</ul>
</li>
<li>若原图不连通，需要加一个点使得原图连通后再用spfa算法来判断负环，否则会漏判。</li>
</ul>
<h4 id="4-例题-2">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/cea9e8a2dc5b4edea95df9a3f9a57119">Poj 3259</a><br>
Poj 3169<br>
LightOJ 1074</p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="三-多源最短路-floyd算法">三、多源最短路 —— Floyd算法</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>求任意两点之间的最短路。包含无向图或有向图，正权图、负权图。</p>
<h4 id="2-解析-3">2. 解析</h4>
<p>使用Floyd算法。时间复杂度O(n^3)。对于多源最短路问题只能使用Floyd算法，对于单源最短路问题，若n比较小，也可以使用Floyd算法来快速解决。因为代码简单啊😀</p>
<h4 id="3-模板-3">3. 模板</h4>
<pre><code>const int INF = 1 &lt;&lt; 29;
int n, d[maxn][maxn];

void init() {
    for(int i = 1; i &lt;= n; i ++) {  // 初始化d
        for(int j = 1; j &lt;= n; j ++) d[i][j] = INF;
        d[i][i] = 0;
    }
}

void Floyd() {
    for(int k = 1; k &lt;= n; k ++) {  // 枚举中间点
        for(int i = 1; i &lt;= n; i ++) {
            for(int j = 1; j &lt;= n; j ++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}

int main() {
    ......
    init();
    Floyd();
    ......
}
</code></pre>
<ul>
<li>要注意Floyd中会有INF相加的情况，因此INF值不能太大，这里取的是1&lt;&lt; 29.</li>
</ul>
<h4 id="4-例题-3">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/693ed45e3cad49b4b7e51e525bea3de7">Uva 567</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="四-差分约束问题与最短路的关系">四、差分约束问题与最短路的关系</h3>
<h4 id="1-定义-4">1. 定义</h4>
<p>即给出对n个数m组约束不等式，求其中某两个数的最值。</p>
<h4 id="2-解析-4">2. 解析</h4>
<ul>
<li>
<p>差分约束问题可以转化为最短路/最长路问题解决。</p>
</li>
<li>
<p>原理：以问最大值为例，问x-y&lt;=多少时，肯定是通过若干B-A&lt;=w的约束条件才可能获得，而B-A&lt;=w这一不等式可以理解为d[B]&lt;=d[A]+w，这正好符合与最短路问题中的松弛操作的条件（d[u]&gt;d[v]+w）相反，也就是松弛操作会使得这一个个约束条件被满足，因此最短路问题的算法就可以得到满足所有约束条件的不等式的一组解。这样就可以得到d[x]与d[y]的差值了。</p>
</li>
</ul>
<h4 id="3-模板-4">3. 模板</h4>
<p>具体规则如下：</p>
<ol>
<li>首先看问题，若问题<strong>问最大值则可以转化为最短路问题</strong>；<strong>问最小值则可以转化为最长路问题</strong>；</li>
<li>若为最短路问题，则将所有约束转化为B-A&lt;=w的形式；最长路问题则转化为B-A&gt;=w的形式；</li>
<li><strong>B-A&lt;=w对应于d[B]&lt;=d[A]+w，也就是从点A到B的有向路径权值为w</strong>；<br>
然后就可以用Dijkstra、spfa或Floyd算法来秒杀了。</li>
<li><strong>若存在负环，则表示无解；若d为INF，表示有无限个解</strong>。</li>
</ol>
<h4 id="4-例题-4">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/4ab5d9ec4f3945829d259dc8c23dc5fa">Poj 3159</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="五-几种常见的最短路变形题">五、几种常见的最短路变形题</h3>
<h4 id="1-求最大边权的最小值-最小边权的最大值">1. 求最大边权的最小值 / 最小边权的最大值</h4>
<ul>
<li>
<p><strong>做法</strong><br>
以求最大边权的最小值为例：</p>
<ul>
<li>Floyd做法：<br>
原松弛操作：d[i][j]= min(d[i][j], d[i][k] + d[k][j]);<br>
变形后的松弛操作：d[i][j]= min(d[i][j] ,max( d[i][k] , d[k][j]));</li>
<li>Dijkstra/spfa算法：<br>
原松弛操作 ： d[v]= min(d[v], d[u]+w);<br>
变形后的松弛操作 ： d[v]= min(d[v] , max(d[u], w));</li>
</ul>
</li>
<li>
<p><strong>例题</strong><br>
Poj 2253<br>
Poj 1797</p>
</li>
</ul>
<h4 id="2-求往返最短路的最大值-和">2. 求往返最短路的最大值 / 和</h4>
<ul>
<li>
<p><strong>做法</strong></p>
<ul>
<li>数据量小的用Floyd算法秒杀；</li>
<li>否则通过对原图和反图（所有有向边反向）各做一次Dijkstra/spfa来解决。</li>
</ul>
</li>
<li>
<p><strong>例题</strong><br>
Poj 1511<br>
Poj 3268</p>
</li>
</ul>
<h4 id="3-确定排名">3. 确定排名</h4>
<ul>
<li>
<p><strong>做法</strong><br>
用Floyd算法，dp[u][v]表示u打败了v：</p>
<ul>
<li>原松弛操作 ： d[i][j]= min(d[i][j], d[i][k] + d[k][j]);</li>
<li>变形后的松弛操作 ： d[i][j] = (d[i][k] &amp;&amp; d[k][j]) ? 1 : 0;</li>
</ul>
</li>
<li>
<p><strong>例题</strong><br>
Poj 3660</p>
</li>
</ul>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p><a href="https://blog.csdn.net/JiangHxin/article/details/101999496">最短路变形-参考博客</a><br>
<a href="https://blog.csdn.net/whereisherofrom/article/details/78922648">差分约束-参考博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论] 最小生成树问题归纳]]></title>
        <id>https://river861.github.io/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/</id>
        <link href="https://river861.github.io/post/tu-lun-zui-xiao-sheng-cheng-shu-wen-ti-gui-na/">
        </link>
        <updated>2020-09-04T07:52:49.000Z</updated>
        <summary type="html"><![CDATA[<p>包括最小生成树、次小生成树和边权极差最小的生成树算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>包括最小生成树、次小生成树和边权极差最小的生成树算法。</p>
<!-- more -->
<h3 id="基本定义">基本定义</h3>
<p>本文的代码基本按照如下的图论模型进行定义，后文用的结构若与此相同则不再赘述：</p>
<pre><code>struct edge {
    int u, v, w;
    edge(int u, int v, int w) : u(u), v(v), w(w) {}
    bool operator &lt; (const edge&amp; rhs) const {  // 边按权值排序
        return w &lt; rhs.w;
    }
};
vector&lt;edge&gt; E;  // 存储所有边
int n, m, Fa[maxn];  // Fa为并查集所需的数组
 
int find(int x) {  // 并查集的find函数
    return Fa[x] == x ? x : Fa[x] = find(Fa[x]);
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="一-最小生成树">一、最小生成树</h3>
<h4 id="1-定义">1. 定义</h4>
<p>把若干点连成连通图，求最少连成的连通图的最小边权和。</p>
<h4 id="2-解析">2. 解析</h4>
<p>这是最基础的题型，直接套用Kruskal算法的模板即可</p>
<h4 id="3-模板">3. 模板</h4>
<pre><code>int main() {
    ......
    for(int i = 0; i &lt; n; i ++) Fa[i] = i;  // Fa初始化
    sort(E.begin(), E.end());  // 按结点从小到大排序
    int ans = 0;
    for(const auto&amp; e : E) {
        int u = find(e.u), v = find(e.v);
        if(u == v) continue;
        Fa[u] = v;   // 若不连通则将其连通
        ans += e.w;
    }
    .....
}
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/5fbad3316353403cad329295c8aa047f">Uva 10034</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-次小生成树">二. 次小生成树</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>顾名思义，就是边权和第二小的生成树</p>
<h4 id="2-解析-2">2. 解析</h4>
<p>其实也比较简单，按照以下步骤即可：</p>
<ol>
<li>
<p>求出最小生成树mst</p>
</li>
<li>
<p>通过以每个点为根分别进行dfs，得到maxW[maxn][maxn]数组。其中maxW[root][v]表示最小生成树mst上从root到v的路径上的最大的一条边的权值。</p>
</li>
<li>
<p>遍历所有不在mst上的边，比如为（u, v），用它去替换mst上从u到v路径上的最大边，从而得到一系列次小生成树替补。这些次小生成树替补权值和最小的那个就是次小生成树。<br>
时间复杂度为O(n^2+mlogm)，基本够用了。</p>
</li>
</ol>
<h4 id="3-模板-2">3. 模板</h4>
<p>原理简单，就是代码量较大...要维护一个存放边的容器E，同时还要维护一个存放最小生成树的边的容器mst。</p>
<pre><code>struct edge {
    int u, v, w;
    bool flag = 0;
    edge(int u, int v, int w) : u(u), v(v), w(w) {}
    bool operator &lt; (const edge&amp; rhs) const {
        return w &lt; rhs.w;
    }
};
struct mst_edge {
    int v, w;
    mst_edge(int v, int w) : v(v), w(w) {}
};
vector&lt;edge&gt; E;  // 存放所有边的容器
vector&lt;mst_edge&gt; mst[maxn];  // 存放最小生成树的容器
int n, m, Fa[maxn], maxW[maxn][maxn], ans1, ans2;  // ans1, ans2分别为最小生成树和次小生成树的边权和
 
int find(int x) {
    return Fa[x] == x ? x : Fa[x] = find(Fa[x]);
}
 
void Kruskal() {
    for(int i = 1; i &lt;= n; i ++) Fa[i] = i;
    sort(E.begin(), E.end());
    ans1 = 0;
    for(edge&amp; e : E) {
        int u = find(e.u), v = find(e.v);
        if(u == v) continue;
        Fa[u] = v;
        ans1 += e.w;
        e.flag = 1;  // 标记这条边在mst中
        mst[e.u].push_back(mst_edge(e.v, e.w));  // 将最小生成树保存起来
        mst[e.v].push_back(mst_edge(e.u, e.w));
    }
}
 
void dfs(int root, int cur, int fa, int val) {  // 遍历最小生成树来生成maxW数组
    maxW[root][cur] = val;
    for(const mst_edge&amp; e : mst[cur]) if(e.v != fa) {
        dfs(root, e.v, cur, max(val, e.w));
    }
}
 
void SKruskal() {
    Kruskal();  // 1. 求最小生成树mst
    for(int i = 1; i &lt;= n; i ++) dfs(i, i, 0, 0);  // 2. 求maxW[root][v]数组
    ans = INF;
    for(const edge&amp; e : E) if(e.flag == 0) ans2 = min(ans2, ans1 - maxW[e.u][e.v] + e.w);
    // 3. 用不在树上的边逐个替换，然后取最小的那个树就是次小生成树
}
 
int main() {
    ......
    SKruskal();
    ......
}
</code></pre>
<h4 id="4-例题-2">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/032d77826377463db81e8b1d2a2526b9">Uva 10600</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="三-边权极差最小的生成树">三. 边权极差最小的生成树</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>即最大边减最小边的值尽量小的生成树</p>
<h4 id="2-解析-3">2. 解析</h4>
<ul>
<li>
<p>我们知道求最小生成树是用Kruskal算法，这里其实也是一样：我们枚举生成树的最小边E[l]，然后每次只从边权大于这条最小边边权的边中进行最小生成树的生成，这样就能得到这个生成树的最大边边权。这样枚举完后，我们就能得到边权极差最小的生成树了。</p>
</li>
<li>
<p>正确性证明：为什么最小生成树T就一定是这个最小边对应的苗条度最小的生成树呢？仔细回想一下Kruskal算法，最小生成树T是通过从小到大枚举边得到的，如果这个最小边对应的使得苗条度最小的最大边不在这个T中的话，那就是说存在一个由边权小于这个最大边的一组边构成的一棵更小的生成树，这就与T是最小生成树矛盾了。</p>
</li>
</ul>
<h4 id="3-模板-3">3. 模板</h4>
<pre><code>int main() {
    ......
    sort(E.begin(), E.end());
    int ans = INF;
    for(int l = 0, r; l &lt; E.size(); l ++) {  // 枚举最小边l，然后通过Kruskal求最大边r
        for(int i = 1; i &lt;= n; i ++) Fa[i] = i;
        int cnt = 0;  // 用cnt记录加的边的条数，以此判断图是否连通完毕
        for(int i = l; i &lt; E.size(); i ++) {
            int u = find(E[i].u), v = find(E[i].v);
            if(u == v) continue;
            Fa[u] = v;
            if(++ cnt == n - 1) {
                r = i;
                break;
            }
        }
        if(cnt == n - 1) ans = min(ans, E[r].w - E[l].w);
    }
    ......
}
</code></pre>
<h4 id="4-例题-3">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/466c1742761349e19ab1db07b5fb5878">Uva 1395</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[枚举] 暴力求解之枚举方法归纳]]></title>
        <id>https://river861.github.io/post/mei-ju-bao-li-qiu-jie-zhi-mei-ju-fang-fa-gui-na/</id>
        <link href="https://river861.github.io/post/mei-ju-bao-li-qiu-jie-zhi-mei-ju-fang-fa-gui-na/">
        </link>
        <updated>2020-09-04T07:46:20.000Z</updated>
        <summary type="html"><![CDATA[<p>包括枚举排列、枚举集合、回溯法、IDA*等算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>包括枚举排列、枚举集合、回溯法、IDA*等算法。</p>
<!-- more -->
<h3 id="一-枚举排列">一、枚举排列</h3>
<h4 id="1-定义">1. 定义</h4>
<p>枚举出一个序列a[maxn]的所有排列。</p>
<h4 id="2-解析">2. 解析</h4>
<p>枚举排列 最简单的方法是运用STL的 <strong>next_permutation函数</strong>.</p>
<h4 id="3-模板">3. 模板</h4>
<pre><code>int a[maxn];

int main(){
        ......
	sort(a, a + n);
	do{
		for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;  // 打印排列
		cout &lt;&lt; endl;
	} while(next_permutation(a, a + n));
} 
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="二-枚举集合">二、枚举集合</h3>
<h4 id="1-定义-2">1. 定义</h4>
<p>枚举出一个序列a[maxn]的所有子集。</p>
<h4 id="2-解析-2">2. 解析</h4>
<p>枚举子集 最简单的方法是 <strong>二进制法</strong>。</p>
<ul>
<li>
<p>设A、B为两个集合的二进制表示，则</p>
<ul>
<li>交集表示为 A &amp; B</li>
<li>并集表示为 A | B</li>
<li>对称差集表示为 A ^ B</li>
<li>补集表示为 ALL ^ A [其中 ALL = (1 &lt;&lt; n) - 1]</li>
</ul>
</li>
<li>
<p><strong>[枚举所有子集]</strong>：<br>
枚举 0 到 (1 &lt;&lt; n) - 1 中的每个数字 i，然后将数字 i 转化为二进制，<br>
如果 i 的第 j 位是 1，表示集合 i 包含 a[j]；<br>
如果 i 的第 j 位是 0，表示集合 i 不包含 a[j]。</p>
</li>
</ul>
<h4 id="3-变式">3. 变式</h4>
<ol>
<li>
<p><strong>[枚举大小为k的所有子集]</strong><br>
从 i = (1 &lt;&lt; k) - 1 开始枚举，每次找比它大的下一个包含k个1的二进制数，方法如下：</p>
<ul>
<li>令 x = lowbit(i)，表示当前 i 的靠右的 1 的权值</li>
<li>令 y = i + x，即让 y 等于 i 的最低 “1” 发生进位后的数字，此时必然有 y 中 1 的个数小于等于k</li>
<li>通过 (i &amp; -y) 得到由于进位而导致的所有从 1 变成 0 的位，然后将其除以 x 来去掉右边的所有 0 , 然后再继续右移 1 位来去掉一个 1 (因为进位后在左侧会有一个 0 变成 1) 。这样得到的数再 和 y 或一下，就可以得到下一个包含 k 个 1 的数字。 总结起来就是 i = ((i &amp; -y) / x) &gt;&gt; 1 | y。</li>
</ul>
</li>
<li>
<p><strong>[枚举一个给定集合 x 的所有子集]</strong><br>
从 全集 i = x 开始，从大到小枚举子集，方法如下：</p>
<ul>
<li>i = (i - 1) &amp; x. 即通过减1来缩小子集，通过&amp;x来限定在x的子集中。</li>
</ul>
</li>
<li>
<p><strong>[枚举一个给定集合 x 的所有超集]</strong><br>
从 最小集 i = x 开始，从小到大枚举超集，方法如下：</p>
<ul>
<li>i = (i + 1) | x. 即通过+1来扩大集合，通过|x来限定生成的集合必定包含x。</li>
</ul>
</li>
</ol>
<h4 id="4-模板">4. 模板</h4>
<ul>
<li><strong>打印数字 i 代表的集合</strong></li>
</ul>
<pre><code>int n, a[maxn];  // 长度为 n 的序列

void print_subset(int s){  // 打印 s 所表示的子集
	for(int i = 0; i &lt; n; i ++){
		if(s &amp; (1 &lt;&lt; i)) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}
</code></pre>
<ul>
<li><strong>枚举所有子集</strong></li>
</ul>
<pre><code>void solve() {
    for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) {
        print_subset(i);  // 用二进制数字i表示一个子集
    }
} 
</code></pre>
<ul>
<li><strong>枚举所有大小为 k 的子集</strong></li>
</ul>
<pre><code>void solve(int k) {
	for(int i = (1 &lt;&lt; k) - 1; i &lt; (1 &lt;&lt; n);) {
		print_subset(i);
		int x = i &amp; -i, y = i + x;
		i = (((i &amp; ~y) / x ) &gt;&gt; 1) | y;
	}
}
</code></pre>
<ul>
<li><strong>[枚举一个给定集合 x 的所有子集]</strong></li>
</ul>
<pre><code>void solve(int x) {
	for (int i = x; i &gt;= 0; i = (i - 1) &amp; x) {
		print_subset(i);
	}
}
</code></pre>
<ul>
<li><strong>[枚举一个给定集合 x 的所有超集]</strong></li>
</ul>
<pre><code>void solve(int x) {
	for (int i = x; i &lt; (1 &lt;&lt; n); i = (i + 1) | x) {
		print_subset(i);
	}
}
</code></pre>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="三-回溯法">三、回溯法</h3>
<h4 id="1-定义-3">1. 定义</h4>
<p>即利用递归的回溯过程，来进行状态的“还原”，从而枚举出所有的情形。</p>
<h4 id="2-解析-3">2. 解析</h4>
<p>紫薯告诉我们，<strong>回溯法总是比生成-测试法快得多</strong>。</p>
<ul>
<li>需要一个<strong>递归深度值 idx</strong>（或一个坐标x, y）表示当前递归进度</li>
<li>需要一个值 <strong>cur 表示根据当前选择所形成的值</strong>（如和值等）。</li>
<li>需要一个 <strong>vis 数组</strong>标记已经递归过的位置（在回溯时还原）</li>
</ul>
<h4 id="3-模板-2">3. 模板</h4>
<pre><code>int n, vis[maxn];
 
void solve(int idx, int cur) {
    if(idx == n - 1) {  // 递归出口
        // 根据 cur 更新 ans
        return;
    }
    for(int i = 1; i &lt;= n; i ++) if(!vis[i] &amp;&amp; 其它条件) {
        vis[i] = 1;
        solve(idx + 1, cur + i);  // 递归
        vis[i] = 0;  // 还原
    }
}
 
int main() {
    ......
    vis[1] = 1;
    solve(0, 1);
    ......
}
</code></pre>
<h4 id="4-例题">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/2a2e5ff2a5b6479dacca40edafe57b25">Uva 524</a><br>
<a href="https://blog.nowcoder.net/n/2762e03342d740f3aa4bb69b8f9c8775">Uva 167 (八皇后)</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<h3 id="四-迭代加深搜索ida">四、迭代加深搜索（IDA*）</h3>
<h4 id="1-定义-4">1. 定义</h4>
<p>一种通过<strong>多次dfs</strong>找解的算法。<br>
从小到大枚举dfs深度上限maxd，每次执行只考虑不超过maxd的节点。<br>
IDA* 能进行关于深度的剪枝，从而提高效率。<br>
一般回溯法可以解决的问题，但是 <strong>回溯时枚举边界无法确定时</strong>，可以使用IDA*算法。</p>
<h4 id="2-解析-4">2. 解析</h4>
<ul>
<li>枚举深搜的最大深度maxd，然后在maxd的限制下去进行dfs，并利用maxd来对dfs进行剪枝，使得dfs的每一层可以很快枚举完。</li>
<li>每次针对一个maxd进行dfs时，实际上就是相当于反复去解答这道题，因此也要重新初始化。</li>
<li>由于需要<strong>由maxd限制递归层数</strong>，因此dfs函数的参数必须包括一个idx表示当前递归的层数。<br>
剩下的参数就按照需要进行增添。</li>
<li><em><em>优化技巧（IDA</em> 的精髓）</em><em>：<br>
1、考虑</em><em>最优性剪枝，即通过maxd可以判断出该次迭代已经不可能得到答案时要及时退出</em>*；<br>
2、考虑节点的搜索顺序，以加快搜索到目标节点。</li>
</ul>
<h4 id="3-模板-3">3. 模板</h4>
<pre><code>bool dfs(int maxd, int idx, ......) {
    if(idx == maxd) {  // 达到当前枚举的最大深度maxd就处理完后退出
        if(不满足条件) return 0;
        else {
            ...... // 记录答案
            return 1;
        }
    }
    if(通过maxd可以判断出该次迭代已经不可能得到答案) return 0;  // 精髓：最优性剪枝
    for(正常的dfs枚举) {
        if(不满足条件) continue;
        if(dfs(maxd, idx + 1, ......)) return 1;
    }
    return 0;
}
 
int main() {
    ......
    for(int maxd = 1; ; maxd ++) {
        memset(ans, -1, sizeof(ans));  // 每次 dfs 需要重新初始化
        if(dfs(maxd, 0, ....)) break;  // 找到解就退出
    }
    ......
</code></pre>
<h4 id="4-例题-2">4. 例题</h4>
<p><a href="https://blog.nowcoder.net/n/6aeaadbaf50347a7979571da59dce6b3">Uva 12558</a><br>
<a href="https://vjudge.net/problem/UVA-1343">Uva 1343</a></p>
<p><br><center><strong>*   *   *</strong></center></br></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Fin
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></span></p>
]]></content>
    </entry>
</feed>